%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module: location-reference
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{location-reference}}

\subsection{Introduction}

A \term{location-reference} is a reference to an object in a document.
These objects are named \term{location}. Examples of locations are
pages, chapters, sections, paragraphs, glossaries, verses \etc{}

An index is structured into indexentries which usually own a list of
location-references. This part implements location-references and is
responsible for their construction and management.

Since the structure of a location-reference must match a
location-class description their stucture is somehow comparable.
A location-reference consists of subparts called \term{layers}. Each
layer corresponds to a basetype.


\subsection{Abstract Specification}

\subsubsection{Definition}

A location-reference is a set
\begin{center}
  $\{$ \func{layers, ordnums, catattr, locclass} $\}$
\end{center}
with
\begin{deflistit}{locclassXX}
\item [layers] is a \tstrlist
\item [ordnums] is a \tintlist
\item [catattr] is a \tcatattr
\item [locclass] is a \tloccls.
\end{deflistit}


\subsubsection{Operation}


\subsection{Concrete Specification}

This is one of the most important parts of the project. Because of its
complexity we will try to enter the source description in a more
educational way starting with the global classes and structures and
extending to more complex issues. After general introduction we
concentrate on the \term{markup} of the introduced objects. Finally we
present pretty-printing functions and other stuff which are less
important.

\subsubsection{External interface}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{location-reference}}

<<Class \class{location-reference}>>=
(defclass location-reference ()
    ())
@ %def location-reference

<<Export-list of submodule \module{locref}>>=
(export 'location-reference)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{structured-locref}}

We start with class \class{structured-locref}. The implementation is
directly derived from its abstract description.

<<Class \class{structured-locref}>>=
(defclass structured-locref (location-reference)
    ((layers   :reader get-layers                    :initarg :layers)
     (ordnums  :reader get-ordnums                   :initarg :ordnums)
     (catattr  :reader get-catattr                   :initarg :catattr)
     (locclass :reader get-locclass                  :initarg :locclass)
     (state    :reader get-state  :writer set-state  :initarg :state)
     (origin   :reader get-origin :writer set-origin :initform 'nil)))
@ %def structured-locref

\no The definition of the constructor is a little bit tricky since it
uses [[&allow-other-keys]] to allow other (for creation of instances
unneccessary) keys specifiers to be given. We gain a much easier code
when this function is called from outside (\emph{see} function
[[gen-indexentries]] and [[forall-location-classes]] for more
details).

<<Class \class{structured-locref}>>=
(defun make-structured-locref (&key (layers '())  (ordnums '())
                                     (catattr nil) (locclass nil)
                                     &allow-other-keys)
  (make-instance 'structured-locref
                 :layers  layers   :ordnums  ordnums
                 :state   'locref-state-normal
                 :catattr catattr  :locclass locclass))
@ %def make-structured-locref

<<Class \class{structured-locref}>>=
(defun make-virtual-structured-locref (&key (layers '())  (ordnums '())
                                             (catattr nil) (locclass nil)
                                             &allow-other-keys)
  (make-instance 'structured-locref
                 :layers  layers   :ordnums  ordnums
                 :state   'locref-state-virtual
                 :catattr catattr  :locclass locclass))
@ %def make-virtual-structured-locref

\no The states a structured-locref can be in are
[['locref-state-normal]] and [['locref-state-virtual]]. They should be
accessed only by the following mutators and predicates.

<<Class \class{structured-locref}>>=
(defmethod state-normal-p ((locref structured-locref))
  (eql 'locref-state-normal (get-state locref)))

(defmethod state-virtual-p ((locref structured-locref))
  (eql 'locref-state-virtual (get-state locref)))

(defmethod state-deleted-p ((locref structured-locref))
  (eql 'locref-state-deleted (get-state locref)))

(defmethod set-state-normal ((locref structured-locref))
  (set-state 'locref-state-normal locref)
  locref)

(defmethod set-state-virtual ((locref structured-locref))
  (set-state 'locref-state-virtual locref)
  locref)

(defmethod set-state-deleted ((locref structured-locref))
  (set-state 'locref-state-deleted locref)
  locref)
@ %def state-normal-p state-virtual-p state-deleted-p set-state-normal set-state-virtual set-state-deleted

<<Export-list of submodule \module{locref}>>=
(export '(structured-locref
          make-structured-locref
          make-virtual-structured-locref
          get-layers get-ordnums get-catattr get-locclass
          get-origin       set-origin
          state-normal-p   state-virtual-p   state-deleted-p
          set-state-normal set-state-virtual set-state-deleted
          ))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{category-attribute}}

Here we define the category-attribute-slots.

\begin{slots}{processing-ordnum}
\item [name] Category-attributes have a name that is specified by the
  user and stored in this slot.
\item [ordnum] By defining the category-attribute-groups each
  category-attribute is given a ordnum which says that it is member of
  the [[ordnum]]th category-attribute-group. Used for sorting-purposes.
\item [sort-ordnum] defines the position in the sort-order.
\item [processing-ordnum] defines the order that is defined by the
  topologial sort of the \irule{drop-if-merged}-rules.
\item [type] gives information if this cat-attr is declared as a
  \term{single} group or as a \term{member} of a group. The respective
  symbols are [[catattr-single]] and [[catattr-member]].
\item [markup] The user also can specify a special markup for each
  attribute.
\end{slots}

<<Class \class{category-attribute}>>=
(defclass category-attribute ()
    ((name   :reader get-name                      :initarg :name)
     (catattr-grp-ordnum :reader get-catattr-grp-ordnum
                         :writer set-catattr-grp-ordnum
                         :initarg :ordnum)
     (sort-ordnum        :reader get-sort-ordnum
                         :writer set-sort-ordnum
                         :initform 0)
     (processing-ordnum  :reader get-processing-ordnum
                         :writer set-processing-ordnum
                         :initform 0)
     (type   :reader get-type   :writer set-type   :initarg :type)
     (markup :reader get-markup :writer set-markup :initarg :markup)))

(defun make-category-attribute (attr-name &optional (markup nil))
  (make-instance 'category-attribute
                 :name attr-name :markup markup))
@ %def category-attribute make-category-attribute

\no When spcifying the category-attribute-groups each catattr is
informed about its [[ordnum]] and [[type]]. These can be set directly
by using [[set-ordnum]] and [[set-type]].

<<Export-list of submodule \module{locref}>>=
(export '(category-attribute make-category-attribute
          get-name
          get-catattr-grp-ordnum set-catattr-grp-ordnum
          get-sort-ordnum        set-sort-ordnum
          get-processing-ordnum  set-processing-ordnum
          get-type   set-type
          get-markup set-markup))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%\subsubsection{Class \class{locref-layer}}
%%
%%A \term{structured-locref-layer} layer is a \tstring. It is the
%%smallest entity in the structured-locref data hierarchy. It consists
%%only of the string that matched with the corresponding layer during
%%the input-parsing of raw location-references.
%%
%%<class \class{locref-layer}>>=
%%(defclass locref-layer ()
%%    ((layer  :reader get-layer  :initarg :layer)))
%%
%%(defun make-locref-layer (layer)
%%  (make-instance 'locref-layer :layer layer))
%%@ %def locref-layer make-locref-layer


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sorting of location-references}

We are now interested how to sort a list of location-references
belonging to a indexentry. When building ranges and examine
successor-relationships we need three sorting criteria that are
possible with location-references.
%%
\begin{enumerate}
\item The order given by the location-class. It is defined via the
  [[location-class<]]-relation (\look{sec:location-class}).
\item The order given by the location-ordnums. The ordnums are a list
  of numbers. To compare two lists of ordnums, we successively compare
  the order-numbers and stop, if we find one number being smaller than
  the other.
\item The order given by the category-attribute ([[catattr<]]).
\end{enumerate}
%%
We define the three predicates for their \emph{less-than}- and
\emph{equal}-relations. Here are the predicates for the location-class
relation.

<<Sorting location-references>>=
(defun locref-class< (locref-1 locref-2)
  (< (get-locclass locref-1) (get-locclass locref-2)))

(defun locref-class= (locref-1 locref-2)
  (= (get-locclass locref-1) (get-locclass locref-2)))
@ %def locref-class< locref-class=

\no Here follows the implementation of the ordnum-relation.

<<Sorting location-references>>=
(defun locref-ordnum< (ordnum-list-1 ordnum-list-2)
  (declare (inline))
  (cond ((equal ordnum-list-1 ordnum-list-2) nil)
        (t (do ((rest-1 ordnum-list-1 (cdr rest-1))
                (rest-2 ordnum-list-2 (cdr rest-2)))
               ((or (endp rest-1) (endp rest-2)
                    (/= (first rest-1) (first rest-2)))
                  (cond ((endp rest-1) t)
                        ((endp rest-2) nil)
                        (t (< (first rest-1) (first rest-2)))))))))

(defun locref-ordnum= (ordnum-list-1 ordnum-list-2)
  (declare (inline))
  (equal ordnum-list-1 ordnum-list-2))
@ %def locref-ordnum< locref-ordnum=

\no Finally we define a combined version of both. I'm not yet sure if
i really need it.

<<Sorting location-references>>=
(defun locref< (locref-1 locref-2)
  (cond ((locref-class= locref-1 locref-2)
           (locref-ordnum< locref-1 locref-2))
        (t (locref-class< locref-1 locref-2))))

(defun locref= (locref-1 locref-2)
  (and (eql (get-catattr locref-1) (get-catattr locref-2))
       (eql (get-catattr locref-1) (get-catattr locref-2))
       (locref-ordnum= (get-ordnums locref-1) (get-ordnums locref-2))))
@ %def locref< locref=

<<Export-list of submodule \module{locref}>>=
(export '(locref-class<  locref-class=
          locref-ordnum< locref-ordnum=
          locref<        locref=))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The module root}

<<*>>=
;; $Id$
;;

(in-package 'locref)
(provide 'locref)

(eval-when (compile load)
  (use-package 'clos)
  (use-package 'xp)
  (unless (find-package 'base)
    (load 'base))
  (use-package 'base))

<<Submodule \module{basetype}>>
<<Submodule \module{locclass}>>
<<Submodule \module{locref}>>

;(eval-when (compile load)
;  (require 'ranges))

<<pretty-print>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))
@

<<Submodule \module{locref}>>=
<<Class \class{location-reference}>>
<<Class \class{structured-locref}>>
<<Class \class{category-attribute}>>
<<Sorting location-references>>
<<markup methods>>
<<Export-list of submodule \module{locref}>>
@

<<RCS-Identifier>>=
("locref" . "$Id$")
@


\subsubsection{Markup}


\no Markup of a location-reference ist currently implemented as a
simple printing of all layers and separators.

<<markup methods>>=
(defmethod markup-object ((locref structured-locref)
                          (dummmy-markup-list  list)
                          (context-list list)
                          (dummmy-env-stack    list))
  (dolist (context-string context-list)
    (mprint context-string))
  (let ((layers (get-layers locref)))
    (dolist (loccls-layer (get-layers (get-locclass locref)))
      (typecase loccls-layer
        (loccls-layer
           (markup-object (pop layers) '() '() '()))
        (loccls-separator
           (markup-object loccls-layer '() '() '()))))))
@


\no Markup of a location-layer ist currently implemented as a simple
printing of the layer-string.

<<markup methods>>=
;(defmethod markup-object ((layer locref-layer)
;                          (dummmy-markup-list  list)
;                          (dummmy-context-list list)
;                          (dummmy-env-stack    list))
;  (mprint (get-layer layer)))
@


\subsubsection{Pretty-printing}

\no A block for pretty-printing a location-reference.

<<pretty-print>>=
(defun pprint-structured-locref (s locref)
  (pprint-logical-block
   (s nil :prefix "[" :suffix "]")
   ;(pprint-indent :block 2 s)
   (cond ((state-normal-p  locref) (write-string "N:" s))
         ((state-virtual-p locref) (write-string "V:" s))
         (t (write-string "D:" s)))
   (write (get-layers locref) :stream s)
   (write-string "=" s)
   (write (get-ordnums locref) :stream s)
   (write-string ";" s)
   (pprint-newline :fill s)
   (write (get-locclass locref) :stream s)
   (write-string ";" s)
   (pprint-newline :fill s)
   (write (get-catattr locref) :stream s)
   (when (get-origin locref)
     (write-string "<-" s)
     (write (get-catattr (get-origin locref)) :stream s))
   ))

(set-pprint-dispatch 'structured-locref #'pprint-structured-locref)
@

<<pretty-print>>=
(set-pprint-dispatch 'category-attribute
                     #'(lambda (s catattr)
                         (write-string "`" s)
                         (write-string (get-name catattr) s)
                         (write-string "'" s)))
@

%% Local Variables:
%% mode: latex
%% End:
%%
%% $Log$
%% Revision 1.10  1996/01/09 14:28:38  kehr
%% Moved submodule `ranges' from this module to module `index'.
%% Minor modifications in conjunction with the rewrite of module `index'.
%%
%% Revision 1.9  1995/12/19  11:00:15  kehr
%% Significant changes.
%%
%% Revision 1.8  1995/12/15  17:09:52  kehr
%% Modified sources for the new module structure.
%%
%% Revision 1.7  1995/12/07  18:15:16  kehr
%% Minor modifications.
%%
%% Revision 1.6  1995/12/05  18:47:09  kehr
%% Minor changes (nreverse etc.)
%%
%% Revision 1.5  1995/12/05  13:53:41  kehr
%% Complete restructuring of submodule `locclass'. New generic functions
%% introduced and separation of standard- and var-classes implemented.
%%
%% Revision 1.4  1995/11/29  16:53:30  kehr
%% Changed class hierarchy below class `location-class'. Defined a
%% location-class< predicate and wrote several regression tests. Wrote a
%% lot of documentation for submodule `locclass'.
%%
%% Revision 1.3  1995/11/22  16:45:16  kehr
%% Corrected the eval-when construct. But I don't understand, why it
%% seemed to work yesterday :-)
%%
%% Revision 1.2  1995/11/19  18:39:06  kehr
%% Introduced packages base and locref.
%%
%% Revision 1.1  1995/11/08  16:13:25  kehr
%% Initial checkin.
%%
%% Revision 1.12  1995/07/28  10:41:18  kehr
%% Added simple markup for location-references and ranges. Currently
%% exists no support for differen layer-markup. A location-reference is
%% always printed as a whole.
%%
%% Revision 1.11  1995/07/27  23:59:04  kehr
%% Added support for keword-markup.
%%
%% Revision 1.10  1995/07/27  14:36:44  kehr
%% Added support for joining of locref-separated-groups.
%%
%% Revision 1.9  1995/07/26  16:19:54  kehr
%% Added support for the pretty-printer module. Output of data-structures
%% now looks more readable.
%%
%% Revision 1.8  1995/07/23  20:48:35  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.7  1995/07/23  14:14:09  kehr
%% Added support for merge-to--rule. Now works and creates
%% virtual-attributes as expected.
%%
%% Revision 1.6  1995/07/15  20:50:24  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.5  1995/07/11  23:33:09  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.4  1995/07/11  15:14:16  kehr
%% Today I finished the definition of indexentries. They now will be
%% inserted into the index when a appropriate location-class was finished.
%%
%% Revision 1.3  1995/07/10  23:26:59  kehr
%% Corrected bugs that caused location-class-matching to fail. Also
%% discovered some bugs in matching under certain circumstances, I hadn't
%% tested so far.
%%
%% Revision 1.2  1995/07/10  19:08:17  kehr
%% Now corrected setup of location-classes. The was a bug in the
%% add-indexclass methods and some wrong reader-functions.
%%
%% Revision 1.1  1995/07/10  00:58:18  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
