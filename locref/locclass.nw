%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Submodule: location-class
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%

\ModuleTitle{}

\section{Submodule \module{locclass}}

\subsection{Introduction}

A \term{location-class} describes the structure of
\term{location-references} that may appear in the document. Every
instance of a location-reference must belong to exactly one
location-class. If a location-reference potentially matches several
location-class descriptions exactly one of them must be the class the
location-reference belongs to. Currently three location-class types
are supported:
%%
\begin{center}
  \term{Standard-class}, \term{Var-class}, \term{Crossreference-class}.
\end{center}
%%
\term{Standard}- and \term{Var-classes} consist of \term{basetypes}
and \term{separators}. A standard-class has a fixed structure whereas
a var-class actually describes a family of standard-classes.

A \term{Crossreference-class} describes how cross references such as
\textit{see}, \textit{see also under} \etc are represented.


\subsection{Abstract Specification}

\subsubsection{Definition}

A location-class is a list of layers and separators. A \term{layer} is
based on the basetypes and consists of a string and a order number. A
\term{separator} is a string.

\subsubsection{Operation}


\subsection{Concrete Specification}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{External interface}

The following symbols are exported:

\begin{defvcls}{location-class}{}%
  Virtual base-class for all location-classes
\end{defvcls}

\begin{defvcls}{layered-location-class}{}
  Virtual base-class for all layered location-classes. Subclass of
  \class{location-class}.
\end{defvcls}

\begin{defcls}{standard-location-class}{}
  Describes all location-classes of fixed structure.\\Subclass of
  \cmd{layered-location-class}.
\end{defcls}

\begin{defcls}{var-location-class}{}
  Describes all location-classes of variable structure.\\Subclass of
  \cmd{layered-location-class}.
\end{defcls}

\begin{defunc}{checked-make-standard-location-class}
  {\tstring \x \tstrlist \res \type{standard-location-class}}%%
  Constructor of \class{standard-location-class}.
\end{defunc}

\begin{defunc}{checked-make-var-location-class}
  {\tstring \x \tstrlist \res \type{var-location-class}}%%
  Constructor of \class{var-location-class}.
\end{defunc}

\begin{defcls}{loccls-layer}{}
  Describes the layer of a layered location-class.
\end{defcls}

\begin{defunc}{make-loccls-layer}
  {\tstring \x \tmarkup \res \type{loccls-layer}}%%
  Constructor of \class{loccls-layer}.
\end{defunc}

\begin{defcls}{loccls-separator}{}
  Describes the separator of a layered location-class.
\end{defcls}

\begin{defunc}{make-loccls-separator}%%
  {\tstring \x \tmarkup \res \type{loccls-separator}}%%
  Constructor of \class{var-location-class}.
\end{defunc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \sans{location-class}}
\label{sec:location-class}

A location-class is the abstract base-class of all location-class
types. The only common slot to all subclasses is [[name]].

<<class \class{location-class}>>=
(defclass location-class ()
    ((name    :reader   get-name   :initarg :name)
     (ordnum  :accessor get-ordnum :initform (gen-next-loccls-ordnum))))
@ %def location-class

\no Every derived class must define a constructor-function
[[checked-make-name-location-class]] that makes some validation-checks
and returns an instance of the specific class. Its signature may vary
due to the different possibilities but its first argument must be a
name that is stored in the [[name]]-slot. Additionally every derived
location-class must implement a method [[perform-match]]
(\look{sec:match.strings}).

<<export-list of module \module{locref}>>=
(export '(location-class perform-match))
@

\no We define a relation between location-classes that is used to sort
instances of location-references due to the order of their
corresponding location-classes. We introduce the relations
[[location-class<]] and [[location-class=]] that compare two
location-classes [[loccls-1]] and [[loccls-2]] and returns [[t]] if
the first one is \emph{smaller} than/\emph{equal} to the second one.

<<class \class{location-class}>>=
(defgeneric location-class< (location-class-1 location-class-2))

(defgeneric location-class= (location-class-1 location-class-2))
@ %def location-class< location-class=

\no It is implemented as a generic function to achieve a simple
implementation that is extendable.

The currently implemented behaviour defines this relation according to
the order in which location-classes are defined.  We use a variable
[[*curr-loccls-ordnum*]] to keep track of the current number with
initial value 0 and increase it everytime we declare a new
location-class by calling [[gen-next-loccls-ordnum]]. It is called in
the [[:initform]] of the class-descriptions.

<<class \class{location-class}>>=
(defparameter *curr-loccls-ordnum* 0)

(defun gen-next-loccls-ordnum ()
  (incf *curr-loccls-ordnum*))
@ %def gen-next-loccls-ordnum

\no The default implementation that needs to be modified later is as
follows:

<<class \class{location-class}>>=
(defmethod location-class< ((loccls-1 location-class)
                            (loccls-2 location-class))
  (< (get-ordnum loccls-1) (get-ordnum loccls-2)))

(defmethod location-class= ((loccls-1 location-class)
                            (loccls-2 location-class))
  (= (get-ordnum loccls-1) (get-ordnum loccls-2)))
@ %def location-class< location-class=


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \sans{layered-location-class}}

\no We combine Standard-classes and Var-classes to a Layered-class
because they share multiple similiarities.

<<class \class{layered-location-class}>>=
(defclass layered-location-class (location-class)
    ((layers      :reader   get-layers      :initarg :layers)
     (join-layers :reader   get-join-layers :initarg :join-layers))
  )
@ %def layered-location-class

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \sans{standard-location-class}}

<<class \class{standard-location-class}>>=
(defclass standard-location-class (layered-location-class)
    ())

(defun make-standard-location-class (name layers join-layers)
  (make-instance 'standard-location-class
                 :name name :layers layers :join-layers join-layers))

(defmethod show ((loccls layered-location-class))
  (format t "[LocCls `~A': (" (get-name loccls))
  (show (get-layers loccls))
  (show (get-join-layers loccls))
  (write-string ")")
  (values))
@ %def standard-location-class make-standard-location-class

\no We add a function for a checked creation of a location-class, that
checks for correct arguments. Currently we just forward it to the
normal instantiation without any validation.

<<class \class{standard-location-class}>>=
(defun checked-make-standard-location-class (name layers join-layers)
  (make-standard-location-class name layers join-layers))
@ %def checked-make-location-class


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \sans{var-location-class}}

<<class \class{var-location-class}>>=
(defclass var-location-class (layered-location-class)
    ())

(defun make-var-location-class (name layers join-layers)
  (make-instance 'var-location-class
                 :name name :layers layers :join-layers join-layers))

(defmethod show ((loccls layered-location-class))
  (format t "[LocCls `~A': (" (get-name loccls))
  (show (get-layers loccls))
  (show (get-join-layers loccls))
  (write-string ")")
  (values))
@ %def var-location-class make-var-location-class

<<class \class{var-location-class}>>=
(defun checked-make-var-location-class (name layers join-layers)
  (make-var-location-class name layers join-layers))
@ %def checked-make-var-location-class

\medskip

\no Here follows the list of all exported location-classes and their
constructors.

<<export-list of module \module{locref}>>=
(export '(layered-location-class
          standard-location-class
          var-location-class
          checked-make-layered-location-class
          checked-make-standard-location-class
          checked-make-var-location-class))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Other stuff --- still a lot of kluges}

This function counts the number of basetypes in a layer-list. It is
used to initialize the [[join-layers]]-value of a location-class.

<<class \class{layered-location-class}>>=
(defun num-of-basetypes (layers)
  (list (count nil layers
               :test #'(lambda (dummy layer)
                         (declare (ignore dummy))
                         (typep layer 'loccls-layer)))))
@

This function checks whether given level [[level-number]] appears in
the list of valid layers of the location-class. Is its used to check
if two location-references are successors that may be joined at at
certain level.

<<class \class{standard-location-class}>>=
(defun joinable-on-layer-x-p (loccls-name level-number)
  (find level-number
          (get-join-layers loccls-name)))
@

This function returns the minimum range-length for a given
location-class. Only if a range is built whose length is greater or
equal to this value a range is valid.

We haven't implemented location-class specific values yet, so we just
return the fixed constant [[3]] for now. The value this function
returns must be at least greater that 1 because a range of length 1
should never be valid.

<<class \class{standard-location-class}>>=
(defun get-minimum-range-length (loccls-name)
  (declare (ignore loccls-name))
  3)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \sans{loccls-layer}}
\label{sec:loccls-layer}

A \term{location-class-layer} is based upon a basetype. We define this
as an extra class to be free for future additions. (Later on... Great
idea, because we now store the markup-information into the class, too.)

<<class \class{loccls-layer}>>=
(defclass loccls-layer ()
    ((basetype :reader get-basetype :initarg :basetype)
     (markup   :reader get-markup   :initarg :markup)))

(defun make-loccls-layer (basetype markup)
  (make-instance 'loccls-layer :basetype basetype :markup markup))

(defmethod show ((layer loccls-layer))
  (show (get-basetype layer))
;  (show (get-markup   layer))
  (values))
@ %def loccls-layer make-loccls-layer

<<export-list of module \module{locref}>>=
(export '(loccls-layer make-loccls-layer))
@

\no To perform matching of a string [[locstring]] against a layer
[[layer]] we just forward the result to the basetype of thar
location-class layer.

<<class \class{loccls-layer}>>=
(defmethod prefix-match ((locstring string)
                         (layer     loccls-layer))
  (prefix-match locstring (get-basetype layer)))
@ %def prefix-match


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \sans{loccls-separator}}
\label{sec:loccls-separator}

The separators is simply a string. We define this as an extra class
for future extensions.

<<class \class{loccls-separator}>>=
(defclass loccls-separator ()
    ((separator  :reader get-separator  :initarg :separator)
     (markup     :reader get-markup     :initarg :markup)))

(defun make-loccls-separator (separator markup)
  (make-instance 'loccls-separator :separator separator :markup markup))

(defmethod show ((separator loccls-separator))
  (write-string (get-separator separator))
  ;;  (show (get-markup separator))
  (values))
@ %def loccls-separator make-loccls-separator

<<export-list of module \module{locref}>>=
(export '(loccls-separator make-loccls-separator))
@

\no To perform matching of a string [[locstring]] against a separator
[[separator]] we must decide, if [[sepstr]] is a prefix of
[[locstring]]. If this is true we return the matched string---which is
then equal to [[locstring]]--the rest-string and the value [[t]] to
indicate success or a multiple value [[(nil nil nil)]] otherwise.

\begin{note}
  [[(string/= sepstr locstring)]] returns [[nil]] if [[sepstr]] equals
  [[locstring]] and $n$ if they share a common prefix of length $n$.
  [[(subseq locstring seplen)]] returns the rest-string of
  [[locstring]] starting from position [[seplen]].
\end{note}

<<class \class{loccls-separator}>>=
(defmethod prefix-match ((locstring string)
                         (separator loccls-separator))
  (let* ((sepstr (get-separator separator))
         (seplen (length sepstr))
         (match-len (string/= sepstr locstring)))
    (cond ((or (null match-len) (eql seplen match-len))
             (values locstring (subseq locstring seplen) t))
          (t (values nil nil nil)))))
@ %def perform-match


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Matching strings with location-classes}
\label{sec:match.strings}

During parsing the input stream of raw-index entries one of the tasks
to be done is the matching of the location-reference strings against a
location-class description. As mentioned in the technical description
we must distiguish between standard- and var-classes.
Standard-classes are of fixed structure and the matching succeeds only
if \emph{all} layers and separators together match completely the
given string. Var-classes are a set of different classes and we must
perform so-called \emph{prefix-matching}.

One remaining problem is the matching of separators in var-classes. It
is not yet stated if separators must match always or not. If the
strings `[[1]]', `[[1.]]' and `[[1.2]]' are compared to var-class
`[[num.num]]' the first and third should always match, but is not yet
clear if the second alternative should be valid or not.  Strictly
spoken we must declare if the separator acts as a \emph{prefix} to
hierarchy No.~2 or if it acts like a \emph{postfix} to hierarchy
No.~1.
\begin{quote}
  As a solution solve this problem we declare all three possibilities
  as valid matches. A separator may be both, a prefix or a postfix.
  This is generally more flexible and less restrictive.
\end{quote}
We implement those two strategies by defining a generic function
[[perform-match]] that dispatches over all kinds of location-classes.
The corresponding methods implement the described matching techniques.

This function tries to match the given [[locstring]] against the given
location-class [[loccls]]. This is achieved by successively matching
all layers and separators against the string. It returns a
multiple-value of the form
\begin{center}
  (\emph{layer-list} : \tstrlist, \emph{ordnum-list} : \tintlist) \quad
  or \quad ([[nil nil]]).
\end{center}
The second alternative is used to indicate that a match was not
possible.

<<Matching strings with location-classes>>=
(defgeneric perform-match (locstring locclass))
@ %def perform-match

\subsubsection*{Matching strings with standard-location-classes}

We start with matching against standard-classes. So what is the way of
success? Ok, at first we iterate over all layers of the locclass
description until one of the following conditions occurs:
\begin{enumerate}
\item [[layers]] and [[locstring]] are both completely eaten up. This
  indicates a correct and complete match.
\item only one of [[layers]] and [[locstring]] is completely eaten up.
  This indicates an error.
\item [[give-up]] is true which indicates that a match failed.
\end{enumerate}
Inside the loop we match [[locstring]] against each layer by calling
[[prefix-match]] dispatching over objects of type \type{locref-layer}
or \type{loccls-separator}. If the resulting [[ordnum]] is [[nil]]
indicating a mismatch we set the [[give-up]]-flag, otherwise the
[[ordnum]] is appended to [[layer-list]]. If we dispatched over a
separator we just continue.

Finally we must check if there was no giving up and if not we return
the appropriate multiple value, otherwise we return the multiple value
[[(nil nil)]] indicating an error.

<<Matching strings with location-classes>>=
(defmethod perform-match ((locstring string)
                          (loccls    standard-location-class))
  (let ((layer-list  '())
        (ordnum-list '())
        (give-up        nil)
        (matched-string nil)
        (rest-string    nil)
        (ordnum         nil))
    (do ((layers (get-layers loccls) (cdr layers)))
        ((or give-up
             (let ((empty-string (= 0 (length locstring)))
                   (empty-list   (endp layers)))
               (cond ((and empty-string empty-list) t)
                     ((or  empty-string empty-list) (setq give-up t))
                     (t nil)))))
      (let ((curr-layer (car layers)))
        (multiple-value-setq (matched-string rest-string ordnum)
          (prefix-match locstring curr-layer))
        (cond ((eq ordnum nil) (setq give-up t))
              ((numberp ordnum)
                 (setq locstring rest-string)
                 (setq layer-list
                       (cons matched-string layer-list))
                 (setq ordnum-list (cons ordnum ordnum-list)))
              (t (setq locstring rest-string)))
        ))
    (if (not give-up)
        (values (nreverse layer-list) (nreverse ordnum-list))
        (values nil nil))))
@ %def perform-match


\subsubsection*{Matching strings with var-location-classes}

Matching with var-classes is similar with standard-classes but the
mechanism must behave differently when the locstring runs out. Here it
is not an error, because we do a prefix-matching.
\begin{note}
  We could share the code between both methods, because they only
  differ in the termination-expression of the [[do]]-loop. For now we
  will stay with this solution.
\end{note}

<<Matching strings with location-classes>>=
(defmethod perform-match ((locstring string)
                          (loccls    var-location-class))
  (let ((layer-list  '())
        (ordnum-list '())
        (give-up        nil)
        (matched-string nil)
        (rest-string    nil)
        (ordnum         nil))
    (do ((layers (get-layers loccls) (cdr layers)))
        ((or give-up
             (let ((empty-string (= 0 (length locstring)))
                   (empty-list   (endp layers)))
               (cond (empty-string t)
                     (empty-list (setq give-up t))
                     (t nil)))))
      (let ((curr-layer (car layers)))
        (multiple-value-setq (matched-string rest-string ordnum)
          (prefix-match locstring curr-layer))
        (cond ((eq ordnum nil) (setq give-up t))
              ((numberp ordnum)
                 (setq locstring rest-string)
                 (setq layer-list
                       (cons matched-string layer-list))
                 (setq ordnum-list (cons ordnum ordnum-list)))
              (t (setq locstring rest-string)))
        ))
    (if (not give-up)
        (values (nreverse layer-list) (nreverse ordnum-list))
        (values nil nil))))
@ %def perform-match


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Markup}

<<markup methods>>=
(defmethod markup-object ((separator loccls-separator)
                          (dummmy-markup-list  list)
                          (dummmy-context-list list)
                          (dummmy-env-stack    list))
  (mprint (get-separator separator)))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The root}

<<*>>=
;; $Id$
;;

(eval-when (compile load)
  (use-package 'clos)
  (use-package 'xp)
  (unless (find-package 'base)
    (load 'base)
    (use-package 'base))
  )

<<class \class{location-class}>>
<<class \class{layered-location-class}>>
<<class \class{standard-location-class}>>
<<class \class{var-location-class}>>
<<class \class{loccls-layer}>>
<<class \class{loccls-separator}>>
<<Matching strings with location-classes>>
<<markup methods>>

<<export-list of module \module{locref}>>
@

\begin{TODO}
\item change declaration of the relation between location-classes
  \texttt{locref<}
\item location-class \class{crossref} still unimplemented
\item implement all \cmd{checked-make-xxx-location-class} functions
\end{TODO}

%% Local Variables:
%% mode: latex
%% TeX-master: t
%% End:
%%
%% $Log$
%% Revision 1.5  1995/12/05 18:47:07  kehr
%% Minor changes (nreverse etc.)
%%
%% Revision 1.4  1995/12/05  13:53:39  kehr
%% Complete restructuring of submodule `locclass'. New generic functions
%% introduced and separation of standard- and var-classes implemented.
%%
%% Revision 1.3  1995/11/29  16:53:29  kehr
%% Changed class hierarchy below class `location-class'. Defined a
%% location-class< predicate and wrote several regression tests. Wrote a
%% lot of documentation for submodule `locclass'.
%%
%% Revision 1.2  1995/11/19  18:39:04  kehr
%% Introduced packages base and locref.
%%
%% Revision 1.1  1995/11/08  16:13:22  kehr
%% Initial checkin.
%%
%% Revision 1.10  1995/07/28  10:41:18  kehr
%% Added simple markup for location-references and ranges. Currently
%% exists no support for differen layer-markup. A location-reference is
%% always printed as a whole.
%%
%% Revision 1.9  1995/07/27  23:59:04  kehr
%% Added support for keword-markup.
%%
%% Revision 1.8  1995/07/27  14:36:44  kehr
%% Added support for joining of locref-separated-groups.
%%
%% Revision 1.7  1995/07/23  20:48:35  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.6  1995/07/15  20:50:23  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.5  1995/07/11  23:33:08  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.4  1995/07/10  23:26:59  kehr
%% Corrected bugs that caused location-class-matching to fail. Also
%% discovered some bugs in matching under certain circumstances, I hadn't
%% tested so far.
%%
%% Revision 1.3  1995/07/10  19:08:17  kehr
%% Now corrected setup of location-classes. The was a bug in the
%% add-indexclass methods and some wrong reader-functions.
%%
%% Revision 1.2  1995/07/10  00:58:17  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
%% Revision 1.1  1995/07/09  18:14:28  kehr
%% Initial checkin.
%%
%%
