<!doctype linuxdoc system>

<!-- This is the compatibility guide of the xindy system.

     $Id$

 -->

<article>

<!-- Title information -->

<title><sf/xindy/

<subtitle>A Flexible Indexing System

<author>Roger Kehr, Institut für Theoretische Informatik, TH-Darmstadt

<date>Makeindex to xindy Compatibility Guide, Edition January 1997 for
xindy version 1.1

<abstract>
<em>This documents describes how <sf/xindy/ &lsqb;5&rsqb; can be used
as a plug-in for <tt/makeindex/ &lsqb;4&rsqb; with minimal effort.
This makes it possible for users to move smoothly to <sf/xindy/ and
learn its features as needed.
</em>
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<!-- ================================================================= -->


<sect>From <tt/makeindex/ to <sf/xindy/
<p>

<sf/xindy/ was developed to overcome some of the limitations of
<tt/makeindex/. The experience with the <tt/makeindex-3/ system by
Joachim Schrod and Gabor Herr &lsqb;3, 6&rsqb; have shown that adding
extensions to <tt/makeindex/ is a difficult job. Thus we have decided
to develop a new indexing tool from scratch. The new tool is based on
a new requirements analysis and offers very interesting features for
processing very complex indexing schemes. The resulting index model is
described in &lsqb;5&rsqb;.

<sect1>Important differences between <tt/makeindex/ and <sf/xindy/
<p>
There are several topics that make it difficult to use <sf/xindy/ as a
real plug-in for <tt/makeindex/:

<descrip>

<tag/Less command-line options./ <sf/xindy/ has dropped the usage of
command-line options in favour of a well-defined indexstyle
description language. Thus, options that could be activated at the
command-line level of <tt/makeindex/ must now be specified in the
indexstyle file. This sounds more restrictive than it is, because the
indexstyle files can be composed from several modules which makes it
possible to write style files in just a few lines of code.

<tag/The concept of attributes./ With <tt/makeindex/ one can assign a
markup to each index entry using the encapsulators (usually following
the vertical bar sign in an index entry command). For example in the
specification

<tscreen><verb>
\index{xindy|bold}
</verb></tscreen>

the encapsulator is <tt/bold/ which encapsulates the page-numbers in
the markup-phase. An additional &TeX;-macro &lsqb;1&rsqb; (if the
system used is &TeX;) must be supplied to assign some markup with the
page number. This concept has completely been dropped in <sf/xindy/ in
favour of a more powerful scheme called <em/attributes/. Attributes
can be used to (i) define several grouping and ordering rules with
locations and we can define (ii) markup-tags for the document
preparation system.

The result of this design decision is that the user is required to
define the attributes in the style file and not in the document
preparation system. The reasons lie in the more powerful markup scheme
of <sf/xindy/ which couldn't be specified in the document processor
anymore. In fact, the <tt/makeindex/-like markup is only a small
subset of <sf/xindy/s features.

<tag/Cross references./ Cross-references were implemented in
<tt/makeindex/ with the encapsulation mechanism, which only served for
markup purposes. This has been completely separated in <sf/xindy/.
Here we distinguish cleanly between attributes and cross references.
This makes it possible to implement <em/checked/ cross references,
i.e. cross-refernces that can be checked if they point to an existing
index entry instead of ``behind-the-moon''.

<tag/Location classes./ <tt/makeindex/ is able to recognize and
process arabic numbers, roman numerals and letter-based alphabets as
specifiers for the indexed location. Simple composite structures of
these are also possible to process. This implicit recognition scheme
has completely been dropped in favour of a well-defined and very
powerful declaration scheme called <em/location-classes/. Thus,
<sf/xindy/ initally does not know any location-class by default and
must be instructed to accept certain location-classes. A typical
declaration might look like:

<tscreen><verb>
(define-location-class "page-numbers" ("arabic-numbers"))
</verb></tscreen>

This declares that page numbers consist of the enumeration of the
arabic numbers. The arabic numbers are referred to as <em/alphabets/.
Users may use the pre-defined alphabets arabic numbers, roman
numerals, etc. or define new alphabets as needed. See the tutorial
that comes with this distribution for some examples.

<tag/Raw-index Parser./ The parser built into <tt/makeindex/ has
completely been separated from the core <sf/xindy/ system. <sf/xindy/
understands a well-defined specification language for the raw index
that is completely different from <tt/makeindex/, but in our opinion
more maintainable than the <tt/makeindex/ format. This requires a
separate filter that transforms arbitrary indices to the <sf/xindy/
format. An example filter is the program <tt/tex2xindy/ that comes
with this distribution.

</descrip>

Summed up, some of the implicit assumptions made by <tt/makeindex/
have been replaced and now burdend to the user. The reason is that
many of <tt/makeindex/'s assumptions were no longer valid in
multi-language environments or documents with arbitrary location
structures. This also characterizes <sf/xindy/ more as a framework
instead of a end-user-tailored product.


<sect1><tt/makeindex4/ and <tt/tex2xindy/: using <sf/xindy/ as a
plug-in
<p>
Despite the inherent problems of making <sf/xindy/ behave equal as
<tt/makeindex/ we have written a program called <tt/makeindex4/ (the
next generation after <tt/makeindex-3/) that tries to do it's very
best. It allows to use <sf/xindy/ almost as a plug-in for
<tt/makeindex/. It is based on the module <tt/makeidx.xdy/ that is
available as a module for the indexstyle. This style can be used as a
starting point for the definition of an index style file as follows.

For example, you have an ordinary &LaTeX;-document &lsqb;2&rsqb; (most
users use <tt/makeindex/ in conjunction with &TeX; or &LaTeX;) for
which you want to prepare an index. The only thing you must do is to
(a) find all the names of your encapsulators used in your document and
(b) define for each of these encapsulators a markup that can call the
appropriate markup-comands. Assuming you are using the encapsulators
<tt/bf/ and <tt/ul/ (for boldface and underlined) you need something
like

<tscreen><verb>
;; sample xindy style file

(define-attributes (("bf" "ul" "default")))

(markup-locref  :open "\bf{" :close "}" :attr "bf")
(markup-locref  :open "\ul{" :close "}" :attr "ul")
</verb></tscreen>

That's all! Now, what do these lines actually mean? The first one (the
two open parenthesis before the names of the attribtues are correct)
defines that if index entries on the same page have different
attributes, then bold takes precedence over underlined and underlined
over default. The default-attribute is automatically assigned to
locations without encapsulator. The next two lines assign a markup to
the attributes (<tt/makeindex/ automatically constructs an appropriate
macro call).

This job is now done automatically by <tt/makeindex4/. It calls
<tt/tex2xindy/ to transform the raw-index into the format suitable for
<sf/xindy/. <tt/tex2xindy/ emits some information about the attributes
(aka. encapsulators in <tt/makeindex/) and the usage of
cross-references into a file, which has the extension `<tt/.sta/'. The
<tt/makeindex4/ program, written in <tt/perl/, parses this
statistics-file and generates the above presented indexstyle commands
for you automatically including the required declaration of all
attributes in the whole index and their markup.

Another problem is the automatic detection of cross-references. As
noted above, <tt/makeindex/ handles cross-references with its
encapsulation mechanism, a scheme which has been dropped in <sf/xindy/
and replaced by a more powerful mechanism. To implement a simple
plug-in mechanism we have extended the syntax of the <tt/tex2xindy/
filter to identify encapsulators of the form

<tscreen><verb>
\indexentry{...|encap{...}}{...}
</verb></tscreen>

as a cross-reference, whereas encapsulators of the form

<tscreen><verb>
\indexentry{...|encap}{...}
</verb></tscreen>

are treated as ordinary attributes. This is standard practice
defining cross-references in <tt/makeindex/. Thus, <tt/tex2xindy/
distinguishes these two forms of encapsulators as opposed to
<tt/makeindex/ and our plug-in <tt/makeindex4/ generates the
appropriate definitions of the cross-reference classes as well.

We have solved the most obvious problems as noted above. Some problems
still remain.


<sect>Problems not (easily) solvable by <tt/makeindex4/.
<p>

<sect1>Limitations of <tt/tex2xindy/
<p>
The parser of <tt/makeindex/ can be configured to recognize different
quoting characters, etc. (see the man-page for <tt/makeindex/, section
<em/input style specifiers/ for further details). We have tried to
extract the parser from <tt/makeindex/ but due to several probems we
have rewritten the parser using <tt/lex/. Scanners written with
<tt/lex/ are usually fixed to a specific character set used in the
regular expressions. Our parser, <tt/tex2xindy/ is therefore not
configurable. If one uses a different configuration of the
<tt/makeindex/ input style specifiers, one can change the source
(<tt/tex2xindy.l/) to generate a completely new parser. From our
personal experience we have rarely used more than two different
parsers in practice so we have written <tt/tex2xindy/ in a form that
is easily maintainable. The input specifiers are stored symbolically
in the source. The definiton section looks like this:

<tscreen><verb>
KEYWORD  \\indexentry
ENCAP    \|
ACTUAL   @
ESCAPE   \\
LEVEL    !
QUOTE    \"
ROPEN    \(
RCLOSE   \)
ARGOPEN  \{
ARGCLOSE \}
</verb></tscreen>

These definitions are essentially the input style specifiers as can be
found in the man-page of <tt/makeindex/. Changing this section
according to your needs and recompiling <tt/tex2xindy/ should be an
easy task. Maybe we will include more pre-defined parsers in future
releases if necessary.


<sect1>Command-line options.
<p>
Some of the command-line options of <tt/makeindex/ are accepted by
<tt/makeindex4/, others aren't. This may change in future releases,
but we recommend using plain <sf/xindy/ after a phase of
investigation, since one cannot use all of its features with
<tt/makeindex4/.

You will be informed about unsupported command-line arguments when
running <tt/makeindex4/.


<sect1>Print-key (aka. actual key) treatment.
<p>
The treatment of the actual key (usually denoted with <tt/@/, the
at-sign) has changed with <sf/xindy/. Specifying index entries with a
specific markup can be done in <tt/makeindex/ with the actual key. The
<tt/makeindex-3/ system and <sf/xindy/ offer the <em/merge-/ and
<em/sort-rules/ to transform a key into different representations,
limiting the need to specify an actual key. For example they support a
style of writing

<tscreen><verb>
\index{\bf{VIP}}
</verb></tscreen>

which can be transformed with a rule like

<tscreen><verb>
(merge-rule "\bf{\(.*\)}" "\1" :again :bregexp)
</verb></tscreen>

which removes the macro definition for merging and sorting keywords,
but keeping the original definition for markup purposes. Therefore we
don't need any actual keys for all keywords written in boldface.

The <tt/makeindex/ behaviour, that the two keywords

<tscreen><verb>
\index{VIP}
\index{VIP@\bf{VIP}}
</verb></tscreen>

are seen as two distinct index entries, can be simulated using the
following definition:

<tscreen><verb>
(merge-rule "\bf{\(.*\)}" "\1~e" :again :bregexp)
</verb></tscreen>

This rule tells <sf/xindy/ to remove the boldface macro for merging
and sorting purposes but defines the replacement to include the
special character <vb>~e</vb>, which is the last character in the
alphabet (ISO-Latin in our case). This makes <sf/xindy/ treat them as
different keywords and positions the boldface keyword right behind the
one without any markup. Thus we receive the following mapping:

<tscreen><verb>
Keyword:    Merged and sorted as:   Appears in the index as:
VIP              VIP                     VIP
\bf{VIP}         VIP~e                   \bf{VIP}
</verb></tscreen>

With this new style of writing keywords and defining their markup, the
need to explicitly specifying the print key (aka. actual key) has
convinced us to remove the <tt/makeindex/ way of defining keywords.

<sect>Conclusion
<p>
We have identified the main problems that occur when using <sf/xindy/
as a pure plug-in for <tt/makeindex/. Some problems can be solved more
or less automatically whereas other changes in the design of
<sf/xindy/ are inherently incompatible.

We hope that this document helps all users that want to use
<sf/xindy/ understanding the basic principles and the differences to
<tt/makeindex/.

Any comments, hints and improvements to this document are welcome.
Send a mail to the following address: Roger Kehr
<tt/kehr@iti.informatik.th-darmstadt.de/


<sect>References
<p>

The following books and papers were referenced in this document:

<enum>
<item> D. E. Knuth, <em/The &TeX;book/, Addison-Wesley, 1984

<item> Leslie Lamport, &LaTeX; <em/A Document Preparation System/,
Addison-Wesley, 1986

<item> Joachim Schrod, <em/An International Version of MakeIndex/,
Cahiers GUTenberg, 10, p81-90, 1991

<item> Pehong Chen and Michael A. Harrison, <em/Automating Index
Preparation/, TR-87/347, University of California Berkeley, 1987
<label id="makeindex">

<item> Roger Kehr, <sf/xindy/, <em/Ein Flexibles Indexierungssystem/,
Studienarbeit FB Informatik, TH-Darmstadt, November 1995.

<item> Joachim Schrod and Gabor Herr, <em/MakeIndex Version 3.0/,
Technical University Darmstadt, 1991

</enum>

</article>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
End:
-->
