<!doctype linuxdoc system [
<!-- $Id$
  ======================================================================

       This is the xindy FAQ;
       formerly known as xindy-by-topic manual

-->

<!ENTITY xindy "<sf/xindy/">
<!ENTITY XINDY "XINDY">
<!ENTITY LaTeX "LaTeX">
<!ENTITY TeX "TeX">

]>

<article>

<!-- Title information -->

<title>&xindy; Manual

<author>Roger Kehr, Computer Science Department, Darmstadt University
of Technology

<date>$Revision$, for xindy version 2.x,
February 1998, minor changes $Date$

<abstract>
This is the manual of the indexing system &xindy;. &xindy;
is a powerful and flexible framework for generating indexes for many
kinds of documents. This is Edition February 1998 and describes the
features of &xindy; version 2.0. The most up-to-date version of
this document can be obtained from the &xindy; Web Site at
<htmlurl url="http://www.xindy.org/" name="http://www.xindy.org/">.
</abstract>

<!-- Table of contents -->
<toc>

<#if output=html>
<p>
<ref id="INDEX" name="Index of all xindy commands">
</#if>

<!-- ================================================================= -->

<sect>About this Manual
<p>
We assume that the reader is already familiar with the task of an
index processor and has basic experience in using a markup-based
document preparation systems such as &TeX;/&LaTeX; &lsqb;1, 2&rsqb;,
the roff-family or SGML-based systems (e.g. its instance HTML).

For a basic introduction into the handling and using of &xindy;
refer to the tutorial that comes with this distribution.

This document is structured as follows. The second part gives an
overview on the index model that is used by our system and we define
general concepts and terms. The third part contains a list of all
index style commands, their syntax, and a description of their
purpose. The reader should at least have read the first part of the
manual to understand the basic terminology to be able to use the
command reference. The fourth part describes how &xindy; can be
invoked, what command line options are available and more. The fifth
part describes the different processing phases the system runs
through.


<!-- ================================================================= -->

<sect>How the Index Processor Works
<label id="how-works">
<p>

<sect1>Data Flow
<p>
Usually document preparation systems produce some form data that
describe the <em/index entries/ and the <em/locations/ they point to.
This data is called the <em/raw index/ since it consists of raw data
which contains structured information about the entries of the index.
The raw index is fed into the index processor and is processed
according to a specification called the <em/index style/. This is a
user-definable description how the index is to be processed, what
sort rules for the keywords should be used, which kind of locations
may appear, and finally, what tags should be emitted when writing the
index into the output file. The result is sometimes fed back into the
document preparation system, as it is in the case of &TeX;, or used
otherwise. The following figure illustrates this embedding into the
document preparation process.

<figure>
<eps file="dataflow.eps" height="120bp">
<img src="dataflow.gif">
</figure>

The &xindy; system is oriented on book-like indexes in a form that
is described later in detail. The format of the input data is fixed
and a small tool that converts some system dependent raw index in a
form suitable for &xindy; should not be a big hurdle. The user is
normally not involved in the correct format suitable for &xindy;
and some tools will make this work invisible to him.

In contrast, the output of the &xindy; system is highly
configurable and can produce a variety of different markups.
Additionally, the way &xindy; processes the index data can be
parametrized and controlled in many ways and gives the user a powerful
framework for describing complex indexes. The user can tell &xindy;
how it should produce an output according to his wishes or simply use
some of the predefined styles that come with the distribution.



<!-- ================================================================= -->

<sect1>General Concepts and Terms
<label id="general-concepts">
<p>
In the following sections we introduce some terms that are necessary
to understand the way &xindy; works.

The development of &xindy; started with the devlopment of a model
of a <em/book-like/ index. This rather vague term will now be fleshed
out by giving a semi-formal description of the model. If the structure
of an index conforms to this model it can be processed by &xindy;.
We first present a diagram that describes the structure of a processed
index. It is a hierarchical recursive data structure which we will
describe now.

<figure>
<eps file="index.eps" height="357bp">
<img src="index.gif">
</figure>

Boxed objects contain elements from the raw index such as the keywords
or the location reference layers. We start from the root of the
diagram and explain the different elements.

<!-- ================================================================= -->


<descrip>

<tag/index/ An index consists of a list of <sf/letter-groups/.

<!-- ================================================================= -->

<label id="def letter-group">
<tag/letter-group/ The letter groups serve as containers for
<sf/indexentries/. The letter groups are intended to group all
index entries sharing a common <sf/keyword/ prefix, allowing the
assignment of a specific markup for each group. For example, indexes
are often organized in a way that new index entries beginning with a
new letter are separated by a specific markup. The following example
illustrates this style.

<verb>
  B
    bread      25, 27
    butter     26

  M
    marmalade  19
    milk       21
</verb>

Here we have two letter groups for the letters `B' and `M' because the
keywords `bread' and `butter' share the same prefix `b' and
`marmalade' and `milk' share the prefix `m'. &xindy; can be advised
to define arbitrary letter groups with a particular markup for each of
them. See command <tt/define-letter-group/ for further details.

<!-- ================================================================= -->

<tag/indexentry/ An index entry consists of three components: the
<sf/keyword/ and optionally the list of <sf/location-class-groups/ and
the sub-<sf/indexentries/. An example:

<verb>
  bread   25-30
     brown   26
     white   27
</verb>

This index entry consists of the keyword `bread', the
location class list `25-30' and the sub-entries `brown 26' and `white
27'. The sub-entries themselves are complete index entries as well,
forming a recursive data structure.

<!-- ================================================================= -->

<tag/keyword/ The keyword is the identifier of an index entry. It
consists of a list of strings being the <em/key/ if the index entry. In
our model the keyword constists of a list of strings, since indexes
are often organized hierarchically with different layers. In the
example

<verb>
  bread         25-30
  bread, brown     26
  bread, white     27
</verb>

we have keywords `bread', `bread, brown' and `bread, white'.

A keyword is actually separated into four different keys. The
<sf/main-key/ is the key that is specified from the author who indexes
a document. The <sf/merge-key/ is derived from the main key with the
so-called <em/merge mapping/. This mapping is accomplished with a set
of rewrite rules. The <sf/sort-key/ is derived from the merge key with
another set of rewrite rules called the <em/sort mapping/. The
<sf/print-key/ can be specified by the user explicitely or, if it is
ommited, equals the main key. The rewrite rules consist of string
substitutions that also include regular expression features.

The following figure describes this:

<figure>
<eps file="mappings.eps" height="25bp">
<img src="mappings.gif">
</figure>
<#if output=txt>key -> merge-key -> sort-key</#if>

The <sf/merge-key/ is necessary to define the equality of
index entry keys. See command <tt/merge-rule/ for further details about
defining the merge mapping.

The <sf/sort-key/ is necessary to define a total order on the
keywords. Since we need a scheme that is independent from any specific
character set such as ASCII or ISO-Latin, we must be able to define
completely new alphabets. The index entries are then sorted according
to the ISO-Latin alphabet. See the command <tt/sort-rule/ for an
explanation how these mapping can be specified.

The <sf/print-key/ is used for the final markup and contains the
string that appears in the generated markup.

<!-- ================================================================= -->

<tag/location-class-group/ There exist two kinds of
location class groups namely <sf/location-reference-groups/ and
<sf/cross-reference-groups/.

<tag/location-reference-group/ consists of a list of
<sf/attribute-groups/.

<!-- ================================================================= -->

<tag/attribute-groups/ Each <sf/location-reference-group/ consists of
a list of <sf/attribute-groups/. Attribute groups are defined by a set
of <sf/attributes/. In the markup phase, all location references are
sorted according to the group number their attributes belong to.
Additionally all location references of a particular attribute group
appear together in the index.

See command <tt/define-attribute-groups/ for further information about
the handling of attribute-groups.

An attribute group consists of a list of <sf/location-references/
and/or <sf/ranges/.

<!-- ================================================================= -->

<label id="def locref-class">
<tag/location-reference-class, location-reference, location/ Each
index entry of an index references at least one <sf/location/ in the
document. A <sf/location/ is a logical or physical part of a document,
such as a single page, a section or subsection, etc. The symbolic name
of a location is called a <sf/location-reference/. The
location reference is always represented as a string (a sequence of
characters). Each location reference is associated a special tag
called <sf/attribute/. The following examples may give you an idea how
location references could look like.

<quote>
<tt/"25"       / represents a page number.
</quote>

<quote>
<tt/"Chapter-3"/ represents the third chapter of a document.
</quote>

<quote>
<tt/"A-I"      / represents the first page, written in uppercase roman
numerals of the appendix `A', separated by a hyphen.
</quote>

<quote>
<tt/"2.3.4"    / represents the sub-sub-section 2.3.4 of a document.
</quote>

As we can see, the location references are often composed
hierarchically of smaller entities, such as numbers or names. All
location references that belong to the same class form a
<sf/location-class/. A location class is composed of <sf/alphabets/
and <sf/separators/. See command <tt/define-location-class/ for a
description how classes can be defined.

<!-- ================================================================= -->

<tag/alphabet, separator/ As we have seen in the previous section,
location classes consist of alphabets and separators. xindy has the
following built-in set of basic alphabets:

<tscreen><verb>
<tag/<tt/arabic-numbers// contains all non-negative numbers beginning
with zero: 0, 1, 2, ....

<tag/<tt/roman-numerals-uppercase// the roman numerals I, II, III,
(IIII/IV), V, ... It recognizes the old and new roman numeral system.

<tag/<tt/roman-numerals-lowercase// the same for the lowercase roman
numerals.

<tag/<tt/ALPHA// the US-ASCII alphabet (uppercase letters).

<tag/<tt/alpha// the US-ASCII alphabet (lowercase letters).

<tag/<tt/digits// the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9 in this
order.
</verb></tscreen>

The user is free to define new alphabets as he wishes. See the
commands <tt/define-alphabet/ and <tt/define-enumeration/ for further
details.

A complete location class can be defined by composing alphabets and
separators. The location class of the example <tt/"A-I"/ can be
defined as follows

<verb>
  (define-location-class "appendix"
	                 (ALPHA "-" roman-numerals-uppercase))
</verb>

This is a list that completely describes all possible instances of
this location class. Other valid members are <tt/A-II/, <tt/B-VI/,
etc. Location classes are defined with the command
<tt/define-location-class/.

&xindy; reads the incoming strings representing location references
and tries to match them against a previously defined location class.
There exist no predefined location classes.

<tag/range/ A <sf/range/ is a pair of <sf/location-references/. A
sequence of location references following one another is transformed
into an range if the length of the sequence exceeds a certain
user-definable limit. For example, the location references 11, 12, 13
and&nbsp;14 may be transformed into the range 11--14. See command
<tt/define-location-class/ for further details.

<!-- ================================================================= -->

<tag/cross-reference-group/ Container for all
<sf/cross-references/ of a particular <sf/cross-reference-class/.

<!-- ================================================================= -->

<label id="def crossref-class">
<tag/cross-reference-class, cross-reference/ A <sf/cross-reference/ is
an unstructured reference. <sf/Cross-reference-classes/ are used to
define different classes of cross references. All elements of a
cross reference class appear together in the index. A cross reference
consists of a list of strings.

<!-- ================================================================= -->

<tag/attributes/ Each location reference contains a so-called
<sf/attribute/. Attributes may be used to give a location reference a
different meaning that may influence the processing and markup of this
reference. Sometimes location references pointing to semantically
different locations such as a definition or a usage of a term are
tagged differently. They often appear in <em/italics/ or <bf/boldface/
indicating this difference. An attribute may now be used to express
this difference. Since &xindy; needs to know the possible
attributes before the index entries are read in, the command
<tt/define-attributes/ must be used to define a set of attributes and
how they interact.

</descrip>



<!-- ================================================================= -->

<sect>Command List

<p>
Here is the complete list of &xindy;'s commands that may be used in
the index style. The symbol <tt/name/ always refers to a string. We
separate the commands into the <em/processing/ and
<em/markup/ commands. The commands are listed in alphabetical order.

The parenthesis `<tt/[/' and `<tt/]/' denote optional parts of the
syntax and `<tt/{/' and `<tt/}/' denote the grouping of elements. A
vertical bar indicates alternatives. However, the enclosing round
braces <em/are/ part of the syntax and must be supplied.

<!-- ================================================================= -->

<sect1>Processing Commands
<p>
Here follows the list of processing commands.

<label id="define-alphabet">
<tscreen><verb>
(define-alphabet name string-list)
</verb></tscreen>

Defines <tt/name/ to be the alphabet consisting of all elements of the
<tt/string-list/. Examples:

<verb>
  (define-alphabet "example-alphabet" ("An" "Example" "Alphabet"))
</verb>

defines an alphabet consisting of exactly three symbols. For the
successor relationship holds: <tt/succ("An")="Example"/ and
<tt/succ("Example")="Alphabet"/. The built-in alphabet <tt/digits/ is
defined as follows:

<verb>
  (define-alphabet "digits"
                   ("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"))
</verb>


<!-- ================================================================= -->

<label id="define-attributes">
<tscreen><verb>(define-attributes attribute-list)</verb></tscreen>

Defines all attributes the raw index may contain. Parameter
<tt/attribute-list/ is a list of list of strings. The nesting level
must not be more than&nbsp;2. So <tt/(..(..)..)/ is allowed, whereas
<tt/(..(..(..)..)..)/ is not.

The list has two kinds of elements: strings and list of strings. A
single string is treated as if it were a single element list. So the
lists <tt/("definition")/ and <tt/( ("definition") )/ are equivalent.
All elements forming a list are a so-called <em/attribute group/. The
members of a group are written to the output file before any member
of the following groups are written.

Examples of valid attributes lists are:

<tt/("definition" "usage")/ defines two attribute groups. The first
one contains all references with the attribute <tt/definition/ and the
second one all with the attribute <tt/usage/.

<tt/(("definition" "important") "usage")/ defines two attribute
groups. The first one contains all references with the attributes
<tt/definition/ or <tt/important/ and the second one all with the
attribute <tt/usage/. In the attribute group <tt/("definition"
"important")/ the attribute <tt/definition/ overrides <tt/important/.


<!-- ================================================================= -->

<label id="define-crossref-class">
<tscreen><verb>(define-crossref-class name [:unverified])</verb></tscreen>

Defines <tt/name/ to be a class of cross references. We distinguish
two types of cross reference classes. <em/Verified/ cross reference
classes can be checked for dangling references. If for instance a
cross reference points to the non-existent keyword `foo' a warning is
issued and the user is advised to correct the invalid cross reference.
This is the default. If for some reasons this mechanism must be
deactivated the switch <tt/:unverified/ can be used to suppress this
behaviour.

<!-- ================================================================= -->

<label id="define-letter-group">
<label id="define-letter-groups">
<tscreen><verb>
(define-letter-group name [:before lgname] [:after lgname]
			  [:prefixes list-of-prefixes])

(define-letter-groups list-of-letter-groups)
</verb></tscreen>

This command defines a letter group with name <tt/name/, which must be
a string value, grouping all index entries that have a <em/sort key/
beginning with the prefix <tt/name/. The command

<verb>
  (define-letter-group "a")
</verb>

is equivalent to the command

<verb>
  (define-letter-group "a" :prefixes ("a"))
</verb>

Using the latter form one can associate more than one prefix with a
given letter group. Also further prefixes can be added to an already
existing letter group by simply defining the same letter group again.
This results not in a redefinition but in adding more prefixes to the
currently defined prefixes.

Example:

<verb>
  (define-letter-group "a")
</verb>

defines a letter group containing all index entries beginning with the
string <tt/"a"/.

<verb>
  (define-letter-group "c" :after "a")
</verb>

defines a letter group containing all index entries beginning with the
string <tt/"c"/. The letter group appears behind the letter group "a"

<verb>
  (define-letter-group "b" :after "a" :before "c")
</verb>

inserts letter group "b" between letter group "a" and "c". This allows
incremental definition of letter groups by extending already defined
ones.

The arguments <tt/:after/ and <tt/:before/ define a partial order on
the letter groups. &xindy; tries to convert this partial order into
a total one. If this is impossible due to circular definitions, an
error is reported. If more than one possible total ordering can
result, it is left open which one is used, so one should always define
a complete total order.

The command <tt/define-letter-groups/ (with an `s' at the end) is
simply an abbreviation for a sequence of
<tt/define-letter-group/ definitions where the elements are ordered in
the ordering given by the list. Example:

<verb>
  (define-letter-groups ("a" "b" "c")
</verb>

equals the definitions

<verb>
  (define-letter-group "a")
  (define-letter-group "b" :after "a")
  (define-letter-group "c" :after "b")
</verb>

See also commands <tt>markup-letter-group-list</tt> and
<tt>markup-letter-group</tt> for further information.


<!-- ================================================================= -->

<label id="define-location-class">
<tscreen><verb>
(define-location-class name layer-list
                       [:min-range-length num]
		       [:hierdepth depth]
		       [:var])
</verb></tscreen>

Defines <tt/name/ to be a location class consisting of the given list
of layers. A list of layers consists of names of basetypes and/or
strings representing separators. Separators must follow the
keyword argument <tt/:sep/. If the keyword <tt/:min-range-length/ is
specified we define the <em/minimum range length/ to be used when
building ranges. The argument <tt/num/ must be a positive integer
number or the keyword <tt/none/ in which case the building of ranges
is disallowed. If the switch <tt/:var/ is specified the declared class
is of type <em/variable/, i.e. it is a <em/var-location-class/. Since
building of ranges is currently only allowed for standard classes
<tt/:var/ and <tt/:min-range-length/ must not be used together. The
keyword argument <tt/:hierdepth/ can be used to declare that the
location references have to be tagged in a hierarchical form. Its
argument <tt/depth/ must be an integer number indicating the number of
layers the hierarchy does contain. See command
<tt>markup-locref-list</tt> for more information. Examples:

<verb>
  (define-location-class "page-numbers" ("arabic-numbers")
	                 :minimum-range-length 3)
</verb>

Defines the location class <tt/page-numbers/ consisting of one layer
which is the alphabet <tt/arabic-numbers/. Since the minimum
range length is set to 3 the location references 2, 3 and 4 don't form
a range because the range length is only 2. But the references 6, 7,
8, and 9 are enough to form a range. Some example instances of this
class are <tt/0/, <tt/1/, ... <tt/2313/, etc.

<verb>
  (define-location-class "sections" :var
     ("arabic-numbers" :sep "."
      "arabic-numbers" :sep "."
      "arabic-numbers"))
</verb>

defines a variable location class. Valid instances are <tt/1/,
<tt/1.1/, <tt/1.2/, <tt/2/, <tt/2.4.5/, but none of <tt/2-3/ (wrong
separator), <tt/1.2.3.4/ (more than 3 layers), <tt/2.3.iv/ (roman
number instead of arabic one).


<!-- ================================================================= -->

<label id="define-location-class-order">
<tscreen><verb>
(define-location-class-order list)
</verb></tscreen>

Defines the order in which the location classes are written to the
output file. The parameter <tt/list/ is a list of names of
location classes. Examples:

<verb>
  (define-location-class-order
      ("page-numbers" "sections" "xrefs"))
</verb>

tells the system that the page numbers should appear before the
section numbers and that the cross references should appear at the
end. If this command is omitted, the declaration order of the
location classes in the index style is implicitly used as the output
order. In the case that a location class does not appear in the list,
the output may behave unexpectedly, so one should always enumerate all
used location classes when using this command.


<!-- =================================================================-->

<label id="define-rule-set">
<tscreen><verb>
(define-rule-set name
        [ :inherit-from ("rule-set" "rule-set-2") ]
        :rules (<rule>...) )
</verb></tscreen>

A complete specification of a multi-phase sorting process for a
language requires that some rules have to appear in several subsequent
sorting phases. Rule sets can be used to define a set of rules that
can be instantiated in an arbitrary sorting phase. Basically, they
offer means to separate the definition of sorting rules from their
instantiation, hence, acting as a wrapper for calls to <tt/sort-rule/.
They do not add new functionality that is not already present with
<tt/sort-rule/.

A rule can be of the form:

<verb>
  <rule> ::= ("pattern" "replacement"
              [:string|:bregexp|:egegexp] [:again])
</verb>

The following incomplete example defines a new rule set of name
<tt/isolatin1-tolower/ that inherits definitions from rule set
<tt/latin-tolower/, overriding or adding the sort rules in the list of
<tt/:rules/.

<verb>
   (define-rule-set "isolatin1-tolower"

     :inherit-from ("latin-tolower")

     :rules (("À" "à" :string :again)
             ("Á" "á" :string :again)
             ("Â" "â" :string :again)
             ("Ã" "ã" :string :again)
             ("Ä" "ä" :string :again)
             ("Å" "å" :string :again)
             ("Æ" "æ" :string :again)
          ...
            )
   ...)
</verb>

Rule sets can be instantiated with the command <tt/use-rule-set/. For
further descriptions on the sorting model refer to the command
<tt/sort-rule/.

<!-- =================================================================-->

<label id="define-sort-rule-orientations">
<tscreen><verb>
(define-sort-rule-orientations (orientations...))
</verb></tscreen>

Defines the order for the different sorting phases. The currently
implemented <em/orientations/ are <tt/forward/ and <tt/backward/. This
command must precede all <tt/sort-rule/ commands in an index style. It
defines the orientations and implicitly sets the maximum number of
sorting phases performed.

For further descriptions on the sorting model refer to the command
<tt/sort-rule/.


<!-- =================================================================-->

<label id="merge-rule">
<tscreen><verb>
(merge-rule pattern replacement [:again]
				[:bregexp | :eregexp | :string])
</verb></tscreen>

Defines a keyword mapping rule that can be used to generate the
<em/merge key/ from the <em/main key/ of an index entry. This mapping
is necessary to map all keywords that are differently written but
belong to the same keyword to the same canonical keyword.

The parameter <tt/pattern/ can be a POSIX-compliant regular expression
or an ordinary string. The implementation uses the GNU Rx regular
expression library which implements the POSIX regular expressions.
Regular expressions (REs) can be specified as <em/basic regular
expressions/ (BREs) or <em/extended regular expressions/ (EREs). You
can use the switch <tt/:bregexp/ to force the interpretation of the
pattern as a BRE, or <tt/:eregexp/ to interpret it as an ERE. If you
want &xindy; to interpret the pattern literally, use the switch
<tt/:string/. If none of these switches is selected, &xindy; uses
an auto-detection mechanism to decide, if the pattern is a regular
expression or not. If it recognizes the pattern as a RE, it interprets
it as an ERE by default.

The parameter <tt/replacement/ must be
a string possibly containing the special characters <tt/&amp;/
(substitutes for the complete match) and <tt>\1</tt>,...,<tt>\9</tt>
(substituting for the <em/n/-th submatch. Examples:

<verb>
  (merge-rule "A" "a")
</verb>
replaces each occurrence of the uppercase letter `<tt/A/' with its
lowercase counterpart.

<verb>
  (merge-rule "\~"([AEOUaeou])" "\1")
</verb>
transforms the &TeX; umlaut-letters into their stripped counterparts,
such that `<tt>\"A</tt>' is treated as an `<tt/A/' afterwards.

The following sequences have a special meaning:

`<tt>~n</tt>' : End of line symbol (<em/linefeed/).

`<tt>~b</tt>' : The ISO-Latin character with the lowest ordinal number.

`<tt>~e</tt>' : The ISO-Latin character with the highest ordinal number.

`<tt>~~</tt>' : The tilde character.

`<tt>~"</tt>' : The double quote character.

Tilde characters and double quotes have to be quoted themselves with a
tilde character. The special characters `<tt>~b</tt>' and
`<tt>~e</tt>' allow the definition of arbitrary sorting orders by
rules. In connection with an additional character every position in
the alphabet can be described. E.g. `<tt>m~e</tt>' is
lexicographically placed between `<tt/m/' and `<tt/n/'.

Due to efficiency, rules that just exchange characters or substitute
constant character sequences are not treated as regular expressions.
Therefore, instead of using the rule

<verb>
  (merge-rule "[A-Z]" "&amp;x")
</verb>

it is more efficient (though less comfortable) to use

<verb>
  (merge-rule "A" "Ax")
  (merge-rule "B" "Bx")
  ...
  (merge-rule "Z" "Zx")
</verb>

Usually rules are applied in order of their definition. Rules with a
special prefix precede those that begin with a class of characters, so
that the search pattern `<tt/alpha/' is checked before `<tt/.*/', but
`<tt/auto/' and `<tt/a.*/' are checked in order of their definition.

The first rule from a style file that matches the input is
applied and the process restarts behind the substituted text. If no
rule could be applied, the actual character is copied from the input
and the process continues with the next character.

Sometimes it is necessary to apply rules anew to the result of a
transformation. By specifying the keyword argument <tt/:again/ in the
merge rule the rule is marked as <em/mutable/, which means that after
using this rule the transformation process shall restart at the same
place. E.g. the rule

<verb>
  (merge-rule "\$(.*)\$" "\1" :again)
</verb>

deletes <em/all/ surrounding `<tt>$</tt>' symbols from the input.

See also command <tt>sort-rule</tt>.

<!-- ================================================================= -->

<label id="merge-to">
<tscreen><verb>
(merge-to attr-from attr-to [:drop])
</verb></tscreen>

A <em/merge rule/ says that the attribute <tt/attr-from/ can be used
to build ranges in <tt/attr-to/. Both attributes must name valid
attribute names. The switch <tt/:drop/ indicates, that the original
location reference with attribute <tt/attr-from/ has to be dropped
(removed), if a successful range was built with location references in
attribute <tt/attr-to/. A detailed description is given in the section
about processing phases.


<!-- ================================================================= -->

<label id="require">
<tscreen><verb>
(require filename)
</verb></tscreen>

This command allows to load more index style modules. The module is
searched in the directories defined in the search path. The file is
read in and processing of the current file continues. The argument
<tt/filename/ must be a string. This allows to decompose the
index style into several modules that can be included into the topmost
index style file. Example:

<verb>
  (require "french/alphabet.xdy")
  (require "french/sort-rules.xdy")
  (require "tex/locations.xdy")
  (require "tex/markup.xdy")
</verb>

Submodules can load other submodules as well. If a file is required
that was already loaded, the <tt/require/ command is simply ignored
and processing continues without including this file twice. See also
command <tt>searchpath</tt>.


<!-- ================================================================= -->

<label id="searchpath">
<tscreen><verb>
(searchpath {path-string | path-list})
</verb></tscreen>

This command adds the given paths to the list of paths, &xindy;
searches for index style files. The argument <tt/path-string/ must be
a colon-separated string of directory names. If this path ends with a
colon the default search path is added to the end of the path list.
Example:

<tscreen><verb>
  (searchpath ".:/usr/local/lib/xindy:/usr/local/lib/xindy/english:")
</verb></tscreen>

adds the specified directories to the search path. Since the last path
ends with a colon, the built-in search path is added at the end.
Specifying

<tscreen><verb>
  (searchpath ("."
               "/usr/local/lib/xindy"
	       "/usr/local/lib/xindy/english"
	       :default))
</verb></tscreen>

yields exactly the same result as the example above. Here
<tt/path-list/ must be a list of strings and/or the keyword(s)
<tt/:default/ and <tt/:last/. The keyword <tt/:default/ signifies that
the default pathnames are to be inserted at the specified position in
the list. The keyword <tt/:last/ allows to insert the currently active
paths at the indicated position. Since this allows to insert the
built-in paths at any position and incrementally adding new paths to
the search path, this version of the command ist more flexible than
the first version.

<!-- ================================================================= -->

<label id="sort-rule">
<tscreen><verb>
(sort-rule pattern replacement [:run level] [:again])
</verb></tscreen>

Defines a keyword mapping rule that can be used to generate the
<em/sort key/ of an index entry from the <em/merge key/. This key is
used to sort the index entries lexicographically after they have been
merged using the merge key.

The argument <tt>:run</tt> indicates that this rule is only in effect
a the specified <em/level/ (default is level 0). For a detailed
discussion on the definition of sort rules for different layers refer
to the documentation about the new sorting scheme
(<tt/new-sort-rules/) that comes with this distribution.

See command <tt>merge-rule</tt> for more information about keyword
rules.


<!-- ================================================================= -->

<label id="use-rule-set">
<tscreen><verb>
(use-rule-set [:run phase]
              [:rule-set ( <rule-set>... ))
</verb></tscreen>

This command instantiates the gives rule sets to be in effect at
sorting phase <tt/phase/. The order of the rule sets given with
argument <tt/:rule-set/ is significant. Rule set entries of rule set
appearing at the beginning of the list override entries in rule sets
at the end of the list.

The following example declares that in phase 0 the rule sets
<tt/din5007/ and <tt/isolatin1-tolower/ should be active, whereas in
phase 2 the other rule sets have to be applied.

<verb>
  (use-rule-set :run 0
                :rule-set ("din5007" "isolatin1-tolower"))

  (use-rule-set :run 1
                :rule-set ("resolve-umlauts"
                           "resolve-sharp-s"
                           "isolatin1-tolower"
                           ))
</verb>

For a discussion on rule sets refer to command <tt/define-rule-set/.


<!-- ================================================================= -->

<sect1>Markup Commands
<p>

The following commands can be used to define the markup of the index.
They don't have any influence on the indexing process. Since the
markup scheme is characterized by the concept of <em/environments/,
the syntax and naming scheme of all commands follows a simple
structure.

The commands can be separated into <em/environment/  and
<em/list-environment/ commands. All commands of the first group
support the keyword arguments <tt/:open/ and <tt/:close/, whereas the
second group additionally supports the keyword argument <tt/:sep/. If
one of these keyword arguments is missing, the default markup tag is
<em/always/ the empty tag. The <tt/:open/ tag is always printed before
the object itself and the <tt/:close/ tag is always printed after the
object has been printed. If a list is printed the <tt/:sep/tag is
printed between two elements of the list but not before the first
element, or after the last one. All commands dealing with a list have
the suffix `<tt/-list/' as part of their command name.

Since the number of commands and the heavy usage of <em/default/ and
<em/specialized/ tags makes the markup somehow complex (but very
powerful) we have added a mechanism to trace the markup tags
&xindy; omits during its markup phase with the command
<tt>markup-trace</tt>.

Here follows the list of markup commands in alphabetical order with
some of the commands grouped together.

<!-- ================================================================= -->

<label id="markup-attribute-group">
<label id="markup-attribute-group-list">
<tscreen><verb>
(markup-attribute-group-list [:open string] [:close string]
                             [:sep string])

(markup-attribute-group      [:open string] [:close string]
                             [:group group-num])
</verb></tscreen>

Location class groups consist of lists of attribute groups. The markup
of this list can be defined with the command
<tt/markup-attribute-group-list/.

To allow different markup for different attribute groups the command
<tt/markup-attribute-group/ can be specialized on the group number
with the keyword argument <tt/:group/ which must be an integer number.
E.g., given are the groups <tt/("definition" "theorem")/ and
<tt/("default")/ with group numbers 0 and 1, then

<verb>
  (markup-attribute-group :open "<group0>" :close "&lt;/group0>"
			  :group 0)

  (markup-attribute-group :open "<group1>" :close "&lt;/group1>"
			  :group 1)
</verb>

can be used to assign different markup for both groups in a SGML-based
language.

<!-- ================================================================= -->

<label id="markup-crossref-layer">
<label id="markup-crossref-layer-list">
<label id="markup-crossref-list">
<tscreen><verb>
(markup-crossref-list       [:open string] [:close string]
		            [:sep string]
			    [:class crossref-class])

(markup-crossref-layer-list [:open string] [:close string]
		            [:sep string]
			    [:class crossref-class])

(markup-crossref-layer      [:open string] [:close string]
		            [:class crossref-class])
</verb></tscreen>

A crossref class group contains cross references of the same class.
The separator between the classes is defined with the
<tt/(markup-locclass-list :sep)/-parameter. A list of cross references
can be tagged with the command <tt/markup-crossref-list/ that
specializes on the <tt/:class/ argument.

Each cross reference is determined by a list of layers indicating
the target of the cross reference. To define a suitable markup for
such a list the command <tt/markup-crossref-layer-list/ can be used.

Each layer of a cross reference can be assigned two tags that
specialize on the class of the reference, like all other commands.

A suitable markup for a cross reference class <tt/see/ within &LaTeX;2e
could look like that:

<verb>
  (markup-crossref-list :class "see" :open "\emph{see} "
				     :sep  "; ")
  (markup-crossref-layer-list :class "see" :sep ",")
  (markup-crossref-layer :class "see"
				     :open "\textbf{" :close "}")
</verb>

An example output could look like

<quote>
... <em/see/  <bf/house/; <bf/garden/,<bf/winter/; <bf/greenhouse/
</quote>

<!-- ================================================================= -->

<label id="markup-index">
<tscreen><verb>
(markup-index [:open string] [:close string]
	      [ :flat | :tree | :hierdepth depth ])
</verb></tscreen>

Defines the markup tags that enclose the whole index via the
<tt/:open/ and <tt/:close/ parameters. Examples:

<verb>
  (markup-index :open  "Here comes the index~n"
                :close "That's all folks!~n")
</verb>

defines that the <tt/:open/ string is printed before the rest of the
index and the <tt/:close/ string appears after the index is printed.

Additionally one can specify the form of the generated index. It is
possible to produce flat indexes by specifying the switch <tt/:flat/,
to generate a tree with the <tt/:tree/ switch or any kind of mixture
between both by specifying the depth up to which trees shall be built
with the parameter <tt/:hierdepth/. Its argument <tt/depth/ is the
number of layers that can be formed into a tree. Therefore <tt/:flat/
is an abbrevation of <tt/:hierdepth 0/ and <tt/:tree/ is an
abbrevation of <tt/:hierdepth max-depth/, with <tt/max-depth/ being
the maximum number of layers a keyword has. An example: the keywords

<verb>
  ("tree" "binary" "AVL")
  ("tree" "binary" "natural")
</verb>

can be transformed in the following ways:

A flat index (<tt/:flat/ or <tt/:hierdepth 0/)

<verb>
  tree binary AVL
  tree binary natural
</verb>

with <tt/:hierdepth 1/

<verb>
  tree
     binary  AVL
     binary  natural
</verb>

and a tree (<tt/:tree/ or <tt/:hierdepth/ &gt; 1)

<verb>
  tree
     binary
        AVL
        natural
</verb>

Most often one will create tree-like indexes or ones that are flat.

<!-- ================================================================= -->

<label id="markup-indexentry-list">
<label id="markup-indexentry">
<tscreen><verb>
(markup-indexentry-list [:open string] [:close string]
			[:sep string]  [:depth integer])

(markup-indexentry      [:open string] [:close string]
		        [:depth integer])
</verb></tscreen>

Letter groups consists of a list of index entries. The command
<tt/markup-indexentry-list/ defines the markup of these lists. The
markup can be specialized on the depth if the index is hierarchically
organized. The command

<verb>
  (markup-indexentry-list :open  "\begin{IdxentList}"
			  :close "\end{IdxentList}"
			  :sep   "~n")
</verb>

defines that the index entries of all layers are wrapped into the
given markup tags. If additionally

<verb>
  (markup-indexentry-list :open  "\begin{IdxentListII}"
			  :close "\end{IdxentListII}"
			  :sep   "~n"
			  :depth 2)
</verb>

is defined, all index entry lists of all layers (except layer 2) are
tagged according to the first specification, and the index entry list
within depth 2 are tagged according to the second rule.

The command <tt/markup-indexentry/ defines the markup of an index entry
at a given depth. Since index entries may also contain subentries and
the markup for subentries may be different in different layers, the
optional keyword argument <tt/:depth/ can be used to assign different
markup for different layers. If depth is ommited the default markup
for all possible depths is defined. The top-most index entries have
depth 0.

<verb>
  (markup-indexentry :open  "\begin{Indexentry}"
		     :close "\end{Indexentry}")
</verb>

defines that the index entries of all layers are wrapped into the
given markup tags. If additionally

<verb>
  (markup-indexentry :open  "\begin{IndexentryII}"
		     :close "\end{IndexentryII}"
		     :depth 2)
</verb>

is defined, all index entries of all layers (except layer 2) are tagged
according to the first specification, and the index entries with depth
2 are tagged according to the second rule.

<!-- ================================================================= -->

<label id="markup-keyword-list">
<label id="markup-keyword">
<tscreen><verb>
(markup-keyword-list [:open string] [:close string]
		     [:sep string] [:depth integer])

(markup-keyword      [:open string] [:close string]
	             [:depth integer])
</verb></tscreen>


The print key of an index entry consists of a list of strings. The
markup of this list can be defined with the command
<tt/markup-keyword-list/. The keyword argument <tt/:depth/ may be
specified to define the markup of the list at a particular depth.

The keyword of an index entry consists of a list of strings. Each of
these components is tagged with the strings defined with the command
<tt/markup-keyword/. Since we maybe need different markup for
different layers, the optional keyword argument can be used to
specialize this markup for some depth.

<!-- ================================================================= -->

<label id="markup-letter-group-list">
<label id="markup-letter-group">
<tscreen><verb>
(markup-letter-group-list [:open string] [:close string]
                          [:sep string])

(markup-letter-group  [:open string] [:close string] [:group group-name]
                      [:open-head string] [:close-head string]
		      [:upcase | :downcase | :capitalize])
</verb></tscreen>

The first command defines the markup of the letter group with name
<tt/group-name/. Since the markup of letter groups often contains the
name of the letter group as a part of it, the other keyword arguments
allow an additional markup for this group name. If one of the
parameters <tt/:open-head/ and <tt/:close-head/ is specified
additional markup is added as can be described as follows:

<verb>
  <OPEN>
     IF (:open-head OR :close-head)
       <OPEN-HEAD>
         transformer-of(<GROUP-NAME>)
       <CLOSE-HEAD>
     FI
     <INDEXENTRIES...>
  <CLOSE>
</verb>

Here, <tt/transformer-of/ is a function that possibly transforms the
string representing the group name into another string. The
transformers we currently support can be specified with the switches
<tt/:upcase/, <tt/:downcase/ and <tt/:capitalize/ which result in the
corresponding string conversions. If none of them is specified no
transformation is done at all.

The command <tt/markup-letter-group/ defines the markup of the list of
letter groups.

<!-- ================================================================= -->

<label id="markup-locclass-list">
<tscreen><verb>
(markup-locclass-list [:open string] [:close string]
                      [:sep string])
</verb></tscreen>

Each index entry contains a list of location class groups. This markup
command can be used to define the markup of this list.

<!-- ================================================================= -->

<label id="markup-locref">
<tscreen><verb>
(markup-locref [:open string] [:close string]
	       [:class locref-class]
	       [:attr  attribute]
	       [:depth integer])
</verb></tscreen>

The markup tags of a location reference can be specialized on the
three arguments <tt/:class/, <tt/:attr/ and additionally, if
sub-references are used, <tt/:depth/. Most often one will only use a
tag depending on the attribute. For example, all location references
with the attribute <tt/definition/ should appear in a font series like
bold, emphasizing the importance of this location reference; those
with the attribute <tt/default/ in font shape italic. The markup in
this case would not specialize on the depth or any particular class. A
valid definition, suitable for a usage within HTML, could look like
this.

<verb>
  (markup-locref :open "&lt;B>" :close "&lt;/B>" :attr "definition")
  (markup-locref :open "&lt;I>" :close "&lt;/I>" :attr "default")
</verb>

<!-- ================================================================= -->

<label id="markup-locref-class">
<tscreen><verb>
(markup-locref-class [:open string] [:close string]
		     [:class locref-class])
</verb></tscreen>

All location references of a particular location reference class can
be wrapped into the tags defined by this command. It specializes on
the keyword argument <tt/:class/.

<!-- ================================================================= -->

<label id="markup-locref-layer-list">
<label id="markup-locref-layer">
<tscreen><verb>
(markup-locref-layer      [:open string] [:close string]
		          [:depth integer] [:layer integer]
			  [:class locref-class])

(markup-locref-layer-list [:open string] [:close string]
			  [:sep string]
		          [:depth integer]
			  [:class locref-class])
</verb></tscreen>

A location reference contains a list of location reference layers. The
second markup command can be used to markup this list. It specializes
on the class of the location references and the depth (if
sub-references are used).

The first command allows to tag the elements of a layer list
differently. The first element of this list can is specialisable with
<tt/:layer 0/, the next element with <tt/:layer 1/, etc. See the next
example for an example.

<!-- ================================================================= -->

<label id="markup-locref-list">
<tscreen><verb>
(markup-locref-list [:open string] [:close string] [:sep string]
		    [:depth integer] [:class locref-class])
</verb></tscreen>

An attribute group contains a list of location references and/or
ranges. Additionally a layered location reference itself may contain
sub-references that are stored as a list of location references. We
specialize the markup for these lists on the location class they
belong to with the keyword argument <tt/:class/, and on <tt/:depth/
that specializes on the different subentry levels when using
location references with sub-references.

Given is a list of location references that have the class description

<verb>
  (define-location-class "Appendix"
		         ("ALPHA" :sep "-" "arabic-numbers")
		         :hierdepth 2)
</verb>

This location class has instances like <tt/A-1/, <tt/B-5/, etc. The
keyword argument <tt/:hierdepth 2/ informs &xindy; to markup these
location references in a hierarchical form. With the commands

<verb>
  (markup-locref-list            :sep "; "
		       :depth 0  :class "Appendix")
  (markup-locref-list  :open " " :sep ","
                       :depth 1  :class "Appendix")
  (markup-locref-layer :open "{\bf " :close "}" :layer 0
		       :depth 0  :class "Appendix")
</verb>

we obtain a markup sequence for some example data that could look like

<verb>
  {\bf A} 1,2,5; {\bf B} 5,6,9; {\bf D} 1,5,8; ...
</verb>


<!-- ================================================================= -->

<label id="markup-range">
<tscreen><verb>
(markup-range [:open string] [:close string] [:sep string]
              [:class locref-class]
	      [:length num] [:ignore-end])
</verb></tscreen>

A range consists of two location references. Markup can be specified
with the <tt/:open/ and <tt/:close/ arguments and one separator given
by the argument <tt/:sep/.

Since both location references are tagged with markup defined by the
command <tt/markup-locref/ a specialization on attributes or depth is
not necessary. Specialization is allowed on the class they belong to,
because the separator between two location refences may be different
for each location class. Argument <tt/:length/ can be used to define
different markup for different lengths. In conjunction with
<tt/:length/ is may be useful not to print the second location
reference at all. For example, one wishes to markup ranges of length 1
in the form <em/Xf./ instead of <em/X--Y/. This can be accomplished
with the switch <tt/:ignore-end/.

The markup tags for a range <em/(X,Y)/ can be described as follows:

<verb>
  <OPEN>
    Markup of location reference X
  <SEP>
    IF (not :ignore-end)
       Markup of location reference Y
    FI
  <CLOSE>
</verb>


The following tags can be used to define a range of page numbers
(given in a location class <tt/page-numbers/) without considering the
open and close parameters:

<verb>
  (markup-range :sep "-" :class "page-numbers")
</verb>

Location ranges then appear separated by a hyphen in a form like this:

<verb>
   ..., 5-8, 19-23, ...
</verb>

<!-- ================================================================= -->

<label id="markup-trace">
<tscreen><verb>
(markup-trace [:on] [:open string] [:close string])
</verb></tscreen>

This command can be used to activate the tracing of all
markup commands &xindy; executes. The switch <tt/:on/ activates the
trace. If <tt/:on/ is omitted, the command line flag <tt/-t/ can be
used as well. All tags which are emitted but not yet defined
explicitly by the user are tagged with a symbolic notation indicating
the commands that must be used to define this tag. The defaults for
the keyword argument <tt/:open/ is `<tt/&lt;/' and for <tt/:close/ is
`<tt/>/'. The beginning of an example output could look like:

<verb>
  <INDEX:OPEN>
    <LETTER-GROUP-LIST:OPEN>
      <LETTER-GROUP:OPEN ["a"]>
        <INDEXENTRY-LIST:OPEN [0]>
          <INDEXENTRY:OPEN [0]>
            <KEYWORD-LIST:OPEN [0]>
              <KEYWORD:OPEN [0]>
   ...
</verb>

We use a simple indentation scheme to make the structure of the tags
visible. The symbolic tag <tt/&lt;LETTER-GROUP:OPEN ["a"]>/ for example
indicates that the tag that can be specified with the command

<verb>
  (markup-letter-group :open "XXX" :group "a" ... )
</verb>

is emitted at this point in the markup process. By incrementally
adding markup commands to the index, more and more tags can be defined
until the whole markup is defined. This general mechanism should allow
everyone understand the markup process. The best is to start with a
small index, define the complete markup and afterwards process the
whole index. Additionally one can enclose the symbolic tags into an
environment that is neutral to the document preparation system, such
as a comment. For &TeX; this could be

<verb>
  (markup-trace :open "%%" :close "~n")
</verb>

or a definition in the &TeX; document like

<verb>
  \def\ignore#1{}
</verb>

combined with the command

<verb>
  (markup-trace :open "\ignore{" :close "}")
</verb>


<!-- ================================================================= -->

<label id="raw-index">
<sect1>Raw Index Interface

<p>

This section can be skipped if the reader is not interested in
adapting &xindy; to a new document preparation system.

The raw index is the file that represents the index that is to be
processed. Since many different document preparation systems may use
different forms of index representations, their output must be
transformed in a form readable by &xindy;. We also could have
written an configurable parser performing this task, but usually a
tool written with some text processing tools such as <tt/perl/,
<tt/sed/ or <tt/awk/ can achieve the same task as well. Therefore,
adapting &xindy; to a completely different system can mostly be
done by writing an appropriate raw index filter.

The format of the raw index interface of &xindy; is defined as
follows:

<label id="indexentry">
<tscreen><verb>
(indexentry { :key string-list [:print string-list]
	    | :tkey list-of-layers }
	    [:attr string]
	    { :locref string  [:open-range | :close-range]
	    | :xref string-list } )
</verb></tscreen>

The pseudo variable <em/string/ is a sequence of characters
surrounded by double quotes, e.g.

<verb>
  "Hi, it's me"  "one"  "a string with two \"double quotes\""
</verb>

are three examples of valid strings. If you need to include a
double quote as a literal character, you must quote it itself with a
backslash as shown in the third example. A <em/string list/ is simply
a list of strings separated by whitespaces and surrounded by round
braces. An example of a string list is

<verb>
  ("This" "is" "a" "list" "of" "strings")
</verb>

So far about the syntax. The semantics of the different elements are
described here.

<p>
<descrip>

<tag/<tt/:key//The argument <em/string list/ defines the keyword of
the index entry. It must be a list of strings, since the keyword may
consist of different layers such as <tt>("heap" "fibonacci")</tt>.

<tag/<tt/:print//The optional <em/print key/ defines the way the
keyword has to be printed in the markup phase.

<tag/<tt/:tkey//Another possibility to define the keys of an
index entry is with the <tt/:tkey/ keyword argument. It can be used
instead of the <tt/:key/ and <tt/:print/ arguments. Instead of
specifying separately the key and the corresponding print key, we
define the keyword by its layers. Each layer consist of a list of one
or two strings. The first string will be interpreted as the main key,
whereas the second one will become the print key. If the print key is
ommited, the main key is taken instead. So the definition

<verb>
  :tkey (("This") ("is") ("a") ("bang" "BANG !!!"))
</verb>

is equivalent to

<verb>
  :key   ("This" "is" "a" "bang")
  :print ("This" "is" "a" "BANG !!!")
</verb>


<tag/<tt/:locref//The reference an index entry describes can be a
<em/location reference/ or a <em/cross reference/. The switch
<tt/:locref/ describes a location reference. Its optional arguments
are <tt/:open-range/ and <tt/:close-range/. The <em/string/ that must
be supplied must somehow encode the location reference. It might look
like the string <tt/"25"/ representing the page number 25, or
<tt/"Appendix-I"/ representing the first appendix numbered in
uppercase roman numerals.

<tag/<tt/:open-range/,<tt/:close-range//These are switches that do not
take any arguments. They describe the beginning and ending of a
<em/range/, starting or ending from the location reference that is
given by the argument <tt/:locref/. If they are supplied, the
location reference may have influence on the way ranges are build.

<tag/<tt/:xref//These arguments choose the second alternative. The
argument <em/string list/ of parameter <tt/:xref/ describes where the
index entry should point to.

<tag/<tt/:attr//This parameter may be used to tag a location reference
with a certain attribute or it names the class of a cross reference.
It may also used to associate different markup for different
attributes in the markup phase. If this parameter is omitted or is the
empty string, the indexentry is declared to have the attribute
<tt/default/.

</descrip>

Some examples:

<verb>
  (indexentry :key ("airplane") :locref "25" :attr "default")
</verb>

defines an index entry with the key `airplane' indexed on page '25'.
This index entry has the attribute <tt/default/.

<verb>
  (indexentry :key ("house") :xref ("building") :attr "see")
</verb>

defines a cross reference with the key 'house' pointing to the term
'building'. This cross reference belongs to the cross reference class
<tt/see/.

<verb>
  (indexentry :key ("house") :xref ("building") :open-range)
</verb>

is an invalid specification, since <tt/:open-range/ mustn't be used
together with cross references.


<!-- ================================================================= -->

<sect>Processing Phases

<!-- ================================================================= -->

<label id="startup-phase">
<sect1>The Startup Phase

<p>
After the system is started, &xindy; reads in the index style that
is passed as a command line argument. Each <tt/require/ command is
executed and the internal data structures representing the index style
are built up. The index style must completely be read in before the
raw index can be read.

<!-- ================================================================= -->

<label id="processing-phase">
<sect1>The Processing Phase

<p>
The processing phase starts with reading the complete raw index. The
name of the raw index file must be passed via the command line. All
index entries are read in and pre-processed. All attributes and
cross reference classes are checked if they are already known to the
system. All strings representing location references are matched
against all known location classes. Appropriate warnings are issued,
if errors are encountered.

After the raw index has completely been read in, the
location references of each index entry are merged, separated and
sorted and the building of ranges takes place. This phase is the most
complex one and we will describe it in detail.

<enum>
<item> All location references are separated according to the class
they belong to. These groups are called <em/location class groups/.
Possible groups are all defined location  and crossref classes. See
the commands <tt>define-location-class</tt> and
<tt>define-crossref-class</tt> for a description how these classes can
be defined.

The classes are sorted according to an order that can be defined with
the command <tt>define-location-class-order</tt>.

<item> The further processing of each location class group is
different for the location classes and the crossref classes.

<itemize>

  <item> Cross references are sorted lexicographically based on
  the ISO-Latin alphabet.

  <label id="sort-merge-locrefs">
  <item> To illustrate the processing of location references we assume
  the following list:

  <quote> <em/13/, <em/14/, <em/15/, <em/18/, <bf/12/, <bf/13/,
  <bf/14/, <bf/16/, 14, 16 </quote>

   The location references in italics own the attribute `important,
   those with in boldface have attribute `definition', and all others
   are own the attribute `default'. Imagine, the attribute groups were
   defined with the commands

   <tscreen><verb>
   (define-attribute-groups (("definition" "important")
   		 	     ("default")))

   (merge-to "definition" "default" :drop)
   </verb></tscreen>

   See commands <tt>define-attributes</tt> and <tt>merge-to</tt> for a
   detailed description.

   The substitution rules are applied. This means that
   location references <bf/13/ and <bf/14/ with attribute `important'
   are <em/substituted/ by the location references <em/13/ and <em/14/
   with attribute `definition'. Substitution means removing from the
   list of location references.

   Substitution occurs because the definition of the attribute groups
   implicitly defines <tt/"definition"/ <em/substitutes/
   <tt/"important"/.

   The resulting list is now

   <quote> <em/13/, <em/14/, <em/15/, <em/18/, <bf/12/, <bf/16/, 14,
   16 </quote>

   <label id="def merge-to"> The <tt/merge-to/ rules are applied.
   Their meaning is to make location references appear with another
   attribute as well, but only in the function of supporting the
   building of ranges. They disappear after the ranges are built. The
   location references that cause new location refererences to be
   added are called <em/parents/, whereas the new ones are called
   <em/childs/. The example rule results in the adding of all
   refernces with attribute `definition' to the attribute `default'
   which results in the list

   <quote> <em/13/, <em/14/, <em/15/, <em/18/, <bf/12/, <bf/16/, (13),
   14, (15), 16, (18) </quote>

   The childs are put in parenthesis since they may only be used to
   build up ranges.

   For each attribute we now try to build ranges. Since the switch
   <tt/:drop/ was specified we must start with the attribute
   `default', because a successful merging of location references may
   result in dropping the parents. This results in the range `13--16'.
   The childs
   (13) and (15) were used in the building of ranges, so their parents
   <em/13/ and <em/15/ have to be removed from the list of
   location references. This step would be omitted if the switch
   <tt/:drop/ were not specified. After unsucessfully trying to build
   more ranges and dropping the location references <em/13/, <em/15/
   and (18)--which was only meant to build ranges--we obtain the list

   <quote>
   <em/14/, <em/18/, <bf/12/, <bf/16/, 13--16
   </quote>

   Finally the attributes are brought into the right order. In our
   example the location references of the first attribute group are
   merged and sorted lexicographically resulting in two attribute groups

   <quote>
   (<bf/12/, <em/14/, <bf/16/, <em/18/) (13--16)
   </quote>

<#if output=comment>
  <label id="sort-merge-locrefs">
  <item> To illustrate the processing of location references we assume
  the following list:

  <quote> <em/13/, <em/14/, <em/15/, <em/18/, <bf/12/, <bf/13/,
  <bf/14/, <bf/16/, 14, 16 </quote>

   The location references displayed in <em/italics/ own the attribute
   `definition', the <bf/boldface/ ones have attribute `important' and
   the others have attribute `default'. Imagine, the attribute groups
   were defined with the command

   <tscreen><verb>
   (define-attributes (("definition" "important") ("default")))
   </verb></tscreen>

   See command <tt>define-attributes</tt> for a detailed description.

   First, the substitution rules are applied. This means that
   location references <bf/13/ and <bf/14/ with attribute `important'
   are <em/substituted/ by the location references <em/13/ and <em/14/
   with attribute `definition'. Substitution means removing from the
   list of location references.

   Substitution occurs because the definition of the attribute groups
   implicitly defines `definition' <em/substitutes/ `important'.

   The resulting list is now

   <quote> <em/13/, <em/14/, <em/15/, <em/18/, <bf/12/, <bf/16/, 14, 16
   </quote>

   After building ranges for each attribute separately we obtain the
   following location references:

   <quote> <em/13/--<em/15/, <em/18/, <bf/12/, <bf/16/, 14, 16
   </quote>

   Finally the attributes are brought into the right order. In our
   example the location references of the first attribute group are
   merged and sorted lexicographically resulting in two
   attribute groups

   <quote>
   (<bf/12/, <em/13/--<em/15/, <bf/16/, <em/18/) (14, 16)
   </quote>

   The first braced list is the result of the attribute group
   <tt/("definition" "important")/ and the second one is the result of
   group <tt/("default")/. The braces are only used to emphasize the
   analogy to the attribute groups.
</#if>

</itemize>

</enum>

After all index entries have been processed the letter groups are
formed and the index entries and location references are transformed
into tree like structures as defined in the index style.


<!-- ================================================================= -->

<label id="markup-phase">
<sect1>The Markup Phase
<p>
After the index has completely been processed, the markup phase
traverses the tree-like structure of the index. Each step triggers the
appropriate markup events resulting in the emitting of markup tags.
This phase can be traced by using the command line option <tt/-t/.

<!-- ================================================================= -->

<sect>Invoking &xindy;

<p>

<!-- ================================================================= -->

<label id="cmdline">
<sect1>Command Line Options

<p>
The following command line options are accepted:

<tscreen><verb>
xindy  [-h] [-t] [-v] [-l logfile] [-o outfile]
       [-L n] [-f filterprog]
       indexstyle raw-index
</verb></tscreen>

The argument <tt/indexstyle/ names a file, containing the index style
description. The argument <tt/raw-index/ names a file, containing the
raw index. Both arguments are mandatory.

<tscreen><verb>
<tag/<tt/-h// Gives a short summary of all command line options.

<tag/<tt/-l// Writes helpful information into the specified
<tt/logfile/. For example, the keyword mappings are written into this
file, so one can check if the intended mappings were actually
performed this way.

<tag/<tt/-o// Explicitly defines the name of the <tt/output/ file. If
not given, the name of the <tt/raw-index/ is used with its extension
changed to `<tt/.ind/' (or added, if it had no extension at all).

<tag><tt/-t// Enters tracing mode of the symbolic markup tags. The
format of the emitted tags can be defined with the command
<tt/markup-trace/.

<tag/<tt/-L// Set the &xindy; logging-level to <em/n/.

<tag/<tt/-f// Run <tt/filterprog/ on <tt/raw-index/ before reading.
The program must act as a filter reading from stdin and writing to
stdout. The most obvious use of this option in conjunction with &TeX;
is to run <tt/-f tex2xindy/ on the index file prior to reading the
entries into &xindy;.


<tag/<tt/-v// Shows the version number of &xindy;.

</verb></tscreen>

Errors and warnings are reported to <tt/stdout/ and additionally to
the logfile if <tt/-l/ was specified.

<!-- ================================================================= -->

<label id="def searchpath">
<sect1>Search Path

<p>
The system uses the concept of a <em/search path/ for finding the
index style files and modules. The searchpath can be set with the
environment variable <tt/XINDY_SEARCHPATH/ which must contain a list
of colon-separated directories. If it ends with a colon, the built-in
searchpath is added to the entire searchpath. See the command
<tt>searchpath</tt> for further details.

<#if output=html>

<sect>Index
<label id="INDEX">
<p>

<bf/List of Commands/
<p>
<ref id="define-attributes" name="define-attributes">
<newline>
<ref id="define-alphabet" name="define-alphabet">
<newline>
<ref id="define-crossref-class" name="define-crossref-class">
<newline>
<ref id="define-letter-group" name="define-letter-group">
<newline>
<ref id="define-letter-groups" name="define-letter-groups">
<newline>
<ref id="define-location-class" name="define-location-class">
<newline>
<ref id="define-location-class-order" name="define-location-class-order">
<newline>
<ref id="define-rule-set" name="define-rule-set">
<newline>
<ref id="define-sort-rule-orientations" name="define-sort-rule-orientations">
<newline>
<ref id="indexentry" name="indexentry">
<newline>
<ref id="markup-attribute-group" name="markup-attribute-group">
<newline>
<ref id="markup-attribute-group-list" name="markup-attribute-group-list">
<newline>
<ref id="markup-crossref-layer" name="markup-crossref-layer">
<newline>
<ref id="markup-crossref-layer-list" name="markup-crossref-layer-list">
<newline>
<ref id="markup-crossref-layer" name="markup-crossref-layer">
<newline>
<ref id="markup-index" name="markup-index">
<newline>
<ref id="markup-indexentry" name="markup-indexentry">
<newline>
<ref id="markup-indexentry-list" name="markup-indexentry-list">
<newline>
<ref id="markup-keyword" name="markup-keyword">
<newline>
<ref id="markup-keyword-list" name="markup-keyword-list">
<newline>
<ref id="markup-letter-group" name="markup-letter-group">
<newline>
<ref id="markup-letter-group-list" name="markup-letter-group-list">
<newline>
<ref id="markup-locclass-list" name="markup-locclass-list">
<newline>
<ref id="markup-locref" name="markup-locref">
<newline>
<ref id="markup-locref-class" name="markup-locref-class">
<newline>
<ref id="markup-locref-layer" name="markup-locref-layer">
<newline>
<ref id="markup-locref-layer-list" name="markup-locref-layer-list">
<newline>
<ref id="markup-locref-list" name="markup-locref-list">
<newline>
<ref id="markup-range" name="markup-range">
<newline>
<ref id="markup-trace" name="markup-trace">
<newline>
<ref id="merge-rule" name="merge-rule">
<newline>
<ref id="merge-to" name="merge-to">
<newline>
<ref id="require" name="require">
<newline>
<ref id="searchpath" name="searchpath">
<newline>
<ref id="sort-rule" name="sort-rule">
<newline>
<ref id="use-rule-set" name="use-rule-set">

</#if>

<sect>References
<p>

The following books and papers were referenced in this document.

<enum>
<item> D. E. Knuth, <em/The &TeX;book/, Addison-Wesley, 1984

<item> Leslie Lamport, &LaTeX; <em/A Document Preparation System/,
Addison-Wesley, 1986

<item> Joachim Schrod, <em/An International Version of MakeIndex/,
Cahiers GUTenberg, 10, p81-90, 1991

<item> Pehong Chen and Michael A. Harrison, <em/Automating Index
Preparation/, TR-87/347, University of California Berkeley, 1987
<label id="makeindex">

<item> Roger Kehr, &xindy;, <em/Ein Flexibles Indexierungssystem/,
Studienarbeit FB Informatik, TH-Darmstadt, November 1995.

<item> Joachim Schrod and Gabor Herr, <em/MakeIndex Version 3.0/,
Technical University Darmstadt, 1991

<item> Roger Kehr, &xindy; -- <em/A Flexible Indexing System/,
Technical Report No. 11/1997, Computer Science Department, Darmstadt
University of Technology, 1997. Also accessible from the &xindy;
homepage.

<item> Roger Kehr, &xindy; -- <em/A Flexible Indexing System/,
Proceedings of the Euro&TeX;'98, St. Malo, France, March 1998

</enum>

</article>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
End:
-->
