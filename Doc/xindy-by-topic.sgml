<!doctype linuxdoc system>

<!-- This is the xindy-by-topic manual of the xindy-system

     $Id$

 -->

<article>

<!-- Title information -->

<title><sf/xindy/

<subtitle><sf/A Flexible Indexing System/

<author>Roger Kehr, Institut für Theoretische Informatik, TH-Darmstadt

<date>xindy by Topic, Edition February 1997 for xindy version 1.1

<abstract>
<em>The <sf/xindy/ by topic manual is intended for all practitioners
that do not want to read too much about <sf/xindys/ details but rather
start to solve concrete problems. Thus, we have written it in a how-to
manner starting from a concrete real-world problem and describing all
the necessary steps that are needed to solve the problem.
</em>
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->


<sect>How to ...

<sect1>I don't want to write style files. How can I proceed?
<p>

You can use the wrapper program <tt/makeindex4/. It tries hard to make
<sf/xindy/ behave as <tt/makeindex/ does. But if you ever need to use
some of the features of <sf/xindy/ you should learn how to write an
index style. Its easy!


<sect1>Eventually, I decided to write my first index style. How can I start?
<p>

Congratulations! You have made a good decision, indeed.

For a first impression, how a style file can be written from scratch
reference the tutorial that comes with this distribution. It is
written as a guided step-by-step practicing exercise and you can learn
the basic concepts quite easily.

Afterwards, the best starting point is to make a copy of the template
file that contains all the necessary commands that are needed to make
a <tt/makeindex/-like index. Starting from this template you can
remove or add commands as necessary.

Additionally, consult the library of predefined index style modules
that come with this distribution. Solutions for most of the typical
problems can be found there, such as a module for doing
case-insensitive sorting rules, or a typical &TeX;-like markup. Most
of the time is is enough to include some of these modules and add a
few own commands.

Maybe some of the examples coming with the test-suite are good
examples of how unusual index style files can be written.

Thus, there are many ways to learn writing an index style file. But it
is very easy and after some experience you can process indexes your
friends will be jealous of.



<sect1>I want to process an index for my native language. What must I do?
<p>

XXX

What makes <tt/makeindex/ hardly usable in non-English speaking
countries is its lack for supporting language specific alphabets and
sort orderings. For example, many roman languages such as Italian,
French, Portuguese or Spanish contain accented letters such as
&Agrave;, &Aacute;, &ntilde;. Other languages from northern Europe
have letters like &Auml;, &Oslash;, &aelig; or &szlig; which often
can't even be processed by many index processors let alone sorting
them correctly into an index.

Two problems must be solved when processing indexes with a new
languages:

<enum>
<item> The <em/sort ordering/ of the indexed terms must be specified
in an appropriate manner. This problem can be solved using the
so-called <em/keyword mappings/.

<item> The <em/letter groups/ that partition the indexed terms into
separate sections must be specified.
</enum>


<bf/Keyword Mappings/
<p>

The <sf/xindy/ system can be configured to process these alphabets by
defining <em/sort/ and <em/merge rules/ that allow expressing language
specific rules. The index style commands acomplishing this task are
<tt/sort-rule/ and <tt/merge-rule/. One example of such a rule would
be

<tscreen><verb>
(sort-rule "ä" "ae")
</verb></tscreen>

defining that a word containing the umlaut-a will be sorted as if it
contained the letters <tt/ae/ instead. This is one form of how the
umlaut-a (ä) is sorted into german indexes. With an appropriate set of
rules on can express the complete rules of a specific language.

The keyword mappings are as follows: The <em/merge key/ is generated
from the <em/main key/ with the so called <em/merge mapping/. The
merge mapping can be specified with the command <tt/merge-rule/. The
<em/sort key/ is derived from the merge key using the <em/sort
mapping/ specified with the <tt/sort-rule/ command. The following
scheme shows this mapping process:

<figure>
<img HTML="mappings.gif" TEX="mappings.latex"
     PLAIN="key -> merge key -> sort key">
</figure>

An example of how an appropriate mapping for some of the Roman
languages could look like is:

<tscreen><verb>
(sort-rule "à" "a")
(sort-rule "á" "a")
(sort-rule "ã" "a")
(sort-rule "è" "e")
(sort-rule "é" "e")
(sort-rule "ç" "c")
</verb></tscreen>

This makes the accented letters be sorted as their unaccented
counterparts, yielding the desired sort ordering.

<p>

<bf/Advanced Keyword Mappings/

<p>
Sometimes it is necessary to specify keyword mappings that tell the
system to put something <em/behind/ something else. For instance, we'd
like to map the character <em/ö/ behind the letter <em/o/. No problem
if you use the special characters <vb>~b</vb> and <vb>~e</vb> which
are called the <em/beginning/ and <em/ending/ characters. The first
letter lexicographically precedes all other letters whereas the latter
one comes after all others. Our mapping problem can now be specified
as follows.

<tscreen><verb>
(sort-rule "ö" "o~e")
</verb></tscreen>

Now the <em/ö/ is directly positioned after the <em/o/ but before
<em/p/.


See the manual for a detailed description of this feature.
Also be informed that the keyword mappings can be specified with
regular expressions. Rules of the form

<tscreen><verb>
(merge-rule "[-$()]" "")
</verb></tscreen>

are possible. This on removes all letters of the defined letter class.
Regular expression substitutions are possible as well. Refer to the
manual for an exact description.



<sect1>In my index the capitalized words appear after the lowercase words. Why?
<p>

The default sort ordering sorts letters according to the ISO Latin
alphabet. As a consequence the lowercase letters appear before the
uppercase letters. To sort them case-insensitively use the command

<tscreen><verb>
(require "lang/latin/caseisrt.xdy")
</verb></tscreen>

This module defines the appropriate sort rules for the letters `A-Z'
for latin-based alphabets. If your language has more letters simply
add the missing ones into the style file. Have a look at the module to
see how to the sort rules are defined.


<sect1>In my index there are no letter groups, yet!
<p>

Letter groups for latin based alphabets can be defined with the command

<tscreen><verb>
(require "lang/latin/letgroup.xdy")
</verb></tscreen>

If your language needs additional letter groups you can insert them
into the previously defined letter group with definitons like the
following:

<tscreen><verb>
(define-letter-group "ly" :after "l" :before "m")
(define-letter-group "ny" :after "n" :before "o")
</verb></tscreen>

This adds two more letter groups to the latin alphabet. Group <em/ly/
is inserted between <em/l/ and <em/m/, and <em/ny/ is inserted between
<em/n/ and <em/o/. This is how two additional letters of the Hungarian
alphabet can be inserted.



<sect1>How can I get rid of any formatting information in the keyword?
<p>

Assume you have index entries containing arbitrary formatting
information. For example you write your index entries in &TeX; in the
following form:

<tscreen><verb>
\index{\bf{In boldface please}}
</verb></tscreen>

To avoid specifying for each index entry the print key separately as
can be done with the following command

<tscreen><verb>
\index{In boldface please@\bf{In boldface please}}
</verb></tscreen>

you can instead define a rule doing this task for you:

<tscreen><verb>
(merge-rule "\\bf *{(.*)}" "\1" :eregexp :again)
</verb></tscreen>

This extended regular expression matches all strings that are
surrounded by this formatting command and in the <em/merge phase/ the
formatting command is simply stripped off. Thus, you don't need to
write an explicit print key anymore.

If for some reason you have the same word appears more than once in the
index, each time having another markup tag as in the following example

<tscreen><verb>
index
{\tt index}
</verb></tscreen>

you must be warned that a rule like

<tscreen><verb>
(merge-rule "{\\tt *(.*)}" "\1" :eregexp :again)
</verb></tscreen>

is not correct. In this case the above strings are both mapped into
the string <tt/index/ thus joining their location references into one
index entry. This happens because the result of the merge mapping is
used as the equality citerium which views both keywords as equal. To
avoid this you should specify instead

<tscreen><verb>
(merge-rule "{\\tt *(.*)}" "\1~e" :eregexp :again)
</verb></tscreen>

With the additional meta character <vb>~e</vb> the substitution of the
second key word is placed <em/after/ the first one making them
different index entries. If the second keyword should appear first,
use <vb>~b</vb> instead.



<sect1>In my index the word <em/-foo/ appears before <em/bar/. What must I do?
<p>
Especially for hierarchical indexes sometimes the result is not as
expected due to special characters such as hyphens. In the following
example the word `card' should appear before `-eyed' since the hyphen
should not count as an ordinary character by means of sorting.

<tscreen><verb>
  green
     -eyed  12
     card   15
</verb></tscreen>

This is especially problematic if the list of words on the second
level is very long. To make the hyphen be simply ignored during the
sorting process you should specify the following command in the index
style:

<tscreen><verb>
  (sort-rule "-" "")
</verb></tscreen>

This makes `-eyed' be sorted as `eyed' thus making it appear
<em/after/ `card' as desired.



<sect1>I want to use letter ordering and not word ordering.
<p>

According to the <em/Chicago Manual of Style/ there exist two
different schemes of sorting word lists. In <em/word ordering/
a blank precedes any letter in the alphabet, whereas in <em/letter
ordering/ it does not count at all. The following example borrowed
from the <tt/makeindex/ man-page illustrates the difference:

<tscreen><verb>
 Word Order:         Letter Order:
  sea lion            seal
  seal                sea lion
</verb></tscreen>

By default, <sf/xindy/ uses word ordering. To use letter ordering
include the appropriate module with the following command:

<tscreen><verb>
(require "ord/letorder.xdy")
</verb></tscreen>

It actually defines the following command:

<tscreen><verb>
(sort-rule " " "")
</verb></tscreen>

This simply removes all blanks from the keyword resulting in the
desired behaviour.



<sect1>My document does not have page numbers, but a different scheme. What must I do?
<p>

XXX  Location classes, Alphabets.


<sect1>I want do mark some page numbers in boldface, others in italics. What must I do?
<p>

XXX Attrubutes, Attribute Groups.


<sect1>I have several successive pages numbers I want to join together. What can I do?
<p>

XXX Ranges definieren und deren Markup.



<sect1>I want to markup ranges of different length differently. How do I accomplish this?
<p>

A common way of tagging ranges is as follows: a range of length 1 is
printed with the starting page number and the suffix `f.', those of
length 2 with suffix `ff.', and all others in the form `<em/X--Y/'.

Assume we want to do this for the location class <em/pagenums/ we can
specify the markup as follows:

<tscreen><verb>
(markup-range :class "pagenums" :close "f."  :length 1 :ignore-end)
(markup-range :class "pagenums" :close "ff." :length 2 :ignore-end)
(markup-range :class "pagenums" :sep "--")
</verb></tscreen>

The first command indicates that a range <em/(X,Y)/ of length 1 should
be printed in the form <em/Xf./, a range of length 2 as <em/Xff./ and
all others in the form <em/X--Y/. The switch <tt/:ignore-end/ causes
the end of range location reference Y to be suppressed in the
resulting output.


<sect1>I need to suppress some of the markup tags. How can I do this?
<p>
Sometimes it is necessary to hide some of the parts of the index. If
you have a text formatter that allows comments or macros that possibly
expand to nothing, just define appropriate markup that makes things
invisible to the formatter. For example, with &TeX; you can define a
macro like this

<tscreen><verb>
\def\ignore#1{}
</verb></tscreen>

If you additionally define markup like this

<tscreen><verb>
(markup-index :open "\ignore{" :close "}")
</verb></tscreen>

you can throw away the complete index if you like, which would be a
real pity!


<sect1>Whats it all about those cross references?
<p>

XXX

<sect>Practical Tips


<sect1>What &LaTeX;-package should I use in conjunction with <sf/xindy/?
<p>

We strongly recommend using the &LaTeX;2e-package <tt/index/ written
by David M. Jones, which is available at CTAN. It supports multiple
indexes as well as several shortcuts to index terms easily. Multiple
indexes support the generation of several indexes for one document.
For instance, one can make an author or command index in addition to a
global index.


<sect1>What editor should I use when writing <sf/xindy/ style files?
<p>

Use <tt/Emacs/ or <tt/XEmacs/. Turn on the Lisp-mode with

<tscreen><verb>
M-x lisp-mode
</verb></tscreen>

and you can properly indent commands using <tt/M-q/. To enter this
mode automatically add the following lines to the end of the style
file:

<tscreen><verb>
^L
;; Local Variables:
;; mode: lisp
;; End:
</verb></tscreen>

The <vb>^L</vb> (Control-L) can be entered with <tt/C-q C-l/.


<sect1>I have written a module for processing language <em/foolandic/. What must I do?
<p>

Great! Send it to us! It will become a part of the system in the next
release.



<!-- -->



<sect>Errors and Problems


<sect1>The keyword mappings don't work as expected!
<p>

Sometimes the keyword mappings don't work as expected. Especially in
cases with several regular expressions one might get confused about
what rule matches exactly when. We have incorporated a detailed
logging mechanism that lets one step by step follow the rules that
accomplish the keyword mapping.

When running <sf/xindy/ you can turn on this feature with the command
line option `<tt/-L/'. This option followed by one of the numbers 1,
2, or 3 turns on the appropriate debugging level. Turning on level 2
or 3 and specifying a log-file with the command line option `<tt/-l/'
a trace of the mappings is recorded in the log-file. A sample output
looks like the following:

<tscreen><verb>
Mappings: (add (merge-rule :eregexp `^\\bf{(.*)}' `\1' :again)).
Mappings: (add (merge-rule :eregexp `^\\"([AEOUaeou])' `\1')).
 ...
Mappings: (compare `\"A\"a' :eregexp `^\\bf{(.*)}')
Mappings: (compare `\"A\"a' :eregexp `^\\"([AEOUaeou])') match!
Mappings: (compare `\"a' :eregexp `^\\bf{(.*)}')
Mappings: (compare `\"a' :eregexp `^\\"([AEOUaeou])') match!
Mappings: (merge-mapping `\"A\"a') -> `Aa'.
</verb></tscreen>

This trace shows that initially two regular expression mappings have
been added to the rule set. The second section shows how the keyword
`<vb>\"A\"a</vb>' is compared to these rules and substitutions are
applied as matches are found. In the last line the result of the
keyword mapping is reported.


<sect1>I'm totally confused by the markup scheme!
<p>

A very important feature is the ability to <em/trace/ all markup tags
<sf/xindy/ emits in the markup phase. Simply use the command line
switch <tt/-t/ or insert the command

<tscreen><verb>
(markup-trace :on)
</verb></tscreen>

into the index style. This informs <sf/xindy/ to emit additional
pseudo markup that can be used to understand and debug the
markup phase. An example output might look like the following:

<tscreen><verb>
<INDEX:OPEN>
  <LETTER-GROUP-LIST:OPEN>
    <LETTER-GROUP:OPEN ["a"]>
      <INDEXENTRY-LIST:OPEN [0]>
        <INDEXENTRY:OPEN [0]>
          <KEYWORD-LIST:OPEN [0]>
            <KEYWORD:OPEN [0]>
 ...
</verb></tscreen>

The symbolic tags directly lead one to the command that is responsible
for the definition of that markup tag. For example, the tag
<vb>LETTER-GROUP-LIST:OPEN</vb> indicates that the command
<vb>markup-letter-group-list</vb> is responsible for replacing this
symbolic tag by a real one.

Give it a try if you find yourself confused by your own markup
specification.





<!-- ================================================================= -->



</article>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
End:
-->
