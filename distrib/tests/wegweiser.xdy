;;
;; Index style to process the `wegweiser' index.
;;

(define-attributes (("default")))

(define-crossref-class "see")
(define-crossref-class "seealso")

(markup-crossref-list :open "\see{" :close "}{}")
(markup-crossref-list :open "\seealso{" :close "}{}")

;; Here are the location-classes

(define-location-class "arabic-page-numbers" ("arabic-numbers"))
(define-location-class "roman-page-numbers"  ("roman-numbers-lowercase"))
(define-location-class "Roman-page-numbers"  ("roman-numbers-uppercase"))
(define-location-class "alpha-page-numbers"  ("alpha"))
(define-location-class "Alpha-page-numbers"  ("ALPHA"))

(define-location-class-order ("roman-page-numbers"
			      "arabic-page-numbers"
			      "alpha-page-numbers"
			      "Roman-page-numbers"
			      "Alpha-page-numbers"
			      "see" "seealso" ))

;; preamble <string>        "\\begin{theindex}\n"
;; postamble <string>       "\n\n\\end{theindex}\n"

(markup-index :open  "\begin{theindex}~n"
	      :close "~n~n\end{theindex}~n"
	      :tree)

;; These specifiers are not directly supported via a command-line
;; switch as in makeindex. Add the appropriate markup-commands into
;; the preamble.

;; setpage_prefix <string>  "~n  \setcounter{page}{"
;; setpage_suffix <string>  "}~n"


;; group_skip <string>      "~n~n  \indexspace~n"

(markup-letter-group-list :sep "~n~n  \indexspace~n")

;; The indexentries (item_<..> specifiers)

(markup-indexentry :open "~n  \item "           :depth 0)
(markup-indexentry :open "~n    \subitem "      :depth 1)
(markup-indexentry :open "~n      \subsubitem " :depth 2)

;; Location-references

;; delim_0 <string>         ", "
;; delim_1 <string>         ", "
;; delim_2 <string>         ", "

(markup-locclass-list :open ", " :sep ", ")

;; delim_n <string>         ", "

(markup-locref-list   :sep ", ")

;; delim_r <string>         "--"

(markup-range :sep "--")

;; Here follow all letter-groups. The short-cut notation is used here.

(define-letter-groups
    ("a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m"
     "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"))

;;
;; The sort-rules map all letters to their lowercase counterpart.
;;

(sort-rule "A" "a")
(sort-rule "B" "b")
(sort-rule "C" "c")
(sort-rule "D" "d")
(sort-rule "E" "e")
(sort-rule "F" "f")
(sort-rule "G" "g")
(sort-rule "H" "h")
(sort-rule "I" "i")
(sort-rule "J" "j")
(sort-rule "K" "k")
(sort-rule "L" "l")
(sort-rule "M" "m")
(sort-rule "N" "n")
(sort-rule "O" "o")
(sort-rule "P" "p")
(sort-rule "Q" "q")
(sort-rule "R" "r")
(sort-rule "S" "s")
(sort-rule "T" "t")
(sort-rule "U" "u")
(sort-rule "V" "v")
(sort-rule "W" "w")
(sort-rule "X" "x")
(sort-rule "Y" "y")
(sort-rule "Z" "z")

;;;

(merge-rule "\\cmd[ ~t]*{(.*)}" "\1" :again :bregexp)
(merge-rule "\\aut[ ~t]*{(.*)}" "\1" :again :bregexp)


;; Local Variables:
;; mode: lisp
;; End:

