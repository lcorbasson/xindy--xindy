%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module: index-style
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{index-style}}

\subsection{Introduction}

The indexstyle is defined by a set of indexclasses. This allows the
user to define several different indexclasses for different purposes.
We're currently unsure about the needs the users will have so we
decided to use a simple model. We declare a pre-defined indexclass
[[default]] that contains some basic alphabets and basetypes. The
users are able to extend the definitions made in this class by
defining location-classes, rules, markups \etc as they like.

\bigskip

In the future we plan that users may define additional classes. If a
user adds a new indexclass its definitions \emph{shadow} the
definitions made in class [[default]].  So a new indexclass
\emph{inherits} is components from class [[default]] and extends or
shadows those inherited definitions. There exist no inheritance
definitions among the user-defined indexclasses.


\subsection{Concrete Specification}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The Indexstyle}

The \term{indexstyle} is organised by a hierarchy of indexclasses.
Currently we only support a assoc-list of different indexclasses
indexed by name.  Therefore the notion \term{scope} describes the
environment that is defined by a given indexclass. The list of
indexclasses is stored in the variable [[*indexstyle*]]. It is the
root of all indexstyle descriptions. We also keep track of the
currently active indexclass-name which is stored in
[[*active-idxcls-name*]].\footnote{This is currently unused.}

<<Global indexstyle definitions>>=
(defvar *indexstyle* '())
(defvar *active-idxcls-name* nil)
@

<<The indexstyle>>=
(defun create-indexclass (idxcls-name)
  (setq *active-idxcls-name* idxcls-name)
  (setf *indexstyle* (make-indexclass idxcls-name)))
@ %def *indexstyle* *active-idxcls-name* create-indexclass

<<Export-list of submodule \module{idxstyle}>>=
(export '(*indexstyle*
          *active-idxcls-name*
          create-indexclass))
@

\begin{TODO}
  \item Define the hierarchy of indexclasses and implement the
  [[find-]]functions corresponding to the defined hierarchy.
\item Implement the rest of the neccessary [[find-]]functions that are
  still unimplemented yet.
\end{TODO}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Predefined default style}

<<Default style>>=
<<Default alphabets>>
<<Default enumerations>>
@

These are the predefined alphabets for upper- and lowercase letters.

<<Default alphabets>>=
(basetype-by-string "ALPHA" "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(basetype-by-string "alpha" "abcdefghijklmnopqrstuvwxyz")
(basetype-by-string "digits" "0123456789")
@

Here follows a general-purpose function
[[prefix-match-for-radix-numbers]] which is capable to recognize
radix-based numbers with a radix ranging from 2\ldots36.

<<Default enumerations>>=
(defun prefix-match-for-radix-numbers (str radix)
  (let* ((n nil)
         (strlen (length str))
         (len-match (do ((i 0 (1+ i)))
                        ((or (>= i strlen)
                             (not (digit-char-p (char str i) radix)))
                           i)
                      (setq n (+ (* (if n n 0) radix)
                                 (digit-char-p (char str i) radix))))))
    (values (subseq str 0 len-match)
            (subseq str len-match)
            n)))
@

Here follows the definition of a enumeration type for positive arabic
numbers. First we define a new class that is subclass of
[[enumeration]]. We then define the method [[prefix-match]] which is
bound to our new class and calculation is forwarded by giving the
help-function [[prefix-match-for-radix-numbers]] a radix of 10. We
could implement enumeration types for binary, octal and hexadecimal
numbers straightforward by defining new classes and binding them with
the radixes 2, 8 and 16. Finally we make the new enumeration type
known in the indexclass [[default]] by defining a new class of name
[[enumeration-arabic-numbers]], a name and the string containing the
basetype-characters. Quiet easy, isn't it ?

<<Default enumerations>>=
(defclass enumeration-arabic-numbers (enumeration) ())

(defmethod prefix-match ((str string) (enum enumeration-arabic-numbers))
  (prefix-match-for-radix-numbers str 10))

(enumeration 'enumeration-arabic-numbers
             "Arabic Numbers"
             "01234567890")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The module root}

<<*>>=
;; $Id$
;;

(in-package 'idxstyle)
(provide 'idxstyle)

(eval-when (compile load)
  (use-package 'clos)
  (use-package 'xp)
  (unless (find-package 'locref)
    (load 'locref))
  (use-package 'locref))

<<Global indexstyle definitions>>
<<Submodule \module{idxrule}>>
<<Submodule \module{idxclass}>>
<<Submodule \module{indexstyle}>>
<<Submodule \module{intface}>>

<<Pretty-printing>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))

<<Export-list of submodule \module{idxstyle}>>
@

\subsubsection{The submodule root}

<<Submodule \module{indexstyle}>>=
<<The indexstyle>>
@

<<RCS-Identifier>>=
("idxstyle" . "$Id$")
@

%% Local Variables:
%% mode: latex
%% TeX-master: t
%% End:
%%
%% $Log$
%% Revision 1.3  1995/12/19 10:58:48  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:26  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:24  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from scratch.
%%
%% Revision 1.4  1995/12/07  13:21:31  kehr
%% Dies ist das Projekt zum Zeitpunkt der Abgabe.
%%
%% Revision 1.3  1995/11/21  14:55:16  kehr
%% Added support for DejaGnu-Framework.
%%
%% Revision 1.2  1995/11/08  16:18:05  kehr
%% Minor modifications.
%%
%% Revision 1.1  1995/10/16  19:23:07  kehr
%% Initial source checkin.
%%
%% Revision 1.4  1995/07/23  20:48:34  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.3  1995/07/10  23:26:58  kehr
%% Corrected bugs that caused location-class-matching to fail. Also
%% discovered some bugs in matching under certain circumstances, I hadn't
%% tested so far.
%%
%% Revision 1.2  1995/07/10  00:58:17  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
%% Revision 1.1  1995/07/09  18:14:28  kehr
%% Initial checkin.
%%
