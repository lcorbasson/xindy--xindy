%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module: index-style
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{index-style}}

\subsection{Introduction}

The indexstyle is defined by a set of indexclasses. This allows the
user to define several different indexclasses for different purposes.
We're currently unsure about the needs the users will have so we
decided to use a simple model. We declare a pre-defined indexclass
[[default]] that contains some basic alphabets and basetypes. The
users are able to extend the definitions made in this class by
defining location-classes, rules, markups \etc as they like.

\bigskip

In the future we plan that users may define additional classes. If a
user adds a new indexclass its definitions \emph{shadow} the
definitions made in class [[default]].  So a new indexclass
\emph{inherits} is components from class [[default]] and extends or
shadows those inherited definitions. There exist no inheritance
definitions among the user-defined indexclasses.


\subsection{Concrete Specification}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The Indexstyle}

<<The indexstyle>>=
(defun create-indexclass (idxcls-name)
  (setq *indexstyle* (make-indexclass idxcls-name)))
@ %def create-indexclass

<<Export-list of submodule \module{idxstyle}>>=
(export 'create-indexclass)
@

\begin{TODO}
  \item Define the hierarchy of indexclasses and implement the
  [[find-]]functions corresponding to the defined hierarchy.
\item Implement the rest of the neccessary [[find-]]functions that are
  still unimplemented yet.
\end{TODO}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Predefined default style}

\subsubsection{Global definitions}

The indexstyle itself will be initialised later after all functions are known.

<<Global indexstyle definitions>>=
(defparameter *indexstyle* nil)
(defparameter *default-minimum-range-length* 3)
@ %def *indexstyle* *default-minimum-range-length*

<<Global indexstyle initialisation>>=
<<Initialize indexclass [[default]]>>
<<Define default alphabets>>
<<Define default enumerations>>
@

<<Initialize indexclass [[default]]>>=
(create-indexclass "default")
@

\no These are the predefined alphabets for upper- and lowercase letters.

<<Define default alphabets>>=
(defmacro string-expand (str)
  (let ((str-expansion
         (map 'list
              #'(lambda (c)
                  (make-string 1 :initial-element c))
              str)))
    `(QUOTE ,str-expansion)))

(define-alphabet "ALPHA"  (string-expand "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
(define-alphabet "alpha"  (string-expand "abcdefghijklmnopqrstuvwxyz"))
(define-alphabet "digits" (string-expand "0123456789"))
@ %def string-expand

\no Here follows a general-purpose function
[[prefix-match-for-radix-numbers]] which is capable to recognize
radix-based numbers with a radix ranging from 2\ldots36.

<<Define default enumerations>>=
(defun prefix-match-for-radix-numbers (str radix)
  (let* ((n nil)
         (strlen (length str))
         (len-match (do ((i 0 (1+ i)))
                        ((or (>= i strlen)
                             (not (digit-char-p (char str i) radix)))
                           i)
                      (setq n (+ (* (if n n 0) radix)
                                 (digit-char-p (char str i) radix))))))
    (values (subseq str 0 len-match)
            (subseq str len-match)
            n)))
@

\no Here follows the definition of a enumeration type for positive
arabic numbers. First we define a new class that is subclass of
[[enumeration]]. We then define the method [[prefix-match]] which is
bound to our new class and calculation is forwarded by giving the
help-function [[prefix-match-for-radix-numbers]] a radix of 10. We
could implement enumeration types for binary, octal and hexadecimal
numbers straightforward by defining new classes and binding them with
the radixes 2, 8 and 16. Finally we make the new enumeration type
known in the indexclass [[default]] by defining a new class of name
[[enumeration-arabic-numbers]], a name and the string containing the
basetype-characters. Quiet easy, isn't it ?

<<Define default enumerations>>=
(define-enumeration arabic-numbers
                    #'(lambda (str)
                        (prefix-match-for-radix-numbers str 10))
                    "01234567890")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The module root}

<<*>>=
;; $Id$
;;

(in-package "IDXSTYLE")
(provide "IDXSTYLE")

(use-package "CLOS")
(use-package "XP")
(require "base")
(use-package "BASE")
(require "locref")
(use-package "LOCREF")
<<Use [[ordrules]]-package if available>> ;; see submodule intface

<<Global indexstyle definitions>>

<<Submodule \module{idxrule}>>
<<Submodule \module{idxclass}>>
<<Submodule \module{indexstyle}>>
<<Submodule \module{intface}>>

<<Global indexstyle initialisation>>

<<Pretty-printing>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))

<<Export-list of submodule \module{idxstyle}>>
@

\subsubsection{The submodule root}

<<Submodule \module{indexstyle}>>=
<<The indexstyle>>
@

<<RCS-Identifier>>=
("idxstyle" . "$Id$")
@

%% $Log$
%% Revision 1.8  1996/05/09 11:49:32  kehr
%% Changes in all submodules, due to macro-expansion problems during
%% compilation.
%%
%% Revision 1.7  1996/03/28  16:46:33  kehr
%% Changed indexstule modules to work with the new foreign package `ordrules'.
%%
%% Revision 1.6  1996/03/13  16:50:47  kehr
%% Ok, here I am. Included support for regular expressions. Minor changes
%% in all other parts of this module. Made some tests but had some
%% problems with LISP stack overflow errors. Don't know where they came
%% from. We'll see. The next step is to implement the string replacement
%% mechanism and set up extensive tests. Maybe I can use the tests from
%% Henry Spencer's regexp library.
%%
%% Revision 1.5  1996/01/31  15:29:22  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.4  1996/01/09  14:26:14  kehr
%% Major modifications.
%%
%% Revision 1.3  1995/12/19  10:58:48  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:26  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:24  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from scratch.
%%
%% Revision 1.4  1995/12/07  13:21:31  kehr
%% Dies ist das Projekt zum Zeitpunkt der Abgabe.
%%
%% Revision 1.3  1995/11/21  14:55:16  kehr
%% Added support for DejaGnu-Framework.
%%
%% Revision 1.2  1995/11/08  16:18:05  kehr
%% Minor modifications.
%%
%% Revision 1.1  1995/10/16  19:23:07  kehr
%% Initial source checkin.
%%
%% Revision 1.4  1995/07/23  20:48:34  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.3  1995/07/10  23:26:58  kehr
%% Corrected bugs that caused location-class-matching to fail. Also
%% discovered some bugs in matching under certain circumstances, I hadn't
%% tested so far.
%%
%% Revision 1.2  1995/07/10  00:58:17  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
%% Revision 1.1  1995/07/09  18:14:28  kehr
%% Initial checkin.

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:

