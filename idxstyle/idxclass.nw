%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Submodule: indexclass
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{indexclass}}

\subsection{Introduction}

Indexclasses serve as containers for indexstyle-information. They
hold information about configured basetypes, location-classes, rules,
and the successor-tables. Their main task is to add objects to the
indexclass and allow queries about objects stored in an indexclass.


\subsection{Abstract Specification}

\subsubsection{Definition}

An indexclass is a set
\begin{center}
  $\{$ \emph{name, basetypes, locclasses, rules, succ-table,
    not-succ-table, keyword-markup} $\}$
\end{center}
with
\begin{deflistit}{not-succ-table}
\item [name] is a \tstring containing the name of the indexclass.
\item [basetypes] is a list of \type{basetype}.
\item [locclasses] is a list of \type{locclass}.
\item [succ-table]
\item [not-succ-table]
\item [markup] Markup for the keywords.
\item [keyword-groups] Describe domains and markup of keyword-groups.
\end{deflistit}


\subsubsection{Operation}


\subsection{Concrete Specification}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{indexclass}}

The following class is a straightforward implementation of the
abstract specification. When specifying new location-classes we need a
fast lookup for bastypes via their names. Therefore we store in slot
[[basetypes]] a hash-table that allows easy lookup by name. It
specifies all already defined basetypes. New basetypes are added to
the hash-table, when reading the indexstyle.

Slot [[locclasses]] is a association list whose key is the
location-class name and its datum is the location-class itself. Slots
[[merge-rules]] and [[subst-rules]] are objects of type
\type{relation-rule} which are actually based on a relation
(\look{sec:relations}). After instantiation the indexclass will be
incrementally filled with more information.

<<Class \class{indexclass}>>=
(defclass indexclass ()
    ((name                 :initarg :name :type string)
     (basetypes            :accessor get-basetypes
                           :initform (make-hash-table :test #'equal :size 10))
     (cat-attrs            :accessor get-cat-attrs
                           :initform (make-catattr-groups))
     (locref-classes       :accessor get-locref-classes
                           :initform '() :type list)
     (xref-classes         :accessor get-xref-classes
                           :initform '() :type list)
     (letter-groups        :reader get-letter-groups
                           :initform (make-letter-group-manager))
     (partial-order-dict   :reader get-partial-order-dict
                           :initform (make-partial-order-dict))
     (letter-dict          :reader get-letter-dict
                           :initform (make-letter-dict))
     <<Location-reference-cache definitions>>
     ;;     (succ-table           :accessor get-succ-table
     ;;                           :initform (make-hash-table))
     <<Rules for indexing>>
     ))

(defun make-indexclass (name)
  (make-instance 'indexclass :name name))
@ %def indexclass make-indexclass

<<Export-list of submodule \module{idxclass}>>=
(export '(indexclass              make-indexclass
          get-name                get-basetypes
          get-cat-attrs           get-xref-classes
          get-succ-table          get-locref-classes
          <<Export-list for indexing rules>>
          ))
@

\subsubsection{The location-reference cache}

The location-reference cache is used to speed up the matching of
strings against location-class descriptions. Since each locref-string
is matched against every location-class the performance can be
improved if the result of each matching-process is stored for later
use. For an index with multiple references into a logical document
location the further matches can be looked up in the hash-table. The
following chunks define the data-structure layout of the locref-cache.

<<Global definitions of \module{idxclass}>>=
(defparameter *locref-cache-size*        1000)
(defparameter *locref-cache-rehash-size*    2)
(defparameter *locref-cache-hits*           0)
(defparameter *locref-cache-misses*         0)
@ %def *locref-cache-size* *locref-cache-rehash-size*

<<Location-reference-cache definitions>>=
     (locref-cache :initform (initialize-locref-cache))
@

<<Location-reference-cache>>=
(defun initialize-locref-cache ()
  (setq *locref-cache-hits*   0)
  (setq *locref-cache-misses* 0)
  (make-hash-table :test #'equal
                   :size        *locref-cache-size*
                   :rehash-size *locref-cache-rehash-size*))

(defmethod clear-locref-cache ((idxclass indexclass))
  (setf (get-locref-cache idxclass)
        (initialize-locref-cache)))

(defun set-locref-cache-parameters (&key (size 1000) (rehash-size 3))
  (when (< size 100) (setq size 100))
  (when (< rehash-size 1.5) (setq rehash-size 1.5))
  (setq *locref-cache-size* size)
  (setq *locref-cache-rehash-size* rehash-size))
@ %def initialize-locref-cache clear-locref-cache set-locref-cache-parameters

\no The items in the hash-table consists of a cons-cell
\texttt{(}\emph{number of matches}\texttt{\ .\ }%
  \emph{locref-template}\texttt{)}. The \emph{number} describes the number of
  matches for a locref-string and \emph{locref-template} is a
  location-reference that can be used to create a new location-reference.

<<Location-reference-cache>>=
(defmacro lookup-locref-cache (idxcls locref-string)
  `(LET ((LOCREF-LOOKUP (GETHASH ,locref-string
                                 (SLOT-VALUE ,idxcls 'LOCREF-CACHE))))
    (IF LOCREF-LOOKUP
        (PROGN
          (INCF *LOCREF-CACHE-HITS*)
          (VALUES (CAR LOCREF-LOOKUP) (CDR LOCREF-LOOKUP)))
        (PROGN
          (INCF *LOCREF-CACHE-MISSES*)
          (VALUES NIL NIL)))))

(defmethod add-locref-cache ((idxcls indexclass)
                             (locref-string string)
                             (num    number)
                             ;; the next one is typeless, since we
                             ;; also want to store the value NIL into
                             ;; it, to denote a mismatch
                             locref)
  (setf (gethash locref-string (get-locref-cache idxcls))
        (cons num locref))
  (values num locref))

(defmethod locref-statistics ((idxcls indexclass))
  (let ((ht (get-locref-cache idxcls)))
    (with-output-to-string (s)
      (format
       s "Statistics for locref-cache of indexclass ~S:~%" (get-name idxcls))
      (format
       s
       "Hash-table: size=~A, count=~A, cache-hits=~A, cache-misses=~A, hits=~4,1,,'*F%~%"
       (hash-table-size ht) (hash-table-count ht)
       *locref-cache-hits* *locref-cache-misses*
       (if (> *locref-cache-misses* 0)
           (* 100 (/ *locref-cache-hits* (+ *locref-cache-hits*
                                            *locref-cache-misses*)))
           100.0 #| produces an invalid value |#)))))
@ %def lookup-locref-cache add-locref-cache locref-statistics

<<Export-list of submodule \module{idxclass}>>=
(export '(locref-cache-size*      *locref-cache-rehash-size*
          initialize-locref-cache clear-locref-cache
          lookup-locref-cache     add-locref-cache
          locref-statistics))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Indexing rules}

The indexing process is highly driven by several rules the user can
specify accoring to his wishes. These rules are part of the indexstyle
and defined by the following slot descriptions.

<<Rules for indexing>>=
     (merge-rules          :reader get-merge-rules
                           :initform (make-merge-rule))
     (drop-if-merged-rules :reader get-drop-if-merged-rules
                           :initform (make-drop-if-merged-rule))
;;     (merge-rule-topsort   :reader get-merge-rule-topsort
;;                           :writer set-merge-rule-topsort
;;                           :initform '())

     <<Hooks for merge-rules>>

     (implicit-subst-rules :reader get-implicit-subst-rules
                           :initform (make-substitution-rule))
     (explicit-subst-rules :reader get-explicit-subst-rules
                           :writer set-explicit-subst-rules
                           :initform (make-substitution-rule))
     <<Hooks for substitution-rules>>
@ %def merge-rules drop-if-merged-rules merge-rule-topsort implicit-subst-rules explicit-subst-rules

\no The \term{hooks} for these rules are defined in detail in
section~\ref{sec:rule-hooks}.

<<Export-list for indexing rules>>=
          get-merge-rules
          get-drop-if-merged-rules
;          get-merge-rule-topsort   set-merge-rule-topsort
          get-implicit-subst-rules set-implicit-subst-rules
          get-explicit-subst-rules set-explicit-subst-rules
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{letter-group-definition}}

<<Class \class{letter-group-definition}>>=
(defparameter *default-letter-group-definition* "default")

(defclass letter-group-definition ()
    ((name    :initarg :name    :type string)
     (ordnum  :initarg :ordnum  :type number)))

(defun make-letter-group-definition (name)
  (make-instance 'letter-group-definition :name name :ordnum 0))

(defclass letter-group-manager ()
    ((prefixes      :accessor get-prefixes
                    :initform (make-hash-table :test #'equal))
     (letter-groups :accessor get-letter-groups
                    :initform (make-hash-table :test #'equal))
     (sort-relation :accessor get-sort-relation
                    :initform (make-relation))
     (lookup-list   :accessor get-lookup-list  :initform '())))

(defun make-letter-group-manager ()
  (let* ((lgm (make-instance 'letter-group-manager))
         (letter-groups (get-letter-groups lgm))
         (default-group (make-letter-group-definition
                         *default-letter-group-definition*)))
    (setf (gethash *default-letter-group-definition* letter-groups)
          default-group)
    (rel-simple-insert (get-sort-relation lgm) default-group)
    lgm))
@ %def letter-group-manager make-letter-group-definition letter-group-definition make-letter-group-definition

\no The following function sorts a list of strings such that if in
direct comparison, one string is a prefix of the other, the longer one
is \emph{less that} the shorter one. This anomaly is necessary to sort
the string \texttt{foobar} before \texttt{foo}. We need this to find
the longest prefix-match in a list of prefixes. So
\begin{center}
  \texttt{(match "foo" '("bar" "foobar" "foo"))}
\end{center}
yields the correct answer \texttt{foobar} instead of \texttt{foo}.
The function actually sorts a list of conses an does only sort the
[[car]] of them.

<<Class \class{letter-group-definition}>>=
(defun make-lookup-list (lgm)
  (setf (get-lookup-list lgm)
        (let ((lookup-list '()))
          (maphash #'(lambda (key elt)
                       (push (cons key elt) lookup-list))
                   (get-prefixes lgm))
          (sort lookup-list #'prefix<))))

(defun prefix< (x y)
  (let ((cx (car x))
        (cy (car y)))
    (let ((same-prefix (string/= cx cy)))
      (cond ((null same-prefix))
            ((> same-prefix 0)
               (and (= same-prefix (length (car y)))))
            (t (string< cx cy))))))
@ %def make-lookup-list prefix<

\no The following function takes a manager, a letter-group name, a
single string naming a prefix of the letter group and optionally the
[[:before]] or [[:after]]-keyword argument. First we check if the
letter group is already present. If not, we create an new onw with
this name, add a link to it into the letter-groups hashtable.
Additionally we update the relation with the [[re-simple-insert]] with
the new group-name.

Afterwards we check if a present binding is to be altered. Then we
establish a link for the new prefix. Finally we insert the relations
the new letter-group is being part of.

<<Class \class{letter-group-definition}>>=
(defun add-letter-group-to-manager (lgm name prefix &key before after)
  (let* ((prefixes      (get-prefixes      lgm))
         (letter-groups (get-letter-groups lgm))
         (letter-group  (gethash name letter-groups)))
    (unless letter-group;; this letter group is unknown -- create one!
      (setq letter-group (make-letter-group-definition name))
      (setf (gethash name letter-groups) letter-group)
      (rel-simple-insert (get-sort-relation lgm) letter-group))
    (let ((current-binding (gethash prefix prefixes)))
      (and current-binding
           (not (equal name (get-name current-binding)))
           (warn "define-letter-group: prefix ~S now maps to letter group ~S"
                 prefix name)))
    (setf (gethash prefix prefixes) letter-group)
    (when before
      (rel-insert (get-sort-relation lgm)
                  letter-group
                  (lookup-letter-group-definition *indexstyle* before)))
    (when after
      (rel-insert (get-sort-relation lgm)
                  (lookup-letter-group-definition *indexstyle* after)
                  letter-group)))
  lgm)

(defmethod lookup-letter-group-definition ((idxcls indexclass) (letter string))
  (gethash letter (get-letter-groups (get-letter-groups idxcls))))
@ %def add-letter-group-to-manager

\no Finalizing the letter-groups means to sort them topologically
according to the defined relation(s) and assigning to eac of the
groups their [[ordnum]] which is simply the position in the top-sorted
list.

<<Class \class{letter-group-definition}>>=
(defmethod make-ready ((lgm letter-group-manager))
  (make-lookup-list lgm)
  (let ((sort-relation  (get-sort-relation lgm)))
    (multiple-value-bind (topsorted-list remaining-relation)
        (topsort sort-relation)
      (if topsorted-list
          (let ((ctr 0))
            (mapc #'(lambda (grp-def)
                      (setf (get-ordnum grp-def) (incf ctr)))
                  topsorted-list))
          (error
           (concatenate 'string
                        "The user-defined relations for the letter-groups contains cycles!~%The part of the relation containing cycles is"
                        (with-output-to-string (s)
                          (print-relation remaining-relation s
                                          #'(lambda (lgdef)
                                              (get-name lgdef))
                                          :open "~%" :headsep " before "
                                          :listsep " "))))))))
@ %def make-ready

\no The following function takes a keyword and finds the letter-group
this keyword belongs to. We use the [[lookup-list]] to find the
correct group easily and if a match was found we return the ordnum of
its letter-group-definition. If we don't find a match we return the
ordnum of the letter-group-definition [[default]].

<<Class \class{letter-group-definition}>>=
(defmethod match-letter-group ((idxcls indexclass) (letter string))
  (let* ((lgm         (get-letter-groups idxcls))
         (lookup-list (get-lookup-list lgm))
         (match (find-if #'(lambda (prefix-cons)
                             (let* ((prefix (car prefix-cons))
                                    (match-len (string/= prefix letter)))
                               (or (not match-len) #| full match |#
                                   (= match-len    #| full match with lg |#
                                      (length prefix)))))
                         lookup-list))
         (letter-group-definition
          (if match
              (cdr match);; the corresponding letter-grp-def
              (lookup-letter-group-definition
               *indexstyle* *default-letter-group-definition*))))
    (gol t "~&Letter-group: ~S -> ~S"
         letter (get-name letter-group-definition))
    letter-group-definition))
@ %def match-letter-group

<<Export-list of submodule \module{idxclass}>>=
(export '(letter-group-definition match-letter-group))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Mutators for \class{indexclass}}

We now need to define the interface how an indexclass may be modified.
After creation of an indexclass we need appropriate modifiers. The
idea is to define a set of methods that allow setting and appending of
entries to an existing indexclass instance.

We define a generic function [[set]] that allows setting of a special
value of information into indexclass [[default]] and [[add]] to
somehow add some information to an indexclass. We just dispatch over
the types of the second argument and achieve a reasonable simplicity.
If no direct dispatch is possible we use names like [[add-]]\textsl{object}
to express that we add an object of type \textsl{object} into the
indexclass.

<<Mutators for \class{indexclass}>>=
(defmethod add ((idxcls indexclass) (basetype basetype))
  (setf (gethash (get-name basetype) (get-basetypes idxcls))
        basetype)
  idxcls)

(defmethod add-alias ((idxcls indexclass) basetype alias-name)
  (let ((new-basetype (make-copy (lookup-basetype idxcls basetype)
                                 alias-name)))
    (add idxcls new-basetype)))

(defmethod add ((idxcls indexclass) (catattr category-attribute))
  (add (get-cat-attrs idxcls) catattr)
  idxcls)
@ %def add

<<Mutators for \class{indexclass}>>=
(defun add-letter-groups (idxcls name prefixes &key before after)
  (let ((lgm (get-letter-groups idxcls)))
    (mapc #'(lambda (prefix)
              (add-letter-group-to-manager lgm name prefix
                                           :before before
                                           :after  after))
          prefixes)))
@ %def add-letter-groups

\no Adding a new location-reference-class needs special treatment,
since we want matching in the correct order of declaration. If later
on, more than one match succeeds the first one is taken and a warnig
should be issued. If this location-class is already known we remove
first remove it. In all cases we add the new location-class.

<<Mutators for \class{indexclass}>>=
(defmethod add ((idxcls indexclass) (loccls layered-location-class))
  (let* ((loccls-name (get-name loccls))
         (old-loccls (cdr (lookup-locref-class idxcls loccls-name))))
    (when old-loccls
      (remove-location-class idxcls old-loccls))
    (if (get-locref-classes idxcls) #| if it is empty, we can't rplacd |#
        (rplacd (last (get-locref-classes idxcls))
                (acons loccls-name loccls nil))
        (setf (get-locref-classes idxcls)
              (acons loccls-name loccls nil))))
  idxcls)

(defmethod remove-location-class ((idxcls indexclass)
                                  (loccls layered-location-class))
  (setf (get-locref-classes idxcls)
        (delete-if #'(lambda (elt)
                       (eq (cdr elt) loccls))
                   (get-locref-classes idxcls)))
  idxcls)
@ %def add remove-location-class

<<Mutators for \class{indexclass}>>=
(defmethod add ((idxcls indexclass) (xrefcls crossref-location-class))
  (let ((xrefcls-name (get-name xrefcls)))
    (setf (get-xref-classes idxcls)
          (acons xrefcls-name xrefcls (get-xref-classes idxcls)))
    idxcls))
@ %def add

\no Here follow the mutators for the merge-rules. Remember that
\irule{drop-if-merged} implies \irule{merge-to}.

<<Mutators for \class{indexclass}>>=
(defmethod add-merge-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                               (catattr-2 category-attribute))
  (rel-insert (get-merge-rules idxcls) catattr-1 catattr-2)
  idxcls)

(defmethod add-drop-if-merged-rule ((idxcls indexclass)
                                    (catattr-1 category-attribute)
                                    (catattr-2 category-attribute))
  (rel-insert (get-merge-rules idxcls) catattr-1 catattr-2)
  (rel-insert (get-drop-if-merged-rules idxcls) catattr-1 catattr-2)
  idxcls)
@ %def add-merge-rule add-drop-if-merged-rule

\no Here follow the mutators for the substitution-rules.

<<Mutators for \class{indexclass}>>=
(defmethod add-implicit-substitution-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                                               (catattr-2 category-attribute))
  (rel-insert (get-implicit-subst-rules idxcls) catattr-1 catattr-2)
  idxcls)


(defmethod add-explicit-substitution-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                                               (catattr-2 category-attribute))
  (rel-insert (get-explicit-subst-rules idxcls) catattr-1 catattr-2)
  idxcls)
@ %def add set add-merge-rule add-drop-if-merged-rule add-implicit-substitution-rule add-explicit-substitution-rule

\no There exists no special method to add [[keyword-markups]] to the
indexclass. The complete management of markups is done in the
submodule \module{markup} of module \module{index}. From the
indexclass' point of view the structure of its slot [[keyword-markup]]
is unknown and handled in module \module{markup}.

This decision is somewhat cruical because it breaks the rule that an
indexclass manages all of its slots. Since the markup is also used in
submodule \module{locclass} the markup must be stored in one of the
lower-level-modules. Because there is no appropriate
lower-level-module to store this information we handle the complete
markup from the top. Because I don't like the idea to split the markup
of all objects over all modules this central management is easier to
maintain.

<<Export-list of submodule \module{idxclass}>>=
(export '(add set
          add-letter-groups
          add-merge-rule
          add-drop-if-merged-rule
          add-implict-substitution-rule
          add-explicit-substitution-rule))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Finders for \class{indexclass}}

After defining a set of methods that modify an indexclass we need
several functions to retrieve information from the indexclass. These
functions are prefixed with [[lookup-]].
\begin{center}
  They all return [[nil]] if no appropriate object was found.
\end{center}

<<Finders for \class{indexclass}>>=
(defmethod lookup-basetype ((idxcls indexclass) (basetype-name string))
  (gethash basetype-name (get-basetypes idxcls)))

(defmethod lookup-catattr ((idxcls indexclass) (catattr-name string))
  (lookup-catattr-name (slot-value idxcls 'cat-attrs) catattr-name))

(defmethod lookup-location-class ((idxcls indexclass) (loccls-name string))
  (or (lookup-crossref-class idxcls loccls-name)
      (lookup-locref-class idxcls loccls-name)))

(defmethod lookup-crossref-class ((idxcls indexclass) (xref-name string))
  (assoc xref-name (slot-value idxcls 'xref-classes) :test #'equal))

(defmethod lookup-locref-class ((idxcls indexclass) (loccls-name string))
  (assoc loccls-name (slot-value idxcls 'locref-classes) :test #'equal))
@ %def lookup-basetype lookup-catattr lookup-crossref-class lookup-location-class lookup-locref-class

<<Export-list of submodule \module{idxclass}>>=
(export '(lookup-basetype
          lookup-catattr
          lookup-letter-group-definition
          lookup-location-class
          lookup-crossref-class
          lookup-locref-class))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Iterators for \class{indexclass}}

Iterators are used to iterate over the elements of a slot value.  The
following function iterates over all location-classes in the
indexclass and calls the given function [[apply-func]] for all
existing location-classes. Function [[apply-func]] \emph{must} have
the following signature:

\begin{defunc}{apply-func}{\type{indexclass} \res
    \type{location-class} \opt{\emph{arguments}\ldots}} This function
  should return non-[[NIL]] values for all items it whishes to appear
  in the result-list of [[map-location-classes]].
\end{defunc}

\no The non-[[NIL]] results of all calls to [[apply-func]] are
returned in a list.

<<Iterators for \class{indexclass}>>=
(defmacro map-location-classes (idxcls apply-func &rest arguments)
  `(LET ()
    (APPLY #'NCONC
           (MAPCAR
            #'(LAMBDA (ELT)
                (LET ((RES
                       (FUNCALL ,apply-func
                                ,idxcls
                                (CDR ELT) #|ELT is ("name".<LOCATION-CLASS>))|#
                                ,@arguments)))
                  (WHEN RES (LIST RES))))
            (GET-LOCREF-CLASSES ,idxcls)))))
@ %def map-location-classes

<<Export-list of submodule \module{idxclass}>>=
(export 'map-location-classes)
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hooks for indexing rules}
\label{sec:rule-hooks}

\paragraph{Merge-hooks}

When we need to \term{drop} a location-reference because of the
successful application of a \irule{drop-if-merged}-rule and a join
into a range we must specify what happens with the original
location-reference. Strictly spoken, we must define what
\term{dropping} means (\emph{see} submodule \module{idxentry} for
further details). The possible ways are:
\begin{enumerate}
\item \term{remove} the origial location-reference.
\item \term{reset} the original attributes state to \textsf{virtual}.
\item Do nothing. Leave it untouched.
\end{enumerate}
%%
So we define the following hook

<<Hooks for merge-rules>>=
     (merge-drop-hook  :reader get-merge-drop-hook
                       :writer set-merge-drop-hook
                       :initform #'set-state-deleted)
@ %def merge-drop-hook

<<Export-list of submodule \module{idxclass}>>=
(export '(get-merge-drop-hook set-merge-drop-hook))
@

\paragraph{Substitution-hooks}

The indexclass contains the implicit- (defined by the
category-attribute-groups) and explicit-substitution-rules. To
generate a complete subtitution-relation we need some hooks to combine
them to a complete relation. Each hook is a variable that contains a
function that takes a [[relation]] as its only argument and modifies
the relation. The currently possible hook-functions are:
\begin{itemize}
\item [[transitive-hull]] which calculates the transitive hull of the relation.
\item [[identity]] which leaves the relation unchanged.
\end{itemize}
%%
The hooks are as follows:
%%
\begin{itemize}
\item The \textsf{implicit-substitution-hook}. It defaults to
  [[transitive-hull]].
\item The \textsf{explicit-substitution-hook}. It defaults to [[identity]].
\item The \textsf{global-substitution-hook}. It defaults to
  [[identity]].
\end{itemize}
%%
These defaults can be changed The \textsf{implicit-substitution-hook}
is applied to slot \texttt{implicit-subst-rules} of an indexclass. The
\textsf{explicit-substitution-hook} is applied to slot
[[explicit]]-[[subst]]-[[rules]] of an indexclass. The
\textsf{global-substitution-hook} is applied to the result of merging
both the [[implicit]]- and [[explicit]]-[[subst]]-[[rules]] together
and stored into slot [[implicit]]-[[subst]]-[[rules]] which then acts
as the only substitution-rule. Slot [[explicit]]-[[subst]]-[[rules]]
remains unused.

Hook [[substitution-subst-hook]] is applied to a location-reference if
it should be \term{substituted} when applying the substitution-rules
during processing an indexentry. It must be a method that takes a
location-reference as its argument and returns the modified
location-reference or [[nil]] if it should be removed entirely. The
functions to be used are [[set-state-virtual]] which resets its state
to virtual or [[null]] which returns [[nil]] applied to a
location-reference.

<<Hooks for substitution-rules>>=
     (implicit-subst-hook  :reader get-implicit-subst-hook
                           :writer set-implicit-subst-hook
                           :initform #'transitive-hull)
     (explicit-subst-hook  :reader get-explicit-subst-hook
                           :writer set-explicit-subst-hook
                           :initform #'identity)
     (global-subst-hook    :reader get-global-subst-hook
                           :writer set-global-subst-hook
                           :initform #'identity)
     (substitution-subst-hook :reader get-substitution-subst-hook
                              :writer set-substitution-subst-hook
                              :initform #'null)
@ %def implicit-subst-hook explicit-subst-hook global-subst-hook substitution-subst-hook

<<Export-list of submodule \module{idxclass}>>=
(export '(get-implicit-subst-hook     set-implicit-subst-hook
          get-explicit-subst-hook     set-explicit-subst-hook
          get-global-subst-hook       set-global-subst-hook
          get-substitution-subst-hook set-substitution-subst-hook))
@

\no The application of all hooks can be described as follows:

<<Apply substitution-hooks>>=
(defmethod apply-substitution-hooks ((idxcls indexclass))
  (let ((impl (get-implicit-subst-rules idxcls))
        (expl (get-explicit-subst-rules idxcls)))
    (funcall (get-implicit-subst-hook idxcls) impl)
    (funcall (get-explicit-subst-hook idxcls) expl)
    (rel-merge impl expl)
    (set-explicit-subst-rules nil idxcls)
    (funcall (get-global-subst-hook idxcls) impl)
    (make-ready impl)
    <<check for reflexivity>>))
@ %def apply-substitution-hooks

\no The check for reflexivity is currently unimplemented.

<<check for reflexivity>>=
@

\begin{TODO}
\item implement the check for reflexivity. See also
  \irule{drop-if-merged}-rules
\end{TODO}

<<Export-list of submodule \module{idxclass}>>=
(export '(apply-substitution-hooks))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Final cleanup}

Before processing the index we must do several cleanups. We must apply
the substitution-hooks to receive a global substitution-relation.
Additionally we must transform all other relation-rules into their
hash-table representation via calling [[make-ready]]. Also the letter
groups must be sorted for a correct processing (this could also be
delayed until the markup).

<<Indexclass cleanups>>=
(defmethod make-ready ((idxcls indexclass))
  (apply-substitution-hooks idxcls)
  (make-ready (get-merge-rules idxcls))
  (make-ready (get-drop-if-merged-rules idxcls))
  (make-ready (get-letter-groups idxcls))
  <<check for reflexivity>>

;;  (set-merge-rule-topsort (topsort
;;                         (remove-reflexivity
;;                          (transform-relation
;;                           (get-drop-if-merged-rules idxcls)
;;                           #'(lambda (attr)
;;                               (get-ordnum attr)))))
;;                        *indexstyle*)

  ;;(pprint (get-drop-if-merged-rules idxcls))
  ;;(pprint (topsort (get-drop-if-merged-rules idxcls)))

  (let ((counter 0))
    (mapc #'(lambda (catattr)
              (set-processing-ordnum (incf counter) catattr))
          (reverse (topsort (get-drop-if-merged-rules idxcls)))))

  idxcls)
@ %def make-ready

<<Export-list of submodule \module{idxclass}>>=
(export '(make-ready))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{idxclass}>>=
;; $Id$
;;

<<Global definitions of \module{idxclass}>>
<<Class \class{indexclass}>>
<<Class \class{letter-group-definition}>>
<<Location-reference-cache>>
<<Mutators for \class{indexclass}>>
<<Finders for \class{indexclass}>>
<<Iterators for \class{indexclass}>>

<<Apply substitution-hooks>>
<<Indexclass cleanups>>

<<Export-list of submodule \module{idxclass}>>
@

<<RCS-Identifier>>=
("idxclass" . "$Id$")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
#+:XP
(defmacro pprint-slot-block (slot-name body)
  `(progn
    (pprint-logical-block (s nil :suffix " }")
                          (pprint-indent :block 2 s)
                          (write-string ,slot-name s)
                          (pprint-newline :mandatory s)
                          ,body)
    (pprint-newline :mandatory s)))

#+:XP
(defmacro pprint-slot-block-line (slot-name body)
  `(progn
    (pprint-logical-block (s nil :suffix " }")
                          (pprint-indent :block 2 s)
                          (write-string ,slot-name s)
                          (pprint-newline :linear s)
                          ,body)
    (pprint-newline :mandatory s)))
@

<<Pretty-printing>>=
#+:XP
(set-pprint-dispatch 'indexclass
                     #'(lambda (s idxcls)
                         (pprint-logical-block
                          (s nil :suffix "}")
                          (pprint-indent :block 2 s)
                          (write-string "indexclass " s)
                          (write (get-name idxcls) :stream s)
                          (write-string " {" s)
                          (pprint-newline :mandatory s)
                          (pprint-slot-block
                           "basetypes {"
                           (maphash #'(lambda (key bt)
                                        (declare (ignore key))
                                        (write (get-name bt) :stream s)
                                        (write-string " " s)
                                        (pprint-newline :linear s))
                                    (get-basetypes idxcls)))
                          (pprint-slot-block
                           "cat-attrs {"
                           (write (get-cat-attrs idxcls) :stream s))
                          (pprint-slot-block
                           "locclasses {"
                           (mapc #'(lambda (lc)
                                     (write (get-name (cdr lc)) :stream s)
                                     (write-string " [" s)
                                     (write (get-ordnum (cdr lc)) :stream s)
                                     (write-string "] " s)
                                     (pprint-newline :linear s))
                                 (get-locref-classes idxcls)))
                          (pprint-slot-block
                           "xrefclasses {"
                           (mapc #'(lambda (lc)
                                     (write (get-name (cdr lc)) :stream s)
                                     (write-string " [" s)
                                     (write (get-ordnum (cdr lc)) :stream s)
                                     (write-string "] " s)
                                     (pprint-newline :linear s))
                                 (get-xref-classes idxcls)))

                          (write (get-letter-dict idxcls) :stream s)
                          (pprint-newline :mandatory s)
                          (write (get-partial-order-dict idxcls) :stream s)
                          (pprint-newline :mandatory s)

                          (pprint-slot-block
                           "merge-rules {"
                           (write (get-merge-rules idxcls) :stream s))
                          (pprint-slot-block
                           "drop-if-merged-rules {"
                           (write (get-drop-if-merged-rules idxcls) :stream s))
                          ;; (pprint-slot-block-line
                          ;; "merge-rule-topsort { "
                          ;; (write (get-merge-rule-topsort idxcls) :stream s))
                          (pprint-slot-block
                           "implicit-subst-rules {"
                           (write (get-implicit-subst-rules idxcls) :stream s))
                          (pprint-slot-block
                           "explicit-subst-rules {"
                           (write (get-explicit-subst-rules idxcls) :stream s))

                          (pprint-slot-block-line
                           "implicit-subst-hook {"
                           (write (get-implicit-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "explicit-subst-hook {"
                           (write (get-explicit-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "global-subst-hook {"
                           (write (get-global-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "substitution-subst-hook {"
                           (write (get-substitution-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "merge-drop-hook {"
                           (write (get-merge-drop-hook idxcls) :stream s))

                                        ;                          (pprint-slot-block
                                        ;                           "keyword-markup {"
                                        ;                           (write (get-keyword-markup idxcls) :stream s))
                          )))
@

%% $Log$
%% Revision 1.19  1997/03/18 14:49:46  kehr
%% Checkin after the several changes. a) the definition of slot-accessor
%% macros in the whole source, b) the modifications suggested by Bernd
%% Raichle to make the source compatible with Allegro CL and c) a first
%% version of the new sorting scheme.
%%
%% Revision 1.18  1997/03/10 15:50:46  kehr
%% Corrected a bug in the macro (merge-to).
%%
%% Revision 1.17  1997/01/23 21:33:09  kehr
%% Reincorporated (merge-to) rule into indexstyle.
%%
%% Revision 1.16  1997/01/17 16:42:05  kehr
%% Several changes for new version 1.1.
%%
%% Revision 1.15  1996/07/16  14:05:48  kehr
%% Checkin after all the changes to the `define-letter-group(s)' commands
%% have been made.
%%
%% Revision 1.14  1996/07/03  18:41:40  kehr
%% Checkin after some modifications of the error-system and the loading of
%% indexstyle-modules have been made. Affects all modules.
%%
%% Revision 1.13  1996/05/29  14:15:24  kehr
%% Complete checkin after the major changes in the markup. See ChangeLog
%% for details.
%%
%% Revision 1.12  1996/05/20  08:47:49  kehr
%% Major release of the modules locref, idxstyle and index.
%%
%% Revision 1.11  1996/04/30  15:52:48  kehr
%% Minor changes.
%%
%% Revision 1.10  1996/04/30  09:26:36  kehr
%% Changes the adding of location-classes to an index. Old definitions
%% will now be removed if a new location-class with the same name is
%% added. The forall-location-classes iterator was rewritten. It is now
%% named map-location-class and its behaviour is now comparable to a
%% map-function with implicit removal of nil in the result-list.
%%
%% Revision 1.9  1996/03/13  16:50:41  kehr
%% Ok, here I am. Included support for regular expressions. Minor changes
%% in all other parts of this module. Made some tests but had some
%% problems with LISP stack overflow errors. Don't know where they came
%% from. We'll see. The next step is to implement the string replacement
%% mechanism and set up extensive tests. Maybe I can use the tests from
%% Henry Spencer's regexp library.
%%
%% Revision 1.8  1996/01/31  15:29:20  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.7  1996/01/10  16:46:39  kehr
%% Made some modifications for the keyword-markup-slot.
%%
%% Revision 1.6  1996/01/10  15:24:06  kehr
%% Changed som parts of `idxclass' for handling markup.
%% Minor changes in the Imakefile.
%%
%% Revision 1.5  1996/01/09  14:26:09  kehr
%% Major modifications.
%%
%% Revision 1.4  1995/12/19  10:58:46  kehr
%% Complete restructuring.
%%
%% Revision 1.3  1995/12/15  17:08:24  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.2  1995/12/07  18:14:22  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from scratch.
%%
%% Revision 1.1  1995/12/05  18:46:11  kehr
%% Added module `idxclass' and restructured some parts.
%%
%% Revision 1.9  1995/07/23  20:48:32  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.8  1995/07/23  14:14:08  kehr
%% Added support for merge-to--rule. Now works and creates
%% virtual-attributes as expected.
%%
%% Revision 1.7  1995/07/15  20:50:22  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.6  1995/07/11  23:33:07  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.5  1995/07/11  15:14:15  kehr
%% Today I finished the definition of indexentries. They now will be
%% inserted into the index when a appropriate location-class was finished.
%%
%% Revision 1.4  1995/07/11  00:47:43  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%
%% Revision 1.3  1995/07/10  19:08:16  kehr
%% Now corrected setup of location-classes. The was a bug in the
%% add-indexclass methods and some wrong reader-functions.
%%
%% Revision 1.2  1995/07/10  00:58:16  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
%% Revision 1.1  1995/07/09  18:14:27  kehr
%% Initial checkin.
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:

