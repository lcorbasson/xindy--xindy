%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Submodule: indexclass
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{indexclass}}

\subsection{Introduction}

Indexclasses serve as containers for indexstyle-information. They
hold information about configured basetypes, location-classes, rules,
and the successor-tables. Their main task is to add objects to the
indexclass and allow queries about objects stored in an indexclass.


\subsection{Abstract Specification}

\subsubsection{Definition}

An indexclass is a set
\begin{center}
  $\{$ \emph{name, basetypes, locclasses, rules, succ-table,
    not-succ-table, keyword-markup} $\}$
\end{center}
with
\begin{deflistit}{not-succ-table}
\item [name] is a \tstring containing the name of the indexclass.
\item [basetypes] is a list of \type{basetype}.
\item [locclasses] is a list of \type{locclass}.
\item [rules] is a list of \type{rule}.
\item [succ-table]
\item [not-succ-table]
\item [markup] Markup for the keywords.
\item [keyword-groups] Describe domains and markup of keyword-groups.
\end{deflistit}


\subsubsection{Operation}


\subsection{Concrete Specification}

\subsubsection{External interface}

The following symbols are exported:

\begin{defcls}{indexclass}{}
  Decribes indexclasses.
\end{defcls}

\begin{defunc}{make-indexclass}{\tstring \x \res \type{indexclass}}
  The constructor of an \type{indexclass}.
\end{defunc}

\begin{defgen}{add}{\type{indexclass} \x object}
  This generic function describes a set of methods that allow storing
  of objects into the indexclass given by \type{indexclass}. The name
  [[add]] suggests that we can call this methods several time to add
  more and more objects. These objects are added to some kind of a
  pool inside the indexclass. The behaviour inside this pool depends
  on the semantics defined by the pool itself.
\end{defgen}

\begin{defgen}{set}{\type{indexclass} \x object}
  This generic function describes a set of methods that allow storing
  of objects into the indexclass named by \type{indexclass}. The name
  [[set]] suggests that everytime we can call this method the old
  object is discarded and replaced by the new one, since there exists
  only one single object that can be set.
\end{defgen}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{indexclass}}

The following class is a straightforward implementation of the
abstract specification. When specifying new location-classes we need a
fast lookup for bastypes via their names. Therefore we store in slot
[[basetypes]] a hash-table that allows easy lookup by name. It
specifies all already defined basetypes. New basetypes are added to
the hash-table, when reading the indexstyle.

Slot [[locclasses]] is a association list whose key is the
location-class name and its datum is the location-class itself. Slots
[[merge-rules]] and [[subst-rules]] are objects of type
\type{relation-rule} which are actually based on a relation
(\look{sec:relations}). After instantiation the indexclass will be
incrementally filled with more information.

<<Class \class{indexclass}>>=
(defclass indexclass ()
    ((name              :reader   get-name              :initarg :name)
     (basetypes         :accessor get-basetypes
                        :initform (make-hash-table :test #'equal))
     (cat-attrs         :accessor get-cat-attrs
                        :initform (make-catattr-groups))
     (locclasses        :accessor get-locclasses        :initform '())
     (succ-table        :accessor get-succ-table
                        :initform (make-hash-table))
     (keyword-markup    :accessor get-keyword-markup    :initform '())
     (merge-rules       :accessor get-merge-rules
                        :initform (make-merge-rule))
     (subst-rules       :accessor get-subst-rules
                        :initform (make-substitution-rule))
     ))

(defun make-indexclass (name)
  (make-instance 'indexclass :name name))
@ %def indexclass make-indexclass

<<Export-list of submodule \module{idxclass}>>=
(export '(indexclass make-indexclass
          get-name        get-basetypes
          get-cat-attrs   get-locclasses
          get-succ-table  get-keyword-markup
          get-merge-rules get-cat-attrs
          get-subst-rules
          ))
@ %def indexclass make-indexclass


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Mutators for \class{indexclass}}

We now need to define the interface how an indexclass may be modified.
After creation of an indexclass we need appropriate modifiers. The
idea is to define a set of methods that allow setting and appending of
entries to an existing indexclass instance.

We define a generic function [[set]] that allows setting of a special
value of information into indexclass [[default]] and [[add]] to
somehow add some information to an indexclass. We just dispatch over
the types of the second argument and achieve a reasonable simplicity.
If no direct dispatch is possible we use names like [[add-]]\textsl{object}
to express that we add an object of type \textsl{object} into the
indexclass.

<<Mutators for \class{indexclass}>>=
(defmethod add ((idxcls indexclass) (basetype basetype))
  (setf (gethash (get-name basetype) (get-basetypes idxcls))
        basetype)
  idxcls)

(defmethod add ((idxcls indexclass) (loccls location-class))
  (setf (get-locclasses idxcls)
        (acons (get-name loccls) loccls (get-locclasses idxcls)))
  idxcls)

(defmethod add-merge-rule ((idxcls indexclass)
                           (catattr-1 category-attribute)
                           (catattr-2 category-attribute))
  (rel-insert (get-merge-rules idxcls) catattr-1 catattr-2)
  idxcls)

(defmethod add-substitution-rule ((idxcls indexclass)
                                  (catattr-1 category-attribute)
                                  (catattr-2 category-attribute))
  (rel-insert (get-subst-rules idxcls) catattr-1 catattr-2)
  idxcls)

;(defmethod add ((idxcls-name string)
;                           (keyword-markup markup))
;  (let ((idxcls (lookup-indexclass idxcls-name)))
;    (unless (null idxcls)
;      (setf (get-keyword-markup idxcls)
;            (append (get-keyword-markup idxcls) (list keyword-markup))))))

;(defmethod add ((idxcls-name string)
;                           (merge-to-rule rule-merge-to))
;  (let ((idxcls (lookup-indexclass idxcls-name)))
;    (unless (null idxcls)
;      (setf (get-merge-to-rules idxcls)
;            (append (get-merge-to-rules idxcls) (list merge-to-rule))))))

;(defmethod set ((idxcls-name string)
;                           (sep-mix-rule rule-separated-mixed))
;  (let ((idxcls (lookup-indexclass idxcls-name)))
;    (unless (null idxcls)
;      (setf (get-sep-mix-rule idxcls) sep-mix-rule))))
@ %def add set

<<Export-list of submodule \module{idxclass}>>=
(export '(add set
          add-merge-rule
          add-substitution-rule))
@ %def add set add-merge-rule add-substitution-rule

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Finders for \class{indexclass}}

After defining a set of methods that modify an indexclass we need
several functions to retrieve information from the indexclass. These
functions are prefixed with [[lookup-]].
\begin{center}
  They all return [[nil]] if no appropriate object was found.
\end{center}

<<Finders for \class{indexclass}>>=
(defmethod lookup-basetype ((idxcls indexclass) (basetype-name string))
  (gethash basetype-name (get-basetypes idxcls)))

(defmethod lookup-catattr ((idxcls indexclass) (catattr-name string))
  (lookup-catattr (get-cat-attrs idxcls) catattr-name))

(defmethod lookup-location-class ((idxcls indexclass) (loccls-name string))
  (assoc loccls-name (get-locclasses idxcls) :test #'equal))
@ %def lookup-basetype lookup-catattr lookup-location-class

<<Export-list of submodule \module{idxclass}>>=
(export '(lookup-basetype
          lookup-catattr
          lookup-location-class))
@ %def lookup-basetype lookup-catattr lookup-location-class

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Iterators for \class{indexclass}}

Iterators are used to iterate over the elements of a slot value.  The
following function iterates over all location-classes in the
indexclass and calls the given function [[apply-func]] for all
existing location-classes. Function [[apply-func]] takes three
arguments: the current indexclass, the current location-class and the
[[&rest]] arguments given to [[forall-location-classes]].

<<Iterators for \class{indexclass}>>=
(defun forall-location-classes (apply-func
                                &rest arguments)
  (let ((idxcls *indexstyle*))
    (maphash #'(lambda (key loccls)
                 (declare (ignore key))
                 (funcall apply-func idxcls loccls arguments))
             (get-locclasses idxcls))))
@ %def forall-location-classes

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{idxclass}>>=
;; $Id$
;;

<<Class \class{indexclass}>>
<<Mutators for \class{indexclass}>>
<<Finders for \class{indexclass}>>
<<Iterators for \class{indexclass}>>
<<Export-list of submodule \module{idxclass}>>
@

<<RCS-Identifier>>=
("idxclass" . "$Id$")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
(set-pprint-dispatch 'indexclass
                     #'(lambda (s idxcls)
                         (pprint-logical-block
                          (s nil :suffix "}")
                          (pprint-indent :block 2 s)
                          (write-string "Indexclass " s)
                          (write (get-name idxcls) :stream s)
                          (write-string " {" s)
                          (pprint-newline :mandatory s)
                          (pprint-logical-block
                           (s nil :prefix "Basetypes   { " :suffix "}")
                           (pprint-indent :block 2)
                           (maphash #'(lambda (key bt)
                                        (declare (ignore key))
                                        (pprint-newline :linear s)
                                        (write (get-name bt) :stream s)
                                        (write-string " " s))
                                    (get-basetypes idxcls)))
                          (pprint-newline :mandatory s)
                          (pprint-logical-block
                           (s nil :prefix "Loc-Classes { " :suffix "}")
                           (pprint-indent :block 2)
                           (mapc #'(lambda (lc)
                                     (pprint-newline :linear s)
                                     (write (get-name (cdr lc)) :stream s)
                                            (write-string " " s))
                                 (get-locclasses idxcls)))
                          (pprint-newline :mandatory s)
                         )))
@

%% Local Variables:
%% mode: latex
%% End:
%%
%% $Log$
%% Revision 1.4  1995/12/19 10:58:46  kehr
%% Complete restructuring.
%%
%% Revision 1.3  1995/12/15  17:08:24  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.2  1995/12/07  18:14:22  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from scratch.
%%
%% Revision 1.1  1995/12/05  18:46:11  kehr
%% Added module `idxclass' and restructured some parts.
%%
%% Revision 1.9  1995/07/23  20:48:32  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.8  1995/07/23  14:14:08  kehr
%% Added support for merge-to--rule. Now works and creates
%% virtual-attributes as expected.
%%
%% Revision 1.7  1995/07/15  20:50:22  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.6  1995/07/11  23:33:07  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.5  1995/07/11  15:14:15  kehr
%% Today I finished the definition of indexentries. They now will be
%% inserted into the index when a appropriate location-class was finished.
%%
%% Revision 1.4  1995/07/11  00:47:43  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%
%% Revision 1.3  1995/07/10  19:08:16  kehr
%% Now corrected setup of location-classes. The was a bug in the
%% add-indexclass methods and some wrong reader-functions.
%%
%% Revision 1.2  1995/07/10  00:58:16  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
%% Revision 1.1  1995/07/09  18:14:27  kehr
%% Initial checkin.
%%
