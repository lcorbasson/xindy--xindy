%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Submodule: indexclass
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{indexclass}}

\subsection{Introduction}

Indexclasses serve as containers for indexstyle-information. They
hold information about configured basetypes, location-classes, rules,
and the successor-tables. Their main task is to add objects to the
indexclass and allow queries about objects stored in an indexclass.


\subsection{Abstract Specification}

\subsubsection{Definition}

An indexclass is a set
\begin{center}
  $\{$ \emph{name, basetypes, locclasses, rules, succ-table,
    not-succ-table, keyword-markup} $\}$
\end{center}
with
\begin{deflistit}{not-succ-table}
\item [name] is a \tstring containing the name of the indexclass.
\item [basetypes] is a list of \type{basetype}.
\item [locclasses] is a list of \type{locclass}.
\item [succ-table]
\item [not-succ-table]
\item [markup] Markup for the keywords.
\item [keyword-groups] Describe domains and markup of keyword-groups.
\end{deflistit}


\subsubsection{Operation}


\subsection{Concrete Specification}

\subsubsection{External interface}

The following symbols are exported:

\begin{defcls}{indexclass}{}
  Decribes indexclasses.
\end{defcls}

\begin{defunc}{make-indexclass}{\tstring \x \res \type{indexclass}}
  The constructor of an \type{indexclass}.
\end{defunc}

\begin{defgen}{add}{\type{indexclass} \x object}
  This generic function describes a set of methods that allow storing
  of objects into the indexclass given by \type{indexclass}. The name
  [[add]] suggests that we can call this methods several time to add
  more and more objects. These objects are added to some kind of a
  pool inside the indexclass. The behaviour inside this pool depends
  on the semantics defined by the pool itself.
\end{defgen}

\begin{defgen}{set}{\type{indexclass} \x object}
  This generic function describes a set of methods that allow storing
  of objects into the indexclass named by \type{indexclass}. The name
  [[set]] suggests that everytime we can call this method the old
  object is discarded and replaced by the new one, since there exists
  only one single object that can be set.
\end{defgen}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{indexclass}}

The following class is a straightforward implementation of the
abstract specification. When specifying new location-classes we need a
fast lookup for bastypes via their names. Therefore we store in slot
[[basetypes]] a hash-table that allows easy lookup by name. It
specifies all already defined basetypes. New basetypes are added to
the hash-table, when reading the indexstyle.

Slot [[locclasses]] is a association list whose key is the
location-class name and its datum is the location-class itself. Slots
[[merge-rules]] and [[subst-rules]] are objects of type
\type{relation-rule} which are actually based on a relation
(\look{sec:relations}). After instantiation the indexclass will be
incrementally filled with more information.

<<Class \class{indexclass}>>=
(defclass indexclass ()
    ((name                 :reader   get-name
                           :initarg :name)
     (basetypes            :accessor get-basetypes
                           :initform (make-hash-table :test #'equal))
     (cat-attrs            :accessor get-cat-attrs
                           :initform (make-catattr-groups))
     (locclasses           :accessor get-locclasses
                           :initform '())
     (succ-table           :accessor get-succ-table
                           :initform (make-hash-table))
     (keyword-markup       :accessor get-keyword-markup
                           :initform '())
     <<Rules for indexing>>
     ))

(defun make-indexclass (name)
  (make-instance 'indexclass :name name))
@ %def indexclass make-indexclass

<<Export-list of submodule \module{idxclass}>>=
(export '(indexclass      make-indexclass
          get-name        get-basetypes
          get-cat-attrs   get-locclasses
          get-succ-table  get-keyword-markup
          <<Export-list for indexing rules>>
          ))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Indexing rules}

The indexing process is highly driven by several rules the user can
specify accoring to his wishes. These rules are part of the indexstyle
and defined by the following slot descriptions.

<<Rules for indexing>>=
     (merge-rules          :reader get-merge-rules
                           :initform (make-merge-rule))
     (drop-if-merged-rules :reader get-drop-if-merged-rules
                           :initform (make-drop-if-merged-rule))
;     (merge-rule-topsort   :reader get-merge-rule-topsort
;                           :writer set-merge-rule-topsort
;                           :initform '())
     <<Hooks for merge-rules>>

     (implicit-subst-rules :reader get-implicit-subst-rules
                           :initform (make-substitution-rule))
     (explicit-subst-rules :reader get-explicit-subst-rules
                           :writer set-explicit-subst-rules
                           :initform (make-substitution-rule))
     <<Hooks for substitution-rules>>
@ %def merge-rules drop-if-merged-rules merge-rule-topsort implicit-subst-rules explicit-subst-rules

\no The \term{hooks} for these rules are defined in detail in
section~\ref{sec:rule-hooks}.

<<Export-list for indexing rules>>=
          get-merge-rules
          get-drop-if-merged-rules
;          get-merge-rule-topsort   set-merge-rule-topsort
          get-implicit-subst-rules set-implicit-subst-rules
          get-explicit-subst-rules set-explicit-subst-rules
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Mutators for \class{indexclass}}

We now need to define the interface how an indexclass may be modified.
After creation of an indexclass we need appropriate modifiers. The
idea is to define a set of methods that allow setting and appending of
entries to an existing indexclass instance.

We define a generic function [[set]] that allows setting of a special
value of information into indexclass [[default]] and [[add]] to
somehow add some information to an indexclass. We just dispatch over
the types of the second argument and achieve a reasonable simplicity.
If no direct dispatch is possible we use names like [[add-]]\textsl{object}
to express that we add an object of type \textsl{object} into the
indexclass.

<<Mutators for \class{indexclass}>>=
(defmethod add ((idxcls indexclass) (basetype basetype))
  (setf (gethash (get-name basetype) (get-basetypes idxcls))
        basetype)
  idxcls)

(defmethod add ((idxcls indexclass) (catattr category-attribute))
  (add (get-cat-attrs idxcls) catattr)
  idxcls)

(defmethod add ((idxcls indexclass) (loccls location-class))
  (setf (get-locclasses idxcls)
        (acons (get-name loccls) loccls (get-locclasses idxcls)))
  idxcls)
@ %def add

\no Here follow the mutators for the merge-rules. Remember that
\irule{drop-if-merged} implies \irule{merge-to}.

<<Mutators for \class{indexclass}>>=
(defmethod add-merge-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                               (catattr-2 category-attribute))
  (rel-insert (get-merge-rules idxcls) catattr-1 catattr-2)
  idxcls)

(defmethod add-drop-if-merged-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                                        (catattr-2 category-attribute))
  (rel-insert (get-merge-rules idxcls) catattr-1 catattr-2)
  (rel-insert (get-drop-if-merged-rules idxcls) catattr-1 catattr-2)
  idxcls)
@ %def add-merge-rule add-drop-if-merged-rule

\no Here follow the mutators for the substitution-rules.

<<Mutators for \class{indexclass}>>=
(defmethod add-implicit-substitution-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                                               (catattr-2 category-attribute))
  (rel-insert (get-implicit-subst-rules idxcls) catattr-1 catattr-2)
  idxcls)


(defmethod add-explicit-substitution-rule ((idxcls indexclass) (catattr-1 category-attribute)
                                                               (catattr-2 category-attribute))
  (rel-insert (get-explicit-subst-rules idxcls) catattr-1 catattr-2)
  idxcls)

;(defmethod add ((idxcls-name string) (keyword-markup markup))
;  (let ((idxcls (lookup-indexclass idxcls-name)))
;    (unless (null idxcls)
;      (setf (get-keyword-markup idxcls)
;            (append (get-keyword-markup idxcls) (list keyword-markup))))))

@ %def add set add-merge-rule add-drop-if-merged-rule add-implicit-substitution-rule add-explicit-substitution-rule

<<Export-list of submodule \module{idxclass}>>=
(export '(add set
          add-merge-rule
          add-drop-if-merged-rule
          add-implict-substitution-rule
          add-explicit-substitution-rule))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Finders for \class{indexclass}}

After defining a set of methods that modify an indexclass we need
several functions to retrieve information from the indexclass. These
functions are prefixed with [[lookup-]].
\begin{center}
  They all return [[nil]] if no appropriate object was found.
\end{center}

<<Finders for \class{indexclass}>>=
(defmethod lookup-basetype ((idxcls indexclass) (basetype-name string))
  (gethash basetype-name (get-basetypes idxcls)))

(defmethod lookup-catattr ((idxcls indexclass) (catattr-name string))
  (lookup (get-cat-attrs idxcls) catattr-name))

(defmethod lookup-location-class ((idxcls indexclass) (loccls-name string))
  (assoc loccls-name (get-locclasses idxcls) :test #'equal))
@ %def lookup-basetype lookup-catattr lookup-location-class

<<Export-list of submodule \module{idxclass}>>=
(export '(lookup-basetype
          lookup-catattr
          lookup-location-class))
@ %def lookup-basetype lookup-catattr lookup-location-class

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Iterators for \class{indexclass}}

Iterators are used to iterate over the elements of a slot value.  The
following function iterates over all location-classes in the
indexclass and calls the given function [[apply-func]] for all
existing location-classes. Function [[apply-func]] takes three
arguments: the current indexclass, the current location-class and the
[[&rest]] arguments given to [[forall-location-classes]].

<<Iterators for \class{indexclass}>>=
(defun forall-location-classes (apply-func
                                &rest arguments)
  (let ((idxcls *indexstyle*))
    (maphash #'(lambda (key loccls)
                 (declare (ignore key))
                 (funcall apply-func idxcls loccls arguments))
             (get-locclasses idxcls))))
@ %def forall-location-classes

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hooks for indexing rules}
\label{sec:rule-hooks}

\paragraph{Merge-hooks}

When we need to \term{drop} a location-reference because of the
successful application of a \irule{drop-if-merged}-rule and a join
into a range we must specify what happens with the original
location-reference. Strictly spoken, we must define what
\term{dropping} means (\emph{see} submodule \module{idxentry} for
further details). The possible ways are:
\begin{enumerate}
\item \term{remove} the origial location-reference.
\item \term{reset} the original attributes state to \textsf{virtual}.
\item Do nothing. Leave it untouched.
\end{enumerate}
%%
So we define the following hook

<<Hooks for merge-rules>>=
     (merge-drop-hook  :reader get-merge-drop-hook
                       :writer set-merge-drop-hook
                       :initform #'set-state-deleted)
@ %def merge-drop-hook

<<Export-list of submodule \module{idxclass}>>=
(export '(get-merge-drop-hook set-merge-drop-hook))
@

\paragraph{Substitution-hooks}

The indexclass contains the implicit- (defined by the
category-attribute-groups) and explicit-substitution-rules. To
generate a complete subtitution-relation we need some hooks to combine
them to a complete relation. Each hook is a variable that contains a
function that takes a [[relation]] as its only argument and modifies
the relation. The currently possible hook-functions are:
\begin{itemize}
\item [[transitive-hull]] which calculates the transitive hull of the relation.
\item [[identity]] which leaves the relation unchanged.
\end{itemize}
%%
The hooks are as follows:
%%
\begin{itemize}
\item The \textsf{implicit-substitution-hook}. It defaults to
  [[transitive-hull]].
\item The \textsf{explicit-substitution-hook}. It defaults to [[identity]].
\item The \textsf{global-substitution-hook}. It defaults to
  [[identity]].
\end{itemize}
%%
These defaults can be changed The \textsf{implicit-substitution-hook}
is applied to slot \texttt{implicit-subst-rules} of an indexclass. The
\textsf{explicit-substitution-hook} is applied to slot
[[explicit]]-[[subst]]-[[rules]] of an indexclass. The
\textsf{global-substitution-hook} is applied to the result of merging
both the [[implicit]]- and [[explicit]]-[[subst]]-[[rules]] together
and stored into slot [[implicit]]-[[subst]]-[[rules]] which then acts
as the only substitution-rule. Slot [[explicit]]-[[subst]]-[[rules]]
remains unused.

Hook [[substitution-subst-hook]] is applied to a location-reference if
it should be \term{substituted} when applying the substitution-rules
during processing an indexentry. It must be a method that takes a
location-reference as its argument and returns the modified
location-reference or [[nil]] if it should be removed entirely. The
functions to be used are [[set-state-virtual]] which resets its state
to virtual or [[null]] which returns [[nil]] applied to a
location-reference.

<<Hooks for substitution-rules>>=
     (implicit-subst-hook  :reader get-implicit-subst-hook
                           :writer set-implicit-subst-hook
                           :initform #'transitive-hull)
     (explicit-subst-hook  :reader get-explicit-subst-hook
                           :writer set-explicit-subst-hook
                           :initform #'identity)
     (global-subst-hook    :reader get-global-subst-hook
                           :writer set-global-subst-hook
                           :initform #'identity)
     (substitution-subst-hook :reader get-substitution-subst-hook
                              :writer set-substitution-subst-hook
                              :initform #'null)
@ %def implicit-subst-hook explicit-subst-hook global-subst-hook substitution-subst-hook

<<Export-list of submodule \module{idxclass}>>=
(export '(get-implicit-subst-hook     set-implicit-subst-hook
          get-explicit-subst-hook     set-explicit-subst-hook
          get-global-subst-hook       set-global-subst-hook
          get-substitution-subst-hook set-substitution-subst-hook))
@

\no The application of all hooks can be described as follows:

<<Apply substitution-hooks>>=
(defmethod apply-substitution-hooks ((idxcls indexclass))
  (let ((impl (get-implicit-subst-rules idxcls))
        (expl (get-explicit-subst-rules idxcls)))
    (funcall (get-implicit-subst-hook idxcls) impl)
    (funcall (get-explicit-subst-hook idxcls) expl)
    (rel-merge impl expl)
    (set-explicit-subst-rules nil idxcls)
    (funcall (get-global-subst-hook idxcls) impl)
    (make-ready impl)
    <<check for reflexivity>>))
@ %def apply-substitution-hooks

\no The check for reflexivity is currently unimplemented.

<<check for reflexivity>>=
@

\begin{TODO}
\item implement the check for reflexivity. See also
  \irule{drop-if-merged}-rules
\end{TODO}

<<Export-list of submodule \module{idxclass}>>=
(export '(apply-substitution-hooks))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Final cleanup}

Before processing the index we must do several cleanups. We must apply
the substitution-hooks to receive a global substitution-relation.
Additionally we must transform all other relation-rules into their
hash-table representation via calling [[make-ready]].

<<Indexclass cleanups>>=
(defmethod make-ready ((idxcls indexclass))
  (apply-substitution-hooks idxcls)
  (make-ready (get-merge-rules idxcls))
  (make-ready (get-drop-if-merged-rules idxcls))
  <<check for reflexivity>>
;  (set-merge-rule-topsort (topsort
;                           (remove-reflexivity
;                            (transform-relation
;                             (get-drop-if-merged-rules idxcls)
;                             #'get-ordnum)))
;                          idxcls)
  (let ((counter 0))
    (mapc #'(lambda (catattr)
              (set-processing-ordnum (incf counter) catattr))
          (topsort (get-drop-if-merged-rules idxcls))))
  idxcls)
@ %def make-ready

<<Export-list of submodule \module{idxclass}>>=
(export '(make-ready))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{idxclass}>>=
;; $Id$
;;

<<Class \class{indexclass}>>
<<Mutators for \class{indexclass}>>
<<Finders for \class{indexclass}>>
<<Iterators for \class{indexclass}>>

<<Apply substitution-hooks>>
<<Indexclass cleanups>>

<<Export-list of submodule \module{idxclass}>>
@

<<RCS-Identifier>>=
("idxclass" . "$Id$")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
(defmacro pprint-slot-block (slot-name body)
  `(progn
    (pprint-logical-block (s nil :suffix " }")
                          (pprint-indent :block 2 s)
                          (write-string ,slot-name s)
                          (pprint-newline :mandatory s)
                          ,body)
    (pprint-newline :mandatory s)))

(defmacro pprint-slot-block-line (slot-name body)
  `(progn
    (pprint-logical-block (s nil :suffix " }")
                          (pprint-indent :block 2 s)
                          (write-string ,slot-name s)
                          (pprint-newline :linear s)
                          ,body)
    (pprint-newline :mandatory s)))
@

<<Pretty-printing>>=
(set-pprint-dispatch 'indexclass
                     #'(lambda (s idxcls)
                         (pprint-logical-block
                          (s nil :suffix "}")
                          (pprint-indent :block 2 s)
                          (write-string "indexclass " s)
                          (write (get-name idxcls) :stream s)
                          (write-string " {" s)
                          (pprint-newline :mandatory s)
                          (pprint-slot-block
                           "basetypes {"
                           (maphash #'(lambda (key bt)
                                        (declare (ignore key))
                                        (write (get-name bt) :stream s)
                                        (write-string " " s)
                                        (pprint-newline :linear s))
                                    (get-basetypes idxcls)))
                          (pprint-slot-block
                           "cat-attrs {"
                           (write (get-cat-attrs idxcls) :stream s))
                          (pprint-slot-block
                           "locclasses {"
                           (mapc #'(lambda (lc)
                                     (write (get-name (cdr lc)) :stream s)
                                     (write-string " " s)
                                     (pprint-newline :linear s))
                                 (get-locclasses idxcls)))

                          (pprint-slot-block
                           "merge-rules {"
                           (write (get-merge-rules idxcls) :stream s))
                          (pprint-slot-block
                           "drop-if-merged-rules {"
                           (write (get-drop-if-merged-rules idxcls) :stream s))
;                          (pprint-slot-block-line
;                           "merge-rule-topsort { "
;                           (write (get-merge-rule-topsort idxcls) :stream s))

                          (pprint-slot-block
                           "implicit-subst-rules {"
                           (write (get-implicit-subst-rules idxcls) :stream s))
                          (pprint-slot-block
                           "explicit-subst-rules {"
                           (write (get-explicit-subst-rules idxcls) :stream s))

                          (pprint-slot-block-line
                           "implicit-subst-hook {"
                           (write (get-implicit-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "explicit-subst-hook {"
                           (write (get-explicit-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "global-subst-hook {"
                           (write (get-global-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "substitution-subst-hook {"
                           (write (get-substitution-subst-hook idxcls) :stream s))
                          (pprint-slot-block-line
                           "merge-drop-hook {"
                           (write (get-merge-drop-hook idxcls) :stream s))
                          )))
@

%% Local Variables:
%% mode: latex
%% End:
%%
%% $Log$
%% Revision 1.5  1996/01/09 14:26:09  kehr
%% Major modifications.
%%
%% Revision 1.4  1995/12/19  10:58:46  kehr
%% Complete restructuring.
%%
%% Revision 1.3  1995/12/15  17:08:24  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.2  1995/12/07  18:14:22  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from scratch.
%%
%% Revision 1.1  1995/12/05  18:46:11  kehr
%% Added module `idxclass' and restructured some parts.
%%
%% Revision 1.9  1995/07/23  20:48:32  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.8  1995/07/23  14:14:08  kehr
%% Added support for merge-to--rule. Now works and creates
%% virtual-attributes as expected.
%%
%% Revision 1.7  1995/07/15  20:50:22  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.6  1995/07/11  23:33:07  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.5  1995/07/11  15:14:15  kehr
%% Today I finished the definition of indexentries. They now will be
%% inserted into the index when a appropriate location-class was finished.
%%
%% Revision 1.4  1995/07/11  00:47:43  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%
%% Revision 1.3  1995/07/10  19:08:16  kehr
%% Now corrected setup of location-classes. The was a bug in the
%% add-indexclass methods and some wrong reader-functions.
%%
%% Revision 1.2  1995/07/10  00:58:16  kehr
%% Completed noweb-support. Current version must be debugged to correct
%% some minor errors.
%%
%% Revision 1.1  1995/07/09  18:14:27  kehr
%% Initial checkin.
%%
