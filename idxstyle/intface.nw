%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    (idxstyle)
%% Submodule: user-interface to the indexstyle (intface)
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{user-interface}}

\subsection{Introduction}

This module contains all functions that are available in the user
interface of the indexstyle.


\subsection{Abstract Specification}


\subsubsection{Definition}


\subsubsection{Operation}



\subsection{Concrete Specification}

\subsubsection{Destructuring-switch-bind --- from Gabor Herr}

The following code was borrowed from Gabor Herr which he used in his
\textsf{ViEWS}-project. It is the heart of the interface macros.

<<Destructuring-switch-bind macro>>=
;;; $Id$
;;;----------------------------------------------------------------------

;;;
;;; util-lib                    LISP Utitlity Library
;;;
;;; (history at end)


;(provide 'util-lib)
;(in-package 'util-lib)

(export '(destructuring-switch-bind &switch))

(defmacro destructuring-switch-bind (lambdalist expr . body)
  "Similar to 'destructuring-bind' but also allows switch options at the
end of LAMBDALIST with the following syntax:

  &switch { var | (var key [defval]) | (var ({ key }*) [defval]) }*

In all cases VAR will be accessible in BODY as a variable.

If only VAR is specified, it is bound to the keyword with the same
name, if that keyword occured in EXPR. Otherwise it is bound to NIL.

If both a VAR and KEY were specified, VAR will be bound to KEY, if KEY
occured in EXPR and to NIL otherwise.

If VAR and a list of KEYs were specified, VAR will be bound to the
first KEY, which occured in EXPR. If none of the KEYS occured within
EXPR, VAR will be bound to NIL.

If DEFVAL was specified, variable will be bound to DEFVAL instead of
NIL in cases where no switch keyword was found in EXPR.
"

  (let* ((switchlist (member '&switch lambdalist))

         ;; 'remove' switches from lambdalist
         (lambdalist (ldiff lambdalist switchlist))

         ;; drop &switch keyword
         (switches (when switchlist (cdr switchlist)))

         ;; construct bindings for each switch and collect valid
         ;; keywords in 'switchkeys'
         (switchkeys '())
         (bindings
          (mapcar
           #'(lambda (spec)
               (cond

                 ;; spec simply consists of VAR
                 ((symbolp spec)
                    (let ((key (intern (symbol-name spec) 'keyword)))
                      (push key switchkeys)
                      `(,spec (FIND ,key <DESTRUCTURING-SWITCH-FORM>))
                      ))

                 ;; spec is (VAR form)
                 ((and (listp spec) (>= (list-length spec) 2))
                    (let ((var (first spec))
                          (keyspec (second spec))
                          (defval (when (cddr spec) (third spec))))
                      (cond
                        ;; spec is (VAR (KEY1 KEY2 ...))
                        ((listp keyspec)
                           `(,var
                             (COND
                               ,@(mapcar
                                  #'(lambda (key)
                                      (push key switchkeys)
                                      `((FIND ,key <DESTRUCTURING-SWITCH-FORM>)
                                        ,key))
                                  keyspec)
                               (T ,defval))))

                        ;; spec is (VAR KEY)
                        (t
                           (push keyspec switchkeys)
                           ` (,var (OR
                                    (FIND ,keyspec <DESTRUCTURING-SWITCH-FORM>)
                                    ,defval)))
                        )))

                 ;; illegal spec
                 (t (error "~A is not a valid switch specifier." spec))
                 ))
           switches))
         )

    ;; construct the expansion form
    ` (LET ((<DESTRUCTURING-SWITCH-FORM> ,expr))
        (LET ,bindings
          (DESTRUCTURING-BIND ,lambdalist
              (SET-DIFFERENCE <DESTRUCTURING-SWITCH-FORM>
                              ',switchkeys)
            ,@body))
        )
      ))


#|
(destructuring-switch-bind (name &rest args &key foo bar
                                 &switch
                                 on                     ; simple form
                                 (started :start)
                                 (speed (:fast :slow))
                                 (off :turn-off :turn-on) ; with switch key
                                 (choose (:one :two :three) :three))
                           '(width :foo 5 :bar 7 :on :turn-off :one)
  (list name foo bar args on started speed off choose))
|#
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{A specialized exporting mechanism}

We need a mechanism for importing only interface-definitions from this
package to other packages. Using [[export]] wouldn't be a good iead
since it imports too many symbols to the package running the indexer.
We define a symbol [[*user-interface-definitions*]] which is a
importable list of symbols.

It can be imported by other packages by calling
\begin{center}
  \texttt{(import idxstyle:*user-interface-definitions*)} .
\end{center}

<<User-interface-definitions>>=
(defparameter *user-interface-definitions*
  '(*indexstyle*
    *default-minimum-range-length*
    define-alphabet
    define-location-class
    define-attributes
    ))
@ %def *user-interface-definitions*

<<Export-list of submodule \module{intface}>>=
(export '*user-interface-definitions*)
(export *user-interface-definitions*)
@

\subsubsection{Global definitions}

The indexstyle itself will be initialised later after all functions are known.

<<Global indexstyle definitions>>=
(defparameter *indexstyle* nil)
(defparameter *default-minimum-range-length* 3)
@ %def *indexstyle* *default-minimum-range-length*

<<Global indexstyle initialisation>>=
(setq *indexstyle* (create-indexclass "default"))
@

\subsubsection{Helpers}

<<Helpers>>=
(defun stringify (name)
  (etypecase name
    (symbol (symbol-name name))
    (string name)
    (number (write-to-string name))))
@ %def stringify

<<Check functions>>=
(defun list-of-strings-p (x)
  (cond ((not (listp x)) nil)
        ((every #'(lambda (elt)
                    (or (stringp elt) (symbolp elt) (numberp elt)))
                x))))
@ %def list-of-strings-p

\subsubsection{Alphabets}

<<Defining alphabets>>=
(defmacro define-alphabet (&optional name string-list)
  (cond ((null name)
           (error "missing argument <name> !"))
        ((not (or (symbolp name) (stringp name)))
           (error "~A is not a symbol or a string" name))
        ((null string-list)
           (error "missing argument <string-list> !"))
        ((not (list-of-strings-p string-list))
           (error "~A is not a list of strings" string-list))
        (t `(LET ((NAME (STRINGIFY ',name)))
             (WHEN (LOOKUP-BASETYPE *indexstyle* NAME)
               (WARN "redefining alphabet `~A'" NAME))
             (ADD *indexstyle*
              (MAKE-ALPHABET NAME ',string-list))))))
@ %def define-alphabet


\subsubsection{Location-classes}

<<Defining location-classes>>=
(defmacro define-location-class (&rest args)
  (destructuring-switch-bind (name
                              layer-list
                              &key (min-range-length
                                    *default-minimum-range-length*)
                              &switch (var :var))
      args
    (cond ((null name)
             (error "missing argument <name> !"))
          ((null layer-list)
             (error "missing argument <layer-list> !"))
          ((not (list-of-strings-p layer-list))
             (error "~A is not a list of strings" layer-list))
          (t `(LET ((NAME (STRINGIFY ',name))
                    (LAYERS (MAPCAR #'(LAMBDA (X)
                                        (LET* ((LAYER (STRINGIFY X))
                                               (BASETYPE
                                                (LOOKUP-BASETYPE *indexstyle*
                                                                 LAYER)))
                                          (IF BASETYPE
                                              (MAKE-LOCCLS-LAYER BASETYPE)
                                              (MAKE-LOCCLS-SEPARATOR LAYER))))
                                    ',layer-list)))
               (WHEN (LOOKUP-LOCATION-CLASS *indexstyle* NAME)
                 (WARN "redefining location-class `~A'" NAME))
               (ADD *indexstyle*
                ,(if var
                     `(CHECKED-MAKE-VAR-LOCATION-CLASS NAME LAYERS
                       ,min-range-length)
                     `(CHECKED-MAKE-STANDARD-LOCATION-CLASS NAME LAYERS
                       ,min-range-length)))
               )))))
@ %def define-location-class

\subsubsection{Attributes}
\label{sec:intface:attributes}

<<Defining attributes>>=
(defmacro define-attributes (&optional attr-list)
  (cond ((null attr-list)
           (error "missing argument <attribute-list> !"))
        (t (let* ((wf-attr-list (make-well-formed-list attr-list))
                  (plain-list (apply #'concatenate 'list wf-attr-list))
                  )
             `(PROGN
               (MAPCAR #'(LAMBDA (CATATTR)
                           (IF (LOOKUP-CATATTR *indexstyle* CATATTR)
                               (WARN "ignoring redefinition of attribute `~A' !"
                                     CATATTR)
                               (ADD *indexstyle*
                                    (MAKE-CATEGORY-ATTRIBUTE CATATTR))))
                ',plain-list)
               (INITIALIZE-CATEGORY-ATTRIBUTES ',wf-attr-list *indexstyle*))
             ))))
@ %def define-attributes

\no Here we introduce a well-formed-list. In this term a well-formed
list is a list containing only non-empty lists as elements. All
elements of the latter lists must be strings. The input list must be a
list containing symbols, strings, numbers and lists. The latter lists
may only consist of symbols, strings and numbers. Function
[[make-well-formed-list]] transforms ist argument into a well-formed
list if possible and signals an error, if its argument is of wrong
type or structure.

<<Helpers>>=
(defun make-well-formed-list (attr-list)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (list (stringify x)))
                    ((listp x)
                       (map-to-strings x))))
          attr-list))

(defun map-to-strings (slist)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (stringify x))
                    ((listp  x)
                       (error "nesting level too deep !"))
                    (t (error "~A is not a string !" x))))
          slist))
@ %def make-well-formed-list map-to-strings


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Keyword sort- and merge-rules}
\label{sec:keyword-rules}

We have three different forms of keyword rules which can be described by
a pair (\term{pattern}, \term{replacement}). The first one is the
so-called \term{string-substitution} and is expressed by a pair of
strings. If the pattern string matches the substring is substituted by
its replacement.

The second form is described as a character substitution. If the given
pattern and replacement string are both of length 1, we assume that a
general character substitution is wanted.

The last form is defined by a regular expression and a replacement
template. The regexp describes the pattern that should be replaced by
the replacement if a valid match was found.

For the implementation of the latter We use the GNU
regular-expression-library [[rx]] for our implementation. This library
is used by the library [[ordrules]], which is a foreign library
implemented in C. The \Lisp-system must be extended by both libraries.
The feature form [[#+:ORDRULES]] is used to include the regular
expression support. Since the user-interface defined in the standard
distribution allows no low-level access we need to explicitly import
the neccessary functions ourselves. The following chunk is included in
the root-chunk of module \module{idxstyle}.

<<Use [[ordrules]]-package if available>>=
(eval-when (eval load compile)
  (when (member "ORDRULES"
                (mapcar #'package-name
                        (list-all-packages))
                :test #'equal)
    (pushnew ':ORDRULES *features*)
    (eval-when (eval)
      (usepackage "ORDRULES"))))
@
%%
\begin{arguments}{replacement}
  \item[pattern] describes the pattern of the substitution rule. It
    must be specified as a string.
  \item[replacement] describes the replacement. It is also a string.
  \item[isreject] is a boolean value that describes if the matching is
    also possible on substituted patterns.
\end{arguments}
%%
For more information see the description of the [[ordrules]]-package.

<<Defining keyword rules>>=
#+:ORDRULES
(defmacro merge-rule (&rest args)
  (destructuring-switch-bind (pattern
                              replacement
                              &switch (again :again))
      args
    (cond ((null pattern)
             (error "missing argument <pattern> !"))
          ((null replacement)
             (error "missing argument <replacement> !"))
          (t `(ADD-MERGE-RULE ,pattern ,replacement
               ,(if again 1 0))))))

#-:ORDULES
(defmacro merge-rule (&rest args)
  (declare (ignore args))
  (warn "merge-rule not supported! ignoring definition"))
@ %def merge-rule

<<Defining keyword rules>>=
#+:ORDRULES
(defmacro sort-rule (&rest args)
  (destructuring-switch-bind (pattern
                              replacement
                              &switch (again :again))
      args
    (cond ((null pattern)
             (error "missing argument <pattern> !"))
          ((null replacement)
             (error "missing argument <replacement> !"))
          (t `(ADD-SORT-RULE ,pattern ,replacement
               ,(if again 1 0))))))

#-:ORDULES
(defmacro sort-rule (&rest args)
  (declare (ignore args))
  (warn "sort-rule not supported! ignoring definition"))
@ %def sort-rule


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{intface}>>=
;; $Id$

<<Destructuring-switch-bind macro>>
<<Defining alphabets>>
<<Defining location-classes>>
<<Defining attributes>>
<<Defining keyword rules>>
<<Helpers>>
<<Check functions>>

<<User-interface-definitions>>

<<Export-list of submodule \module{intface}>>
@

<<RCS-Identifier>>=
("intface" . "$Id$")
@


%% $Log$
%% Revision 1.8  1996/04/29 08:37:34  kehr
%% Don't remember any changes.
%%
%% Revision 1.7  1996/03/28  16:46:35  kehr
%% Changed indexstule modules to work with the new foreign package `ordrules'.
%%
%% Revision 1.6  1996/03/13  16:50:49  kehr
%% Ok, here I am. Included support for regular expressions. Minor changes
%% in all other parts of this module. Made some tests but had some
%% problems with LISP stack overflow errors. Don't know where they came
%% from. We'll see. The next step is to implement the string replacement
%% mechanism and set up extensive tests. Maybe I can use the tests from
%% Henry Spencer's regexp library.
%%
%% Revision 1.5  1996/02/06  15:43:35  kehr
%% Added some code for define-alphabet. This code is buggy and must be
%% rewritten due to macro failures.
%%
%% Revision 1.4  1996/01/31  15:29:24  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.3  1995/12/19  10:58:50  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:28  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:26  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from
%% scratch.
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:

