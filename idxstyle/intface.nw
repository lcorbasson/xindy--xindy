%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    (idxstyle)
%% Submodule: user-interface to the indexstyle (intface)
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{user-interface}}

\subsection{Introduction}

This module contains all functions that are available in the user
interface of the indexstyle.


\subsection{Abstract Specification}


\subsubsection{Definition}


\subsubsection{Operation}



\subsection{Concrete Specification}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{A specialized exporting mechanism}

We need a mechanism for importing only interface-definitions from this
package to other packages. Using [[export]] wouldn't be a good iead
since it imports too many symbols to the package running the indexer.
We define a symbol [[*user-interface-definitions*]] which is a
importable list of symbols.

It can be imported by other packages by calling
\begin{center}
  \texttt{(import idxstyle:*idxstyle-user-interface-definitions*)} .
\end{center}

<<User-interface-definitions>>=
(defparameter *idxstyle-user-interface-definitions*
  '(*indexstyle*
    *indexstyle-readtable*
    *default-minimum-range-length*
    *included-files*
    define-alphabet
    define-alphabet*
    define-enumeration
    define-location-class
    define-crossref-class
    define-location-class-order
    define-attributes
    define-letter-group
    define-letter-groups
    merge-rule
    sort-rule
    searchpath
    require
    info
    ))
@ %def *idxstyle-user-interface-definitions*

<<Export-list of submodule \module{intface}>>=
(export '(*idxstyle-user-interface-definitions*
          *indexstyle*
          *indexstyle-readtable*
          set-searchpath-by-string
          do-require))
@

\subsubsection{Helpers}

The following functions help the macros to test for syntactic errors.
Since in the submodule \module{idxstyle} we start to define the
default indexstyle which is expressed via macros that use the
following function [[stringify]], this function must be evaluable
during the compilation process. This is assured through the
[[eval-when]] special form.

<<Helpers>>=
(eval-when (compile load eval)
  (defun stringify (name)
    (declare (inline))
    (etypecase name
      (symbol (symbol-name name))
      (string name)
      (number (write-to-string name)))))

(defun list-of-strings-p (x)
  (cond ((not (listp x)) nil)
        ((every #'(lambda (elt)
                    (or (stringp elt) (symbolp elt) (numberp elt)))
                x))))
@ %def stringify list-of-strings-p

\no Here we introduce a well-formed-list. In this term a well-formed
list is a list containing only non-empty lists as elements. All
elements of the latter lists must be strings. The input list must be a
list containing symbols, strings, numbers and lists. The latter lists
may only consist of symbols, strings and numbers. Function
[[make-well-formed-list]] transforms ist argument into a well-formed
list if possible and signals an error, if its argument is of wrong
type or structure.

<<Helpers>>=
(defun make-well-formed-list (attr-list)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (list (stringify x)))
                    ((listp x)
                       (map-to-strings x))))
          attr-list))

(defun map-to-strings (slist)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (stringify x))
                    ((listp  x)
                       (error "nesting level too deep !"))
                    (t (error "~S is not a string !" x))))
          slist))

(export '(stringify list-of-strings-p
          make-well-formed-list map-to-strings))
@ %def make-well-formed-list map-to-strings


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{A special reader syntax for quoted strings}

The following reader function simulates the reading of strings like C
does. Its quote-symbol is `\texttt{\bslash}' which quotes every
character appearing next in the input stream. If the next character is
`\texttt{n}' it is converted to a \texttt{Newline}-character. The
macro-character \texttt{\#} recognizes a new kind of strings such that
the string
\begin{center}
  \verb|#"this is a string\n with two newlines \n"|
\end{center}
will be correctly parsed and all occurences of `\texttt{\bslash{}n}'
converted to a \texttt{Newline}-character.

Additionally this reader-function knows the correct values of the
special characters `\texttt{\bslash{}b}' and `\texttt{\bslash{}e}'.
The encoding of these special characters declares
`\texttt{\bslash{}b}' to be the character no.~1, and
`\texttt{\bslash{}e}' to be character no.~255 in the
ISO-Latin-alphabet. We can't choose character no.~0 for
`\texttt{\bslash{}b}' since the sort-key generation is performed via
the C-library \module{ORDRULES} in which character no.~0 is used as
the string-termination character.

<<String reader function>>=
(defun c-string-reader (stream char)
  (declare (ignore char))
  (let ((ch nil)
        (str (make-array 10
                         :element-type 'string-char
                         :adjustable t
                         :fill-pointer 0)))
    (loop
      (setq ch (read-char stream t #\Newline t))
      (case ch
        (#\" (return str))              ;; "
        (#\\ (setq ch (read-char stream t #\Newline t))
             (case ch
               (#\n (vector-push-extend #\Newline str))
               (#\b (vector-push-extend (character   1) str))
               (#\e (vector-push-extend (character 255) str))
               (t   (vector-push-extend ch str))))
        (t (vector-push-extend ch str))))))

(set-macro-character #\" #'c-string-reader nil *indexstyle-readtable*)

#|
(let ((x #\Null))
  (loop for i from 1 to 255
        do (progn (print (character i))
                  (when (char>= x (character i))
                    (print "Whee!"))
                  (setq x (character i)))))
|#
@ %def c-string-reader

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Typechecking parameters}

<<check :hierdepth>>=
(when (not (numberp hierdepth))
  (error "~S is not a number! in ~S~%" hierdepth whole))
@

<<check name>>=
((null name)
 (error "missing argument <name> in `~S' !" whole))
((not (or (symbolp name) (stringp name)))
 (error "~S is not a symbol or a string in `~S' !" name whole))
@

\subsubsection{Alphabets}

We introduce two different forms of alphabet definitions. The first
macro does \emph{not} expand the [[string-list]]-argument, whereas the
second form \emph{does} so. The second form is intended to define
alphabets via \Lisp-expressions and should only be used by an
experienced user.

<<Defining alphabets>>=
(defmacro define-alphabet (&whole whole &optional name string-list)
  (cond <<check name>>
        ((not (listp string-list))
           (error "missing argument <string-list> !"))
        ((not (list-of-strings-p string-list))
           (error "~S is not a list of strings" string-list))
        (t `(LET ((NAME (STRINGIFY ',name)))
             (WHEN (LOOKUP-BASETYPE *indexstyle* NAME)
               (NRAW "redefining alphabet `~S'" NAME))
             (ADD *indexstyle* (MAKE-ALPHABET NAME ',string-list))))))

(defmacro define-alphabet* (&whole whole &optional name string-list)
  (cond <<check name>>
        ((not (listp string-list))
           (error "missing argument <string-list> !"))
        (t (let ((scar (car string-list)))
             (if (and (symbolp scar) (fboundp scar))
                 `(LET ((NAME (STRINGIFY ',name))
                        (STRING-LIST ,string-list)) #| evaluates string-list |#
                   (UNLESS (LIST-OF-STRINGS-P STRING-LIST)
                     (ERROR "~S is not a list of strings" STRING-LIST))
                   (WHEN (LOOKUP-BASETYPE *indexstyle* NAME)
                     (NRAW "redefining alphabet `~S'" NAME))
                   (ADD *indexstyle* (MAKE-ALPHABET NAME STRING-LIST))))))))
@ %def define-expand-alphabet define-expand-alphabet*


\subsubsection{Enumerations}

<<Defining enumerations>>=
(defmacro define-enumeration (&whole
                              whole
                              &optional
                              name prefix-match-func base-alphabet)
  (cond <<check name>>
        ((null prefix-match-func)
           (error "missing argument <prefix-match-function> !"))
        (t (let* ((name   (stringify name))
                  (symbol (make-symbol
                           (concatenate 'string "ENUMERATION-" name))))
             `(LET () #| PROGN instead of LET () yields a runtime error !? |#
               (IF (LOOKUP-BASETYPE *indexstyle* ,name)
                   (NRAW "redefining alphabet `~S'" ,name)
                   (PROGN
                     (DEFCLASS ,symbol (ENUMERATION) ())
                     (ADD *indexstyle*
                          (MAKE-ENUMERATION ',symbol ,name ,base-alphabet))))
               (DEFMETHOD PREFIX-MATCH ((STR STRING) (ENUM ,symbol))
                 (FUNCALL ,prefix-match-func STR)))))))
@ %def define-enumeration

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Location-classes}

\paragraph{Structured location-classes}

<<Defining location-classes>>=
(defmacro define-location-class (&whole whole &rest args)
  (destructuring-switch-bind (name
                              layer-list
                              &key
                              (min-range-length *default-minimum-range-length*)
                              (hierdepth 0) ;no hierarchies are to be formed
                              &switch
                              (var :var))
      args
    (cond
      ((null name)
         (error "missing argument <name> in~%~S" whole))
      ((null layer-list)
         (error "missing argument <layer-list> in~%~S" whole))
      ((not (list-of-strings-p layer-list))
         (error "~S is not a list of strings in~%~S" layer-list whole))
      ((not (numberp hierdepth))
         (error "~S is not a number! in~%~S" hierdepth whole))
      ((not (or (numberp   min-range-length)
		(eql 'none min-range-length)))
         (error "~S must be a number or the keyword `none' in~%~S"
		min-range-length whole))
      (t (when (eql 'none min-range-length)
	   (setq min-range-length 0))
	 `(LET ((NAME (STRINGIFY ',name))
                (LAYERS (MAPCAR #'(LAMBDA (X)
                                    (LET* ((LAYER (STRINGIFY X))
                                           (BASETYPE
                                            (LOOKUP-BASETYPE *indexstyle*
                                                             LAYER)))
                                      (IF BASETYPE
                                          (MAKE-LOCCLS-LAYER BASETYPE)
                                          (MAKE-LOCCLS-SEPARATOR LAYER))))
                                ',layer-list)))
           (COND ((LOOKUP-CROSSREF-CLASS *indexstyle* NAME)
                    (OOPS "replacing cross-reference-class `~S' is not allowed !"
                          NAME))
                 (t (WHEN (LOOKUP-LOCATION-CLASS *indexstyle* NAME)
                      (NRAW "redefining location-reference-class `~S' !" NAME))
                    (ADD *indexstyle*
                         ,(if var
                              `(CHECKED-MAKE-VAR-LOCATION-CLASS NAME LAYERS
                                ,min-range-length ,hierdepth)
                              `(CHECKED-MAKE-STANDARD-LOCATION-CLASS NAME LAYERS
                                ,min-range-length ,hierdepth))))
                 ))))))
@ %def define-location-class


\paragraph{Cross-reference location-classes}

<<Defining location-classes>>=
(defmacro define-crossref-class (&rest args)
  (destructuring-switch-bind (&whole
                              whole
                              name
                              &switch (verified :unverified))
      args
    (cond <<check name>>
      (t `(LET ((NAME (STRINGIFY ',name)))
           (cond ((LOOKUP-LOCATION-CLASS *indexstyle* NAME)
                    (OOPS "replacing location-reference-class `~S' is not allowed !"
                          NAME))
                 (t (WHEN (LOOKUP-CROSSREF-CLASS *indexstyle* NAME)
                      (NRAW "redefining crossref-location-class `~S'" NAME))
                    (ADD *indexstyle*
                         ,(if verified
                              `(MAKE-UNVERIFIED-CROSSREF-LOCATION-CLASS NAME)
                              `(MAKE-VERIFIED-CROSSREF-LOCATION-CLASS NAME))))))))))
@ %def define-crossref-class


\paragraph{Defininig the order of location-classes}

<<Defining location-classes>>=
(defmacro define-location-class-order (olist)
  (cond ((not (listp olist))
           (error "missing argument <list> !"))
        ((not (list-of-strings-p olist))
           (error "~S is not a list of strings" olist))
        (t `(LET ((CTR 1))
             (MAPC #'(LAMBDA (NAME)
                       (LET* ((NEW-NAME (STRINGIFY NAME))
                              (LOCCLS
                               (CDR (LOOKUP-LOCATION-CLASS *indexstyle*
                                                           NEW-NAME))))
                         (INCF CTR)
                         (COND (LOCCLS (SET-ORDNUM CTR LOCCLS))
                               (t (OOPS "unknown location-class `~S'"
                                        NEW-NAME)))))
              ',olist)))))
@ %def define-location-class-order


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Attributes}
\label{sec:intface:attributes}

<<Defining attributes>>=
(defmacro define-attributes (&whole whole &optional attr-list)
  (cond ((null attr-list)
           (error "missing argument <attribute-list> in~&~S" whole))
        (t (let* ((wf-attr-list (make-well-formed-list attr-list))
                  (plain-list (apply #'concatenate 'list wf-attr-list))
                  )
             `(PROGN
               (MAPCAR
		#'(LAMBDA (CATATTR)
		    (IF (LOOKUP-CATATTR *indexstyle* CATATTR)
			(NRAW "ignoring redefinition of attribute ~S in~&~S"
			      CATATTR ,whole)
			(ADD *indexstyle*
			     (MAKE-CATEGORY-ATTRIBUTE CATATTR))))
                ',plain-list)
               (INITIALIZE-CATEGORY-ATTRIBUTES ',wf-attr-list *indexstyle*))
             ))))
@ %def define-attributes

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Keyword sort- and merge-rules}
\label{sec:keyword-rules}

We have three different forms of keyword rules which can be described by
a pair (\term{pattern}, \term{replacement}). The first one is the
so-called \term{string-substitution} and is expressed by a pair of
strings. If the pattern string matches the substring is substituted by
its replacement.

The second form is described as a character substitution. If the given
pattern and replacement string are both of length 1, we assume that a
general character substitution is wanted.

The last form is defined by a regular expression and a replacement
template. The regexp describes the pattern that should be replaced by
the replacement if a valid match was found.

For the implementation of the latter We use the GNU
regular-expression-library [[rx]] for our implementation. This library
is used by the library [[ordrules]], which is a foreign library
implemented in C. The \Lisp-system must be extended by both libraries.
The feature form [[#+:ORDRULES]] is used to include the regular
expression support. Since the user-interface defined in the standard
distribution allows no low-level access we need to explicitly import
the neccessary functions ourselves. The following chunk is included in
the root-chunk of module \module{idxstyle}.

<<Use [[ordrules]]-package if available>>=
(eval-when (eval load compile)
  (when (member "ORDRULES"
                (mapcar #'package-name
                        (list-all-packages))
                :test #'equal)
    (pushnew ':ORDRULES *features*)))
@
%%
\begin{arguments}{replacement}
  \item[pattern] describes the pattern of the substitution rule. It
    must be specified as a string.
  \item[replacement] describes the replacement. It is also a string.
  \item[isreject] is a boolean value that describes if the matching is
    also possible on substituted patterns.
\end{arguments}
%%
For more information see the description of the [[ordrules]]-package.

<<Defining keyword rules>>=
#+:ORDRULES
(defmacro merge-rule (&rest args)
  (destructuring-switch-bind (pattern
                              replacement
                              &switch (again :again))
      args
    (cond ((null pattern)
             (error "missing argument <pattern> !"))
          ((null replacement)
             (error "missing argument <replacement> !"))
          (t `(ORDRULES:ADD-KEYWORD-MERGE-RULE ,pattern ,replacement
               ,(if again 1 0))))))

#-:ORDRULES
(defmacro merge-rule (&rest args)
  (declare (ignore args))
  (oops "merge-rule not supported! ignoring definition"))
@ %def merge-rule

<<Defining keyword rules>>=
#+:ORDRULES
(defmacro sort-rule (&rest args)
  (destructuring-switch-bind (pattern
                              replacement
                              &switch (again :again))
      args
    (cond ((null pattern)
             (error "missing argument <pattern> !"))
          ((null replacement)
             (error "missing argument <replacement> !"))
          (t `(ORDRULES:ADD-KEYWORD-SORT-RULE ,pattern ,replacement
               ,(if again 1 0))))))

#-:ORDRULES
(defmacro sort-rule (&rest args)
  (declare (ignore args))
  (oops "sort-rule not supported! ignoring definition"))
@ %def sort-rule


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Letter groups}

Letter group are intended to group indexentries together to be able to
associate a special markup for each letter group. For example, one
wants to define a group named ``Symbols'' and all indexentries
describing symbols should be put into this group. Usually letter
groups are defined via the prefic of the indexentries' keyword. The
sorting of the letter groups may be different from the sorting of the
\term{sort-key} of the indexentries. To specify a sort-order on the
letter groups we decided to use a total order that can be defined with
relations between letter group. Such a specification might be `b' is
\emph{before} `c' and \emph{after} `a'. The user defines a partial
order that must result in exactly one possible total order. This
principle was chosen to overcome the old concept of assigning integer
numbers as the group identifier. This concept proved to be very
incomfortable and not easy to be understood. The partial order
approach now allows to extend predefined modules such as one
specifying the letter groups for latin-based alphabets with
language-specific letters that may be inserted among the existing
groups without the need to consider the group-numbers.

The command \texttt{define-letter-group} now comes in a general form
that allows to define a \emph{group-name} and a list of prefixes that
should be mapped onto this group. Further prefixes that appear in more
definitions for the same group are simply added to the list of
prefixes.

<<Defining letter groups>>=
(defmacro define-letter-group
    (&whole whole name &key prefixes before after)
  (cond <<check name>>
        ((and before
              (not (lookup-letter-group-definition *indexstyle* before)))
           (error "~S does not name a letter group in~%~S" before whole))
        ((and after
              (not (lookup-letter-group-definition *indexstyle* after)))
           (error "~S does not name a letter group in~%~S" after whole))
        ((not (list-of-strings-p prefixes))
           (error "argument <prefixes> is not a list of strings in~%~S"
                  whole))
        (t `(LET ()
             (ADD-LETTER-GROUPS *INDEXSTYLE*
              ,name ',(or prefixes (list name))
              :BEFORE ,before :AFTER ,after)))))
@ %def define-letter-group

\no Additionally we define a convenience-macro that allows us to
define several letter groups at once.

<<Defining letter groups>>=
(defmacro define-letter-groups (&whole whole &optional letter-groups)
  (cond ((not (list-of-strings-p letter-groups))
           (error "~S is not a list of strings in~%~S" letter-groups whole))
        (t `(LET ()
             (ADD-LETTER-GROUPS *INDEXSTYLE*
              ,(car letter-groups) ',(list (car letter-groups)))
             ,@(let ((last (car letter-groups)))
                    (mapcar #'(lambda (letter-group)
                                (prog1
                                    `(ADD-LETTER-GROUPS *INDEXSTYLE*
                                      ,letter-group ',(list letter-group)
                                      :AFTER ,last)
                                  (setq last letter-group)))
                            (cdr letter-groups)))))))
@ %def define-letter-groups

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Loading more files}
\label{sec:intface:require}

<<Including files>>=
;;; we remove the inherited symbol and establish a new one
(eval-when (compile load eval)
  (shadow 'require))

(defmacro require (&rest args)
  (cond ((null args)
           (error "missing argument <filename> !"))
        ((not (stringp (car args)))
           (error "(require ~S): expected <filename> !" (car args)))
        (t `(LET ((FILENAME (STRINGIFY ',(car args))))
             (DO-REQUIRE FILENAME)))))

(defun do-require (filename)
  (let ((file (find-file filename)))
    (unless (member file *included-files* :test #'equalp)
      (push file *included-files*)
      (info "~&Loading module ~S..." filename)
      (load file :verbose nil)
      (info "~&Finished loading module ~S.~%" filename))))
@ %def require do-require

\no Since the built-in [[load]] is not very clever when searching for
files we implement a function that is given a filename which may
contain absolute and relative pathnames. If it is an absolute pathname
we check if is availabe and load it, if possible. If it is a relative
pathname, we append the filename to all paths in
[[*xindy-load-paths*]] and check if we get an existing file. If we
find one we load it as usual.

<<Including files>>=
(defun find-file (filename)
  (let ((file (pathname filename)))
    (when (equal (file-namestring file) "")
      (error "~S is not a valid filename !" filename))
    (let ((found (some #'(lambda (path)
                           (and (probe-file (append-pathnames path file))))
                       *load-paths*)))
      (or found (error "Could not find file ~S !" filename)))))
@ %def find-file

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Setting the searchpath}
\label{sec:intface:searchpath}

The following chunks implement the searchpath.

<<Setting the searchpath>>=
(defmacro searchpath (&rest args)
  (cond ((null args)
           (error "missing argument <pathlist> !"))
        ((stringp (car args))
           `(SET-SEARCHPATH-BY-STRING ,(car args)))
        ((listp args)
           `(SET-SEARCHPATH ',(car args)))))

(defun set-searchpath-by-string (searchpath-str)
  (set-searchpath (string-to-searchlist searchpath-str)))

(defun string-to-searchlist (str)
  (let ((paths '())
        pos)
    (nreverse
     (loop (when (equalp str "")
             (return (push :default paths)))
           (setq pos (position #\: str))
           (if pos
               (progn
                 (push (subseq str 0 pos) paths)
                 (setq str (subseq str (1+ pos))))
               (return (push str paths)))))))

(defun set-searchpath (path-list)
  (setq *load-paths*
        (apply #'nconc
               (mapcar
                #'(lambda (elt)
                    (cond ((stringp elt)
                             (list (make-real-pathname elt)))
                          ((eq elt :default)
                             *default-load-paths*)
                          ((eq elt :last)
                             *load-paths*)
                          (t (oops "~&searchpath: invalid argument ~S in~%~S"
                                   elt path-list))))
                path-list))))
@ %def searchpath

\no The following function takes a string representing a pathname and
converts it into a pathname-object. Since the string represents a
directory in every case we first convert it with the function
[[pathname]] to a pathname-object. If the resulting pathname contains
a name-field indicating that the string was not a correct pathname (in
UNIX: the trailing [[/]] was missing) we create a new pathname by
adding the filename to the directory resulting in the corrected
pathname.

<<Setting the searchpath>>=
(defun make-real-pathname (pathname-str)
  (let* ((pn     (pathname pathname-str))
         (fname  (file-namestring pn)))
    (cond ((string/= fname "")
             (make-pathname :directory (append (pathname-directory pn)
                                               (list fname))))
          (t pn))))
@ %def make-real-pathname

\no The following function takes two pathnames and appends the second
one (if its a [[:relative]] one) to the first one. It creates a new
[[:directory]]-fieldand copies the [[name]]- and [[type]]-components
of the second argument. This function can therefore be used to take a
relative file- or directory-name and append it to an existing
directory.

<<Setting the searchpath>>=
(defun append-pathnames (pn-dir pn-sub)
  (let ((dir-dir (pathname-directory pn-dir))
        (dir-sub (pathname-directory pn-sub)))
    (cond ((not (eq :relative (car dir-sub))) nil)
          (t (make-pathname :directory (append dir-dir (cdr dir-sub))
                            :name (pathname-name pn-sub)
                            :type (pathname-type pn-sub))))))
@ %def append-pathnames


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Destructuring-switch-bind --- from Gabor Herr}

The following code was borrowed from Gabor Herr which he used in his
\textsf{ViEWS}-project. It is the heart of the interface macros.

<<Destructuring-switch-bind macro>>=
;;; $Id$
;;;----------------------------------------------------------------------

;;;
;;; util-lib                    LISP Utitlity Library
;;;
;;; (history at end)


;(provide 'util-lib)
;(in-package 'util-lib)

(export '(destructuring-switch-bind &switch))

(defmacro destructuring-switch-bind (lambdalist expr . body)
  "Similar to 'destructuring-bind' but also allows switch options at the
end of LAMBDALIST with the following syntax:

  &switch { var | (var key [defval]) | (var ({ key }*) [defval]) }*

In all cases VAR will be accessible in BODY as a variable.

If only VAR is specified, it is bound to the keyword with the same
name, if that keyword occured in EXPR. Otherwise it is bound to NIL.

If both a VAR and KEY were specified, VAR will be bound to KEY, if KEY
occured in EXPR and to NIL otherwise.

If VAR and a list of KEYs were specified, VAR will be bound to the
first KEY, which occured in EXPR. If none of the KEYS occured within
EXPR, VAR will be bound to NIL.

If DEFVAL was specified, variable will be bound to DEFVAL instead of
NIL in cases where no switch keyword was found in EXPR.
"

  (let* ((switchlist (member '&switch lambdalist))

         ;; 'remove' switches from lambdalist
         (lambdalist (ldiff lambdalist switchlist))

         ;; drop &switch keyword
         (switches (when switchlist (cdr switchlist)))

         ;; construct bindings for each switch and collect valid
         ;; keywords in 'switchkeys'
         (switchkeys '())
         (bindings
          (mapcar
           #'(lambda (spec)
               (cond

                 ;; spec simply consists of VAR
                 ((symbolp spec)
                    (let ((key (intern (symbol-name spec) 'keyword)))
                      (push key switchkeys)
                      `(,spec (FIND ,key <DESTRUCTURING-SWITCH-FORM>))
                      ))

                 ;; spec is (VAR form)
                 ((and (listp spec) (>= (list-length spec) 2))
                    (let ((var (first spec))
                          (keyspec (second spec))
                          (defval (when (cddr spec) (third spec))))
                      (cond
                        ;; spec is (VAR (KEY1 KEY2 ...))
                        ((listp keyspec)
                           `(,var
                             (COND
                               ,@(mapcar
                                  #'(lambda (key)
                                      (push key switchkeys)
                                      `((FIND ,key <DESTRUCTURING-SWITCH-FORM>)
                                        ,key))
                                  keyspec)
                               (T ,defval))))

                        ;; spec is (VAR KEY)
                        (t
                           (push keyspec switchkeys)
                           ` (,var (OR
                                    (FIND ,keyspec <DESTRUCTURING-SWITCH-FORM>)
                                    ,defval)))
                        )))

                 ;; illegal spec
                 (t (error "~A is not a valid switch specifier." spec))
                 ))
           switches))
         )

    ;; construct the expansion form
    ` (LET ((<DESTRUCTURING-SWITCH-FORM> ,expr))
        (LET ,bindings
          (DESTRUCTURING-BIND ,lambdalist
              (SET-DIFFERENCE <DESTRUCTURING-SWITCH-FORM>
                              ',switchkeys)
            ,@body))
        )
      ))

(export 'destructuring-switch-bind)

#|
(destructuring-switch-bind (name &rest args &key foo bar
                                 &switch
                                 on                     ; simple form
                                 (started :start)
                                 (speed (:fast :slow))
                                 (off :turn-off :turn-on) ; with switch key
                                 (choose (:one :two :three) :three))
                           '(width :foo 5 :bar 7 :on :turn-off :one)
  (list name foo bar args on started speed off choose))
|#
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{intface}>>=
;; $Id$

<<Destructuring-switch-bind macro>>
<<Helpers>>
<<String reader function>>
<<Defining alphabets>>
<<Defining enumerations>>
<<Defining location-classes>>
<<Defining attributes>>
<<Defining keyword rules>>
<<Defining letter groups>>
<<Including files>>
<<Setting the searchpath>>

<<User-interface-definitions>>

<<Export-list of submodule \module{intface}>>
@

<<RCS-Identifier>>=
("intface" . "$Id$")
@


%% $Log$
%% Revision 1.19  1996/07/22 15:54:23  kehr
%% Replaced some of the oops-macros by nraw-macros.
%%
%% Revision 1.18  1996/07/22  11:43:31  kehr
%% Argument `none' can now be specified as argument to the
%% keyqword-argument :min-range-length of command `define-location-class'.
%% ----------------------------------------------------------------------
%%
%% Revision 1.17  1996/07/16  14:05:54  kehr
%% Checkin after all the changes to the `define-letter-group(s)' commands
%% have been made.
%%
%% Revision 1.16  1996/07/11  14:16:19  kehr
%% Complete Major checkin before changing the letter-groups.
%%
%% Revision 1.15  1996/07/03  18:41:42  kehr
%% Checkin after some modifications of the error-system and the loading of
%% indexstyle-modules have been made. Affects all modules.
%%
%% Revision 1.14  1996/06/24  09:12:29  kehr
%% Several changes in all Lisp-modules due to the new startup-module and
%% the implementation of the percentage bar appearing in the processing
%% phases.
%%
%% Revision 1.13  1996/06/03  10:01:15  kehr
%% Added support for treeing layered-location-references.
%%
%% Revision 1.12  1996/05/29  14:15:29  kehr
%% Complete checkin after the major changes in the markup. See ChangeLog
%% for details.
%%
%% Revision 1.11  1996/05/20  08:47:56  kehr
%% Major release of the modules locref, idxstyle and index.
%%
%% Revision 1.10  1996/05/09  11:49:35  kehr
%% Changes in all submodules, due to macro-expansion problems during
%% compilation.
%%
%% Revision 1.9  1996/04/30  09:26:40  kehr
%% Changes the adding of location-classes to an index. Old definitions
%% will now be removed if a new location-class with the same name is
%% added. The forall-location-classes iterator was rewritten. It is now
%% named map-location-class and its behaviour is now comparable to a
%% map-function with implicit removal of nil in the result-list.
%%
%% Revision 1.8  1996/04/29  08:37:34  kehr
%% Don't remember any changes.
%%
%% Revision 1.7  1996/03/28  16:46:35  kehr
%% Changed indexstule modules to work with the new foreign package `ordrules'.
%%
%% Revision 1.6  1996/03/13  16:50:49  kehr
%% Ok, here I am. Included support for regular expressions. Minor changes
%% in all other parts of this module. Made some tests but had some
%% problems with LISP stack overflow errors. Don't know where they came
%% from. We'll see. The next step is to implement the string replacement
%% mechanism and set up extensive tests. Maybe I can use the tests from
%% Henry Spencer's regexp library.
%%
%% Revision 1.5  1996/02/06  15:43:35  kehr
%% Added some code for define-alphabet. This code is buggy and must be
%% rewritten due to macro failures.
%%
%% Revision 1.4  1996/01/31  15:29:24  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.3  1995/12/19  10:58:50  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:28  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:26  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from
%% scratch.
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:

