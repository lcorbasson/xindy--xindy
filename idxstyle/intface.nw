%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    (idxstyle)
%% Submodule: user-interface to the indexstyle (intface)
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{user-interface}}

\subsection{Introduction}

This module contains all functions that are available in the user
interface of the indexstyle.


\subsection{Abstract Specification}


\subsubsection{Definition}


\subsubsection{Operation}



\subsection{Concrete Specification}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{A specialized exporting mechanism}

We need a mechanism for importing only interface-definitions from this
package to other packages. Using [[export]] wouldn't be a good iead
since it imports too many symbols to the package running the indexer.
We define a symbol [[*user-interface-definitions*]] which is a
importable list of symbols.

It can be imported by other packages by calling
\begin{center}
  \texttt{(import idxstyle:*idxstyle-user-interface-definitions*)} .
\end{center}

<<User-interface-definitions>>=
(defparameter *idxstyle-user-interface-definitions*
  '(*indexstyle*
    *indexstyle-readtable*
    *default-minimum-range-length*
    *included-files*
    define-alphabet
    define-alphabet*
    define-enumeration
    define-location-class
    define-crossref-class
    define-location-class-order
    define-attributes
    define-letter-group
    define-letter-groups
    merge-to
    merge-rule
    sort-rule
    searchpath
    require
    info
    ))
@ %def *idxstyle-user-interface-definitions*

<<Export-list of submodule \module{intface}>>=
(export '(*idxstyle-user-interface-definitions*
          *indexstyle*
          *indexstyle-readtable*
          set-searchpath-by-string
          do-require))
@

\subsubsection{Helpers}

The following functions help the macros to test for syntactic errors.
Since in the submodule \module{idxstyle} we start to define the
default indexstyle which is expressed via macros that use the
following function [[stringify]], this function must be evaluable
during the compilation process. This is assured through the
[[eval-when]] special form.

<<Helpers>>=
(eval-when (compile load eval)
  (defun stringify (name)
    (declare (inline))
    (etypecase name
      (symbol (symbol-name name))
      (string name)
      (number (write-to-string name)))))

(defun list-of-strings-p (x)
  (cond ((not (listp x)) nil)
        ((every #'(lambda (elt)
                    (or (stringp elt) (symbolp elt) (numberp elt)))
                x))))
@ %def stringify list-of-strings-p

\no Here we introduce a well-formed-list. In this term a well-formed
list is a list containing only non-empty lists as elements. All
elements of the latter lists must be strings. The input list must be a
list containing symbols, strings, numbers and lists. The latter lists
may only consist of symbols, strings and numbers. Function
[[make-well-formed-list]] transforms ist argument into a well-formed
list if possible and signals an error, if its argument is of wrong
type or structure.

<<Helpers>>=
(defun make-well-formed-list (attr-list)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (list (stringify x)))
                    ((listp x)
                       (map-to-strings x))))
          attr-list))

(defun map-to-strings (slist)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (stringify x))
                    ((listp  x)
                       (error "nesting level too deep !"))
                    (t (error "~S is not a string !" x))))
          slist))
@ %def make-well-formed-list map-to-strings

<<Export-list of submodule \module{intface}>>=
(export '(stringify list-of-strings-p
          make-well-formed-list map-to-strings))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{A special reader syntax for quoted strings}

The following reader function simulates the reading of strings like C
does. Its quote-symbol is `\texttt{~}' which quotes every character
appearing next in the input stream. If the next character is
`\texttt{n}' it is converted to a \texttt{Newline}-character, the
sequence `\texttt{~t} will be substituted by the
\texttt{Tab}-character, `\texttt{~~}' to `\texttt{~}' and
`\texttt{~"}' to `\texttt{"}'.

Additionally this reader-function knows the correct values of the
special characters `\texttt{~b}' and `\texttt{~e}'.  The encoding of
these special characters declares `\texttt{~b}' to be the character
no.~1, and `\texttt{~e}' to be character no.~255 in the
ISO-Latin-alphabet. We can't choose character no.~0 for `\texttt{~b}'
since the sort-key generation is performed via the C-library
\module{ORDRULES} in which character no.~0 is used as the
string-termination character.

<<String reader function>>=
(defun c-string-reader (stream char)
  (declare (ignore char))
  (let ((ch nil)
        (str (make-array 32
                         :element-type
			 #+CLISP 'string-char
			 #-CLISP 'base-char
                         :adjustable t
                         :fill-pointer 0)))
    (loop
      (setq ch (read-char stream t #\Newline t))
      (case ch
        (#\" (let ((nextch (read-char-no-hang stream t #\Newline t)))
               (when nextch
                 (unread-char nextch stream)
                 (case nextch
                   (#\Newline)
                   (#\t)
                   (#\Space)
                   (#\))
                   (t (nraw "~&Possible read-error due to ill-formed string \"~A\" ~S"
                            str *))))
               (return str)))
        (#\~ (setq ch (read-char stream t #\Newline t))
             (case ch
               (#\n (vector-push-extend #\Newline str))
               (#\t (vector-push-extend #\Tab str))
               (#\b (vector-push-extend (character   1) str))
               (#\e (vector-push-extend (character 255) str))
               (t   (vector-push-extend ch str))))
        (t (vector-push-extend ch str))))))

(set-macro-character #\" #'c-string-reader nil *indexstyle-readtable*)

#|
(let ((x #\Null))
  (loop for i from 1 to 255
        do (progn (print (character i))
                  (when (char>= x (character i))
                    (print "Whee!"))
                  (setq x (character i)))))
|#
@ %def c-string-reader

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Typechecking parameters}

<<check :hierdepth>>=
(when (not (numberp hierdepth))
  (error "~S is not a number! in ~S~%" hierdepth whole))
@

<<check name>>=
((null name)
 (error "missing argument <name> in `~S' !" whole))
((not (or (symbolp name) (stringp name)))
 (error "~S is not a symbol or a string in `~S' !" name whole))
@

\subsubsection{Alphabets}

We introduce two different forms of alphabet definitions. The first
macro does \emph{not} expand the [[string-list]]-argument, whereas the
second form \emph{does} so. The second form is intended to define
alphabets via \Lisp-expressions and should only be used by an
experienced user.

<<Defining alphabets>>=
(defmacro define-alphabet (&whole whole &optional name string-list)
  (cond <<check name>>
        ((not (listp string-list))
           (error "missing argument <string-list> !"))
        ((not (list-of-strings-p string-list))
           (error "~S is not a list of strings" string-list))
        (t `(LET ((NAME (STRINGIFY ',name)))
             (WHEN (LOOKUP-BASETYPE *indexstyle* NAME)
               (NRAW "redefining alphabet `~S'" NAME))
             (ADD *indexstyle* (MAKE-ALPHABET NAME ',string-list))))))

(defmacro define-alphabet* (&whole whole &optional name string-list)
  (cond <<check name>>
        ((not (listp string-list))
           (error "missing argument <string-list> !"))
        (t (let ((scar (car string-list)))
             (if (and (symbolp scar) (fboundp scar))
                 `(LET ((NAME (STRINGIFY ',name))
                        (STRING-LIST ,string-list)) #| evaluates string-list |#
                   (UNLESS (LIST-OF-STRINGS-P STRING-LIST)
                     (ERROR "~S is not a list of strings" STRING-LIST))
                   (WHEN (LOOKUP-BASETYPE *indexstyle* NAME)
                     (NRAW "redefining alphabet `~S'" NAME))
                   (ADD *indexstyle* (MAKE-ALPHABET NAME STRING-LIST))))))))
@ %def define-expand-alphabet define-expand-alphabet*


\subsubsection{Enumerations}

<<Defining enumerations>>=
(defmacro define-enumeration (&whole
                              whole
                              &optional
                              name prefix-match-func base-alphabet)
  (cond <<check name>>
        ((null prefix-match-func)
           (error "missing argument <prefix-match-function> !"))
        (t (let* ((name   (stringify name))
                  (symbol (make-symbol
                           (concatenate 'string "ENUMERATION-" name))))
             `(LET () #| PROGN instead of LET () yields a runtime error !? |#
               (IF (LOOKUP-BASETYPE *indexstyle* ,name)
                   (NRAW "redefining alphabet `~S'" ,name)
                   (PROGN
                     (DEFCLASS ,symbol (ENUMERATION) ())
                     (ADD *indexstyle*
                          (MAKE-ENUMERATION ',symbol ,name ,base-alphabet))))
               (DEFMETHOD PREFIX-MATCH ((STR STRING) (ENUM ,symbol))
                 (FUNCALL ,prefix-match-func STR)))))))
@ %def define-enumeration

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Location-classes}

\paragraph{Structured location-classes}

<<Defining location-classes>>=
(defmacro define-location-class (&whole whole &rest args)
  (destructuring-switch-bind (name
                              layer-list
                              &key
                              (min-range-length *default-minimum-range-length*)
                              (hierdepth 0) ;no hierarchies are to be formed
                              &switch
                              (var :var))
      args
    (cond
      ((null name)
         (error "missing argument <name> in~%~S" whole))
      ((null layer-list)
         (error "missing argument <layer-list> in~%~S" whole))
      ;;((not (list-of-strings-p layer-list))
      ;;  (error "~S is not a list of strings in~%~S" layer-list whole))
      ((not (numberp hierdepth))
         (error "~S is not a number! in~%~S" hierdepth whole))
      ((not (or (numberp   min-range-length)
                (eql 'none min-range-length)))
         (error "~S must be a number or the keyword `none' in~%~S"
                min-range-length whole))
      (t (when (eql 'none min-range-length)
           (setq min-range-length 0))
         `(LET ((NAME (STRINGIFY ',name))
                (LAYERS (BUILD-LOCCLASS-LAYERS ',layer-list ',whole)))
           ;;(GOL T "~&define-location-class: ~S" LAYERS)
           (COND ((LOOKUP-CROSSREF-CLASS *indexstyle* NAME)
                    (OOPS "replacing cross-reference-class `~S' is not allowed !"
                          NAME))
                 (t (WHEN (LOOKUP-LOCATION-CLASS *indexstyle* NAME)
                      (NRAW "redefining location-reference-class `~S' !" NAME))
                    (ADD *indexstyle*
                         ,(if var
                              `(CHECKED-MAKE-VAR-LOCATION-CLASS NAME LAYERS
                                ,min-range-length ,hierdepth)
                              `(CHECKED-MAKE-STANDARD-LOCATION-CLASS NAME LAYERS
                                ,min-range-length ,hierdepth))))
                 ))))))
@ %def define-location-class

<<Defining location-classes>>=
(defun build-locclass-layers (layers whole)
  (let ((res-list '()))
    (loop
      ;;(gol t "~&build-locclass-layers: ~S" layers)
      (when (endp layers) (return (nreverse res-list)))
      (cond ((eql :sep (car layers))
               (setq layers (cdr layers))
               (if (endp layers)
                   (error "Reached end of list in~%~S" whole)
                   (push (make-loccls-separator (stringify (car layers)))
                         res-list)))
            (t (let* ((layer (stringify (car layers)))
                      (basetype (lookup-basetype *indexstyle* layer)))
                 (if basetype
                     (push (make-loccls-layer basetype) res-list)
                     (error "Unknown basetype ~S in~%~S" layer whole)))))
      (setq layers (cdr layers)))))
@ %def build-locclass-layers


\paragraph{Cross-reference location-classes}

<<Defining location-classes>>=
(defmacro define-crossref-class (&whole whole &rest args)
  (destructuring-switch-bind (name
                              &switch (verified :unverified))
      args
    (cond <<check name>>
      (t `(LET ((NAME (STRINGIFY ',name)))
           (cond ((LOOKUP-LOCATION-CLASS *indexstyle* NAME)
                    (OOPS "replacing location-reference-class `~S' is not allowed !"
                          NAME))
                 (t (WHEN (LOOKUP-CROSSREF-CLASS *indexstyle* NAME)
                      (NRAW "redefining crossref-location-class `~S'" NAME))
                    (ADD *indexstyle*
                         ,(if verified
                              `(MAKE-UNVERIFIED-CROSSREF-LOCATION-CLASS NAME)
                              `(MAKE-VERIFIED-CROSSREF-LOCATION-CLASS NAME))))))))))
@ %def define-crossref-class


\paragraph{Defininig the order of location-classes}

<<Defining location-classes>>=
(defmacro define-location-class-order (olist)
  (cond ((not (listp olist))
           (error "missing argument <list> !"))
        ((not (list-of-strings-p olist))
           (error "~S is not a list of strings" olist))
        (t `(LET ((CTR 1))
             (MAPC #'(LAMBDA (NAME)
                       (LET* ((NEW-NAME (STRINGIFY NAME))
                              (LOCCLS
                               (CDR (LOOKUP-LOCATION-CLASS *indexstyle*
                                                           NEW-NAME))))
                         (INCF CTR)
                         (COND (LOCCLS (SET-ORDNUM CTR LOCCLS))
                               (t (OOPS "unknown location-class `~S'"
                                        NEW-NAME)))))
              ',olist)))))
@ %def define-location-class-order


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Attributes}
\label{sec:intface:attributes}

<<Defining attributes>>=
(defmacro define-attributes (&whole whole &optional attr-list)
  (cond ((null attr-list)
           (error "missing argument <attribute-list> in~&~S" whole))
        (t (let* ((wf-attr-list (make-well-formed-list attr-list))
                  (plain-list (apply #'concatenate 'list wf-attr-list))
                  )
             `(PROGN
               (MAPCAR
                #'(LAMBDA (CATATTR)
                    (IF (LOOKUP-CATATTR *indexstyle* CATATTR)
                        (NRAW "ignoring redefinition of attribute ~S in~&~S"
                              CATATTR ',whole)
                        (ADD *indexstyle*
                             (MAKE-CATEGORY-ATTRIBUTE CATATTR))))
                ',plain-list)
               (INITIALIZE-CATEGORY-ATTRIBUTES ',wf-attr-list *indexstyle*))
             ))))
@ %def define-attributes

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Keyword sort- and merge-rules}
\label{sec:keyword-rules}

We have three different forms of keyword rules which can be described by
a pair (\term{pattern}, \term{replacement}). The first one is the
so-called \term{string-substitution} and is expressed by a pair of
strings. If the pattern string matches the substring is substituted by
its replacement.

The second form is described as a character substitution. If the given
pattern and replacement string are both of length 1, we assume that a
general character substitution is wanted.

The last form is defined by a regular expression and a replacement
template. The regexp describes the pattern that should be replaced by
the replacement if a valid match was found.

For the implementation of the latter We use the GNU
regular-expression-library [[rx]] for our implementation. This library
is used by the library [[ordrules]], which is a foreign library
implemented in C. The \Lisp-system must be extended by both libraries.
The feature form [[#+:ORDRULES]] is used to include the regular
expression support. Since the user-interface defined in the standard
distribution allows no low-level access we need to explicitly import
the neccessary functions ourselves. The following chunk is included in
the root-chunk of module \module{idxstyle}.

<<Use [[ordrules]]-package if available>>=
(eval-when (eval load compile)
  (when (find-package "ORDRULES")
    (pushnew :ORDRULES *features*)))
@
%%
\begin{arguments}{replacement}
  \item[pattern] describes the pattern of the substitution rule. It
    must be specified as a string.
  \item[replacement] describes the replacement. It is also a string.
  \item[isreject] is a boolean value that describes if the matching is
    also possible on substituted patterns.
\end{arguments}
%%
For more information see the description of the [[ordrules]]-package.

<<Defining keyword rules>>=
#+:ORDRULES
(defmacro merge-rule (&whole whole &rest args)
  (destructuring-switch-bind (pattern
                              replacement
                              &switch
                              (again           :again)
                              (string          :string)
                              (extended-regexp :eregexp)
                              (basic-regexp    :bregexp))
      args
    (cond ((null pattern)
             (error "missing argument <pattern> !"))
          ((or (and string extended-regexp) (and string basic-regexp)
               (and extended-regexp basic-regexp))
             (error "~&Only one of (:string :bregexp :eregexp) allowed in:~&~S !"
                    whole))
          ((null replacement)
             (error "~&Missing argument <replacement> in:~&~S!" whole))
          (t `(PROGN
               (UNLESS
                   (ZEROP
                    (ORDRULES:ADD-KEYWORD-MERGE-RULE ,pattern ,replacement
                                                     ,(if again 1 0)
                                                     ,(cond (string 1)
                                                            (basic-regexp 2)
                                                            (extended-regexp 3)
                                                            (t 0))))
                 (OOPS "~&Wrong regular expression ~S in:~%~S." ',pattern ',whole))
               (FLUSH-ORDRULES-MESSAGE-BUFFER))))))

#-:ORDRULES
(defmacro merge-rule (&rest args)
  (declare (ignore args))
  (oops "merge-rule not supported! ignoring definition"))
@ %def merge-rule

<<Defining keyword rules>>=
#+:ORDRULES
(defmacro sort-rule (&whole whole &rest args)
  (destructuring-switch-bind (pattern
                              replacement
                              &switch
                              (again           :again)
                              (string          :string)
                              (extended-regexp :eregexp)
                              (basic-regexp    :bregexp))
      args
    (cond ((null pattern)
             (error "missing argument <pattern> !"))
          ((or (and string extended-regexp) (and string basic-regexp)
               (and extended-regexp basic-regexp))
             (error "~&Only one of (:string :bregexp :eregexp) allowed in:~&~S !"
                    whole))
          ((null replacement)
             (error "missing argument <replacement> !"))
          (t `(PROGN
               (UNLESS
                   (ZEROP
                    (ORDRULES:ADD-KEYWORD-SORT-RULE ,pattern ,replacement
                                                    ,(if again 1 0)
                                                    ,(cond (string 1)
                                                           (basic-regexp 2)
                                                           (extended-regexp 3)
                                                           (t 0))))
                 (OOPS "~&Wrong regular expression ~S in:~%~S." ',pattern ',whole))
               (FLUSH-ORDRULES-MESSAGE-BUFFER))))))

#-:ORDRULES
(defmacro sort-rule (&rest args)
  (declare (ignore args))
  (oops "sort-rule not supported! ignoring definition"))

(defun flush-ordrules-message-buffer ()
  #+:ORDRULES
  (when (and *mappings-trace* ordrules::*message-logging*)
    (gol t "~A" ordrules::*message-buffer*)
    (setq ordrules::*message-buffer-ptr* 0)))
@ %def sort-rule

<<Export-list of submodule \module{intface}>>=
(export 'flush-ordrules-message-buffer)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Location Reference Rules}

<<Defining locref rules>>=
(defmacro merge-to (&whole whole &rest args)
  (destructuring-switch-bind (from to &switch drop)
      args
    (let ((from-attr (lookup-catattr *indexstyle* from))
          (to-attr   (lookup-catattr *indexstyle* to)))
      (cond ((not from-attr)
               (nraw "`~S' is not a known attribute in:~&~A" from whole))
            ((not to-attr)
               (nraw "`~S' is not a known attribute in:~&~A" to whole))
            (t (if drop
                   `(ADD-DROP-IF-MERGED-RULE *INDEXSTYLE*
                     ,from-attr ,to-attr)
                   `(ADD-MERGE-RULE *INDEXSTYLE*
                     ,from-attr ,to-attr)))))))
@ %def merge-to

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Letter groups}

Letter group are intended to group indexentries together to be able to
associate a special markup for each letter group. For example, one
wants to define a group named ``Symbols'' and all indexentries
describing symbols should be put into this group. Usually letter
groups are defined via the prefic of the indexentries' keyword. The
sorting of the letter groups may be different from the sorting of the
\term{sort-key} of the indexentries. To specify a sort-order on the
letter groups we decided to use a total order that can be defined with
relations between letter group. Such a specification might be `b' is
\emph{before} `c' and \emph{after} `a'. The user defines a partial
order that must result in exactly one possible total order. This
principle was chosen to overcome the old concept of assigning integer
numbers as the group identifier. This concept proved to be very
incomfortable and not easy to be understood. The partial order
approach now allows to extend predefined modules such as one
specifying the letter groups for latin-based alphabets with
language-specific letters that may be inserted among the existing
groups without the need to consider the group-numbers.

The command \texttt{define-letter-group} now comes in a general form
that allows to define a \emph{group-name} and a list of prefixes that
should be mapped onto this group. Further prefixes that appear in more
definitions for the same group are simply added to the list of
prefixes.

<<Defining letter groups>>=
(defmacro define-letter-group
    (&whole whole name &key prefixes before after)
  (cond <<check name>>
        ((and before
              (not (lookup-letter-group-definition *indexstyle* before)))
           (error "~S does not name a letter group in~%~S" before whole))
        ((and after
              (not (lookup-letter-group-definition *indexstyle* after)))
           (error "~S does not name a letter group in~%~S" after whole))
        ((not (list-of-strings-p prefixes))
           (error "argument <prefixes> is not a list of strings in~%~S"
                  whole))
        (t `(LET ()
             (ADD-LETTER-GROUPS *INDEXSTYLE*
              ,name ',(or prefixes (list name))
              :BEFORE ,before :AFTER ,after)))))
@ %def define-letter-group

\no Additionally we define a convenience-macro that allows us to
define several letter groups at once.

<<Defining letter groups>>=
(defmacro define-letter-groups (&whole whole &optional letter-groups)
  (cond ((not (list-of-strings-p letter-groups))
           (error "~S is not a list of strings in~%~S" letter-groups whole))
        (t `(LET ()
             (ADD-LETTER-GROUPS *INDEXSTYLE*
              ,(car letter-groups) ',(list (car letter-groups)))
             ,@(let ((last (car letter-groups)))
                    (mapcar #'(lambda (letter-group)
                                (prog1
                                    `(ADD-LETTER-GROUPS *INDEXSTYLE*
                                      ,letter-group ',(list letter-group)
                                      :AFTER ,last)
                                  (setq last letter-group)))
                            (cdr letter-groups)))))))
@ %def define-letter-groups

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Loading more files}
\label{sec:intface:require}

<<Including files>>=
;;; we remove the inherited symbol and establish a new one
(eval-when (compile load eval)
  (shadow 'require))

(defmacro require (&rest args)
  (cond ((null args)
           (error "missing argument <filename> !"))
        ((not (stringp (car args)))
           (error "(require ~S): expected <filename> !" (car args)))
        (t `(LET ((FILENAME (STRINGIFY ',(car args))))
             (DO-REQUIRE FILENAME)))))

(defun do-require (filename)
  (let ((file (find-file filename)))
    (unless (member file *included-files* :test #'equalp)
      (push file *included-files*)
      (info "~&Loading module ~S..." filename)
      (watched-load file :echo t)
      (info "~&Finished loading module ~S.~%" filename))))

#|
(defun do-require (filename)
  (let ((file (find-file filename)))
    (unless (member file *included-files* :test #'equalp)
      (push file *included-files*)
      (info "~&Loading module ~S..." filename)
      (let ((*standard-output* (make-string-output-stream)))
        (handler-case
            (load file :verbose nil :echo t)
;         (stream-error (cond)
;                       (step
;                        (progn
;                          (oops*
;                            (simple-condition-format-string cond)
;                            (simple-condition-format-arguments cond))
;                          (exit))
;                        )
;                       )
          (error (condition)
                 (info "~&~%~A~%" ";;;;;;;;;;;;;;;;;;;;;;;;")
                 (info "~A~%"     ";; ERROR SECTION START")
                 (info "~%~A~%" (get-output-stream-string *standard-output*))
                 (info "~%~A~%"   ";; ERROR SECTION END")
                 (info "~A~%~%"   ";;;;;;;;;;;;;;;;;;;;;;;;")
                 (oops* (simple-condition-format-string    condition)
                        (simple-condition-format-arguments condition))
                 (error-exit))
          )
        )
      (info "~&Finished loading module ~S.~%" filename))))
|#
@ %def require do-require

\no Since the built-in [[load]] is not very clever when searching for
files we implement a function that is given a filename which may
contain absolute and relative pathnames. If it is an absolute pathname
we check if is availabe and load it, if possible. If it is a relative
pathname, we append the filename to all paths in
[[*xindy-load-paths*]] and check if we get an existing file. If we
find one we load it as usual.

<<Including files>>=
(defun find-file (filename)
  (let ((file (pathname filename)))
    (when (equal (file-namestring file) "")
      (error "~S is not a valid filename !" filename))
    (let ((found (some #'(lambda (path)
                           (and (probe-file (append-pathnames path file))))
                       *load-paths*)))
      (or found (error "Could not find file ~S !" filename)))))
@ %def find-file

<<Including files>>=
(defvar *wl-fmt* "~&~%Error in line ~S:~%~A~%")
(defun watched-load (filename
                     &key
                     (print *load-print*)
                     (if-does-not-exist t)
                     echo)
  (let ((stream (open (setq filename (pathname filename))
                      :direction
		      #+CLISP :input-immutable
		      #-CLISP :input
                      :element-type
		      #+CLISP 'string-char
		      #-CLISP 'base-char
                      :if-does-not-exist nil))
        (lineno 1))
    (if stream
        (let* ((load-stream (make-string-output-stream))
               (input-stream (if echo
                                 (make-echo-stream stream load-stream)
                                 stream
                                 ))
               (*load-pathname* (if (pathnamep filename) filename nil))
               (*load-truename* (if (pathnamep filename) (truename filename) nil))
               (*package* *package*)    ; *PACKAGE* binden
               (*readtable* *readtable*) ; *READTABLE* binden
               (end-of-file "EOF"))     ; einmaliges Objekt
          ;;(setq sys::*load-input-stream* input-stream)
          (block nil
            (unwind-protect
                 (tagbody weiter
                    (let* ((obj
                            (handler-case (read input-stream nil end-of-file)
                              (error (cond)
                                (when echo
                                  (let* ((str (get-output-stream-string load-stream))
                                         (cnt (count #\Newline str)))
                                    (info *wl-fmt* (+ cnt lineno) str)
                                    (oops* (simple-condition-format-string cond)
                                           (simple-condition-format-arguments cond))
                                    (error-exit))))))
                           (str (get-output-stream-string load-stream))
                           (cnt (count #\Newline str)))
                      (incf lineno cnt)
                      (when (eql obj end-of-file)
                        (return-from nil))
                      (setq obj
                            (multiple-value-list
                                (cond ((compiled-function-p obj) (funcall obj))
                                      ;;(compiling (funcall (compile-form obj nil nil nil nil nil)))
                                      (t (handler-case (eval obj)
                                           (error (cond)
                                             (info *wl-fmt* lineno str)
                                             (oops* (simple-condition-format-string cond)
                                                    (simple-condition-format-arguments cond))
                                             (error-exit)))
                                         (get-output-stream-string load-stream)
                                         ))))
                      (when print (when obj (print (first obj))))
                      )
                    (go weiter)
                    )
              (close stream) (close input-stream)
              ) )
          t)
        (if if-does-not-exist
            (error "A file with name ~A does not exist" filename)
            nil)
        ) ))
@ %def watched-load

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Setting the searchpath}
\label{sec:intface:searchpath}

The following chunks implement the searchpath.

<<Setting the searchpath>>=
(defmacro searchpath (&rest args)
  (cond ((null args)
           (error "missing argument <pathlist> !"))
        ((stringp (car args))
           `(SET-SEARCHPATH-BY-STRING ,(car args)))
        ((listp args)
           `(SET-SEARCHPATH ',(car args)))))

(defun set-searchpath-by-string (searchpath-str)
  (set-searchpath (string-to-searchlist searchpath-str)))

(defun string-to-searchlist (str)
  (let ((paths '())
        pos)
    (nreverse
     (loop (when (equalp str "")
             (return (push :default paths)))
           (setq pos (position #\: str))
           (if pos
               (progn
                 (push (subseq str 0 pos) paths)
                 (setq str (subseq str (1+ pos))))
               (return (push str paths)))))))

(defun set-searchpath (path-list)
  (setq *load-paths*
        (apply #'nconc
               (mapcar
                #'(lambda (elt)
                    (cond ((stringp elt)
                             (list (make-real-pathname elt)))
                          ((eq elt :default)
                             *default-load-paths*)
                          ((eq elt :last)
                             *load-paths*)
                          (t (oops "~&searchpath: invalid argument ~S in~%~S"
                                   elt path-list))))
                path-list))))
@ %def searchpath

\no The following function takes a string representing a pathname and
converts it into a pathname-object. Since the string represents a
directory in every case we first convert it with the function
[[pathname]] to a pathname-object. If the resulting pathname contains
a name-field indicating that the string was not a correct pathname (in
UNIX: the trailing [[/]] was missing) we create a new pathname by
adding the filename to the directory resulting in the corrected
pathname.

<<Setting the searchpath>>=
(defun make-real-pathname (pathname-str)
  (let* ((pn     (pathname pathname-str))
         (fname  (file-namestring pn)))
    (cond ((string/= fname "")
             (make-pathname :directory (append (pathname-directory pn)
                                               (list fname))))
          (t pn))))
@ %def make-real-pathname

\no The following function takes two pathnames and appends the second
one (if its a [[:relative]] one) to the first one. It creates a new
[[:directory]]-field and copies the [[name]]- and [[type]]-components
of the second argument. This function can therefore be used to take a
relative file- or directory-name and append it to an existing
directory. If the second directory name is an absolute filename we
return it immediately.

<<Setting the searchpath>>=
(defun append-pathnames (pn-dir pn-sub)
  (let ((dir-dir (pathname-directory pn-dir))
        (dir-sub (pathname-directory pn-sub)))
    (cond ((not (eq :relative (car dir-sub))) pn-sub)
          (t (make-pathname :directory (append dir-dir (cdr dir-sub))
                            :name (pathname-name pn-sub)
                            :type (pathname-type pn-sub))))))
@ %def append-pathnames


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Destructuring-switch-bind --- from Gabor Herr}

The following code was borrowed from Gabor Herr which he used in his
\textsf{ViEWS}-project. It is the heart of the interface macros.

One thing we have added is the following kludge:
[[destructuring-switch-bind]] preprocesses its arguments and calls
[[structuring-bind]] to process the remaining arguments. If an error
occurs in this situation we would not be able to print an error
message that prints the whole command that caused the problems. Thus,
we have added an handler around the [[destructuring-bind]]-call (see
below) and print an error message with the whole command. To make this
work we make the variable [[whole]] special such that all other
commands using [[des-sw-bd]] can use this feature with the [[&whole
whole]] mechanism as part of their macro-arguments.

<<Destructuring-switch-bind macro>>=
;;; $Id$
;;;----------------------------------------------------------------------

;;;
;;; util-lib                    LISP Utitlity Library
;;;
;;; (history at end)


;(provide 'util-lib)
;(in-package 'util-lib)

(defvar whole)
(eval-when (compile load eval)
  (export '(destructuring-switch-bind &switch whole)))

(defmacro destructuring-switch-bind (lambdalist expr . body)
  "Similar to 'destructuring-bind' but also allows switch options at the
end of LAMBDALIST with the following syntax:

  &switch { var | (var key [defval]) | (var ({ key }*) [defval]) }*

In all cases VAR will be accessible in BODY as a variable.

If only VAR is specified, it is bound to the keyword with the same
name, if that keyword occured in EXPR. Otherwise it is bound to NIL.

If both a VAR and KEY were specified, VAR will be bound to KEY, if KEY
occured in EXPR and to NIL otherwise.

If VAR and a list of KEYs were specified, VAR will be bound to the
first KEY, which occured in EXPR. If none of the KEYS occured within
EXPR, VAR will be bound to NIL.

If DEFVAL was specified, variable will be bound to DEFVAL instead of
NIL in cases where no switch keyword was found in EXPR.
"

  (let* ((switchlist (member '&switch lambdalist))

         ;; 'remove' switches from lambdalist
         (lambdalist (ldiff lambdalist switchlist))

         ;; drop &switch keyword
         (switches (when switchlist (cdr switchlist)))

         ;; construct bindings for each switch and collect valid
         ;; keywords in 'switchkeys'
         (switchkeys '())
         (bindings
          (mapcar
           #'(lambda (spec)
               (cond

                 ;; spec simply consists of VAR
                 ((symbolp spec)
                    (let ((key (intern (symbol-name spec) 'keyword)))
                      (push key switchkeys)
                      `(,spec (FIND ,key <DESTRUCTURING-SWITCH-FORM>))
                      ))

                 ;; spec is (VAR form)
                 ((and (listp spec) (>= (list-length spec) 2))
                    (let ((var (first spec))
                          (keyspec (second spec))
                          (defval (when (cddr spec) (third spec))))
                      (cond
                        ;; spec is (VAR (KEY1 KEY2 ...))
                        ((listp keyspec)
                           `(,var
                             (COND
                               ,@(mapcar
                                  #'(lambda (key)
                                      (push key switchkeys)
                                      `((FIND ,key <DESTRUCTURING-SWITCH-FORM>)
                                        ,key))
                                  keyspec)
                               (T ,defval))))

                        ;; spec is (VAR KEY)
                        (t
                           (push keyspec switchkeys)
                           ` (,var (OR
                                    (FIND ,keyspec <DESTRUCTURING-SWITCH-FORM>)
                                    ,defval)))
                        )))

                 ;; illegal spec
                 (t (error "~A is not a valid switch specifier." spec))
                 ))
           switches))
         )

    ;; construct the expansion form
    ` (LET ((<DESTRUCTURING-SWITCH-FORM> ,expr))
        (LET ,bindings
          (HANDLER-CASE
	      (DESTRUCTURING-BIND ,lambdalist
		  (SET-DIFFERENCE-KEEP-ORIGINAL-ORDER
		   <DESTRUCTURING-SWITCH-FORM>
		   ',switchkeys)
		,@body)
            (ERROR (COND)
	      (DECLARE (IGNORE COND))
	      (ERROR "~&Syntax Error in ~S." WHOLE)
	      )
            )
          )
        )
    ))

(defun set-difference-keep-original-order (set1 set2)
  (mapcan #'(lambda (elt)
	      (unless (member elt set2)
		(list elt)))
	  set1))

#|
(destructuring-switch-bind (name &rest args &key foo bar
                                 &switch
                                 on                     ; simple form
                                 (started :start)
                                 (speed (:fast :slow))
                                 (off :turn-off :turn-on) ; with switch key
                                 (choose (:one :two :three) :three))
                           '(width :foo 5 :bar 7 :on :turn-off :one)
  (list name foo bar args on started speed off choose))
|#
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{intface}>>=
;; $Id$

<<Destructuring-switch-bind macro>>
<<Helpers>>
<<String reader function>>
<<Defining alphabets>>
<<Defining enumerations>>
<<Defining location-classes>>
<<Defining attributes>>
<<Defining keyword rules>>
<<Defining letter groups>>
<<Defining locref rules>>
<<Including files>>
<<Setting the searchpath>>

<<User-interface-definitions>>

(eval-when (compile load eval)
  <<Export-list of submodule \module{intface}>>
  )
@

<<RCS-Identifier>>=
("intface" . "$Id$")
@


%% $Log$
%% Revision 1.27  1997/03/26 16:18:26  kehr
%% Several changes to make the source ANSI and X3J13 compliant.
%%
%% Revision 1.26  1997/03/26 14:04:57  kehr
%% Fixed a bug in (destructuring-switch-bind) that made the system fail on
%% Allegro CL. Bug did not occur in CLISP since (set-difference) keeps
%% the order of the first list there.
%%
%% Revision 1.25  1997/03/18 14:49:53  kehr
%% Checkin after the several changes. a) the definition of slot-accessor
%% macros in the whole source, b) the modifications suggested by Bernd
%% Raichle to make the source compatible with Allegro CL and c) a first
%% version of the new sorting scheme.
%%
%% Revision 1.24  1997/03/10 15:50:50  kehr
%% Corrected a bug in the macro (merge-to).
%%
%% Revision 1.23  1997/01/23 21:33:13  kehr
%% Reincorporated (merge-to) rule into indexstyle.
%%
%% Revision 1.22  1997/01/22 16:44:47  kehr
%% Replaced the (load ...) with the new (watched-load ...) that produces
%% a better error information in case of a broken indexstyle file.
%%
%% Revision 1.21  1997/01/17 16:42:11  kehr
%% Several changes for new version 1.1.
%%
%% Revision 1.20  1996/07/24  13:47:17  kehr
%% Fixed a bug in the definition of define-alphabet that caused a Lisp
%% stack overflow. A simple quote was forgotten in the macro-definition :-)
%%
%% Revision 1.19  1996/07/22  15:54:23  kehr
%% Replaced some of the oops-macros by nraw-macros.
%%
%% Revision 1.18  1996/07/22  11:43:31  kehr
%% Argument `none' can now be specified as argument to the
%% keyqword-argument :min-range-length of command `define-location-class'.
%% ----------------------------------------------------------------------
%%
%% Revision 1.17  1996/07/16  14:05:54  kehr
%% Checkin after all the changes to the `define-letter-group(s)' commands
%% have been made.
%%
%% Revision 1.16  1996/07/11  14:16:19  kehr
%% Complete Major checkin before changing the letter-groups.
%%
%% Revision 1.15  1996/07/03  18:41:42  kehr
%% Checkin after some modifications of the error-system and the loading of
%% indexstyle-modules have been made. Affects all modules.
%%
%% Revision 1.14  1996/06/24  09:12:29  kehr
%% Several changes in all Lisp-modules due to the new startup-module and
%% the implementation of the percentage bar appearing in the processing
%% phases.
%%
%% Revision 1.13  1996/06/03  10:01:15  kehr
%% Added support for treeing layered-location-references.
%%
%% Revision 1.12  1996/05/29  14:15:29  kehr
%% Complete checkin after the major changes in the markup. See ChangeLog
%% for details.
%%
%% Revision 1.11  1996/05/20  08:47:56  kehr
%% Major release of the modules locref, idxstyle and index.
%%
%% Revision 1.10  1996/05/09  11:49:35  kehr
%% Changes in all submodules, due to macro-expansion problems during
%% compilation.
%%
%% Revision 1.9  1996/04/30  09:26:40  kehr
%% Changes the adding of location-classes to an index. Old definitions
%% will now be removed if a new location-class with the same name is
%% added. The forall-location-classes iterator was rewritten. It is now
%% named map-location-class and its behaviour is now comparable to a
%% map-function with implicit removal of nil in the result-list.
%%
%% Revision 1.8  1996/04/29  08:37:34  kehr
%% Don't remember any changes.
%%
%% Revision 1.7  1996/03/28  16:46:35  kehr
%% Changed indexstule modules to work with the new foreign package `ordrules'.
%%
%% Revision 1.6  1996/03/13  16:50:49  kehr
%% Ok, here I am. Included support for regular expressions. Minor changes
%% in all other parts of this module. Made some tests but had some
%% problems with LISP stack overflow errors. Don't know where they came
%% from. We'll see. The next step is to implement the string replacement
%% mechanism and set up extensive tests. Maybe I can use the tests from
%% Henry Spencer's regexp library.
%%
%% Revision 1.5  1996/02/06  15:43:35  kehr
%% Added some code for define-alphabet. This code is buggy and must be
%% rewritten due to macro failures.
%%
%% Revision 1.4  1996/01/31  15:29:24  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.3  1995/12/19  10:58:50  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:28  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:26  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from
%% scratch.
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:

