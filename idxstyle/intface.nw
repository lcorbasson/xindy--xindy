%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    (idxstyle)
%% Submodule: user-interface to the indexstyle (intface)
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{user-interface}}

\subsection{Introduction}

This module contains all functions that are available in the user
interface of the indexstyle.


\subsection{Abstract Specification}


\subsubsection{Definition}


\subsubsection{Operation}



\subsection{Concrete Specification}

\subsubsection{Destructuring-switch-bind --- from Gabor Herr}

The following code was borrowed from Gabor Herr which he used in his
\textsf{ViEWS}-project. It is the heart of the interface macros.

<<Destructuring-switch-bind macro>>=
;;; $Id$
;;;----------------------------------------------------------------------

;;;
;;; util-lib                    LISP Utitlity Library
;;;
;;; (history at end)


;(provide 'util-lib)
;(in-package 'util-lib)

(export '(destructuring-switch-bind &switch))

(defmacro destructuring-switch-bind (lambdalist expr . body)
  "Similar to 'destructuring-bind' but also allows switch options at the
end of LAMBDALIST with the following syntax:

  &switch { var | (var key [defval]) | (var ({ key }*) [defval]) }*

In all cases VAR will be accessible in BODY as a variable.

If only VAR is specified, it is bound to the keyword with the same
name, if that keyword occured in EXPR. Otherwise it is bound to NIL.

If both a VAR and KEY were specified, VAR will be bound to KEY, if KEY
occured in EXPR and to NIL otherwise.

If VAR and a list of KEYs were specified, VAR will be bound to the
first KEY, which occured in EXPR. If none of the KEYS occured within
EXPR, VAR will be bound to NIL.

If DEFVAL was specified, variable will be bound to DEFVAL instead of
NIL in cases where no switch keyword was found in EXPR.
"

  (let* ((switchlist (member '&switch lambdalist))

         ;; 'remove' switches from lambdalist
         (lambdalist (ldiff lambdalist switchlist))

         ;; drop &switch keyword
         (switches (when switchlist (cdr switchlist)))

         ;; construct bindings for each switch and collect valid
         ;; keywords in 'switchkeys'
         (switchkeys '())
         (bindings
          (mapcar
           #'(lambda (spec)
               (cond

                 ;; spec simply consists of VAR
                 ((symbolp spec)
                    (let ((key (intern (symbol-name spec) 'keyword)))
                      (push key switchkeys)
                      `(,spec (FIND ,key <DESTRUCTURING-SWITCH-FORM>))
                      ))

                 ;; spec is (VAR form)
                 ((and (listp spec) (>= (list-length spec) 2))
                    (let ((var (first spec))
                          (keyspec (second spec))
                          (defval (when (cddr spec) (third spec))))
                      (cond
                        ;; spec is (VAR (KEY1 KEY2 ...))
                        ((listp keyspec)
                           `(,var
                             (COND
                               ,@(mapcar
                                  #'(lambda (key)
                                      (push key switchkeys)
                                      `((FIND ,key <DESTRUCTURING-SWITCH-FORM>)
                                        ,key))
                                  keyspec)
                               (T ,defval))))

                        ;; spec is (VAR KEY)
                        (t
                           (push keyspec switchkeys)
                           ` (,var (OR
                                    (FIND ,keyspec <DESTRUCTURING-SWITCH-FORM>)
                                    ,defval)))
                        )))

                 ;; illegal spec
                 (t (error "~A is not a valid switch specifier." spec))
                 ))
           switches))
         )

    ;; construct the expansion form
    ` (LET ((<DESTRUCTURING-SWITCH-FORM> ,expr))
        (LET ,bindings
          (DESTRUCTURING-BIND ,lambdalist
              (SET-DIFFERENCE <DESTRUCTURING-SWITCH-FORM>
                              ',switchkeys)
            ,@body))
        )
      ))


#|
(destructuring-switch-bind (name &rest args &key foo bar
                                 &switch
                                 on                     ; simple form
                                 (started :start)
                                 (speed (:fast :slow))
                                 (off :turn-off :turn-on) ; with switch key
                                 (choose (:one :two :three) :three))
                           '(width :foo 5 :bar 7 :on :turn-off :one)
  (list name foo bar args on started speed off choose))
|#
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{A specialized exporting mechanism}

We need a mechanism for importing only interface-definitions from this
package to other packages. Using [[export]] wouldn't be a good iead
since it imports too many symbols to the package running the indexer.
We define a symbol [[*user-interface-definitions*]] which is a
importable list of symbols.

It can be imported by other packages by calling
\begin{center}
  \texttt{(import idxstyle:*user-interface-definitions*)} .
\end{center}

<<User-interface-definitions>>=
(defparameter *user-interface-definitions*
  '(*indexstyle*
    *default-minimum-range-length*
    define-alphabet
    define-location-class
    define-attributes
    ))
@ %def *user-interface-definitions*

<<Export-list of submodule \module{intface}>>=
(export '*user-interface-definitions*)
(export *user-interface-definitions*)
@

\subsubsection{Global definitions}

The indexstyle itself will be initialised later after all functions are known.

<<Global indexstyle definitions>>=
(defparameter *indexstyle* nil)
(defparameter *default-minimum-range-length* 3)
@ %def *indexstyle* *default-minimum-range-length*

<<Global indexstyle initialisation>>=
(setq *indexstyle* (create-indexclass "default"))
@

\subsubsection{Helpers}

<<Helpers>>=
(defun stringify (name)
  (etypecase name
    (symbol (symbol-name name))
    (string name)
    (number (write-to-string name))))
@ %def stringify

<<Check functions>>=
(defun list-of-strings-p (x)
  (cond ((not (listp x)) nil)
        ((every #'(lambda (elt)
                    (or (stringp elt) (symbolp elt) (numberp elt)))
                x))))
@ %def list-of-strings-p

\subsubsection{Alphabets}

<<Defining alphabets>>=
(defmacro define-alphabet (&optional name string-list)
  (cond ((null name)
           (error "missing argument <name> !"))
        ((not (or (symbolp name) (stringp name)))
           (error "~A is not a symbol or a string" name))
        ((null string-list)
           (error "missing argument <string-list> !"))
        ((not (list-of-strings-p string-list))
           (error "~A is not a list of strings" string-list))
        (t `(LET ((NAME (STRINGIFY ',name)))
             (WHEN (LOOKUP-BASETYPE *indexstyle* NAME)
               (WARN "redefining alphabet `~A'" NAME))
             (ADD *indexstyle*
              (MAKE-ALPHABET NAME ',string-list))))))
@ %def define-alphabet


\subsubsection{Location-classes}

<<Defining location-classes>>=
(defmacro define-location-class (&rest args)
  (destructuring-switch-bind (name
                              layer-list
                              &key (min-range-length
                                    *default-minimum-range-length*)
                              &switch (var :var))
      args
    (cond ((null name)
             (error "missing argument <name> !"))
          ((null layer-list)
             (error "missing argument <layer-list> !"))
          ((not (list-of-strings-p layer-list))
             (error "~A is not a list of strings" layer-list))
          (t `(LET ((NAME (STRINGIFY ',name))
                    (LAYERS (MAPCAR #'(LAMBDA (X)
                                        (LET* ((LAYER (STRINGIFY X))
                                               (BASETYPE
                                                (LOOKUP-BASETYPE *indexstyle*
                                                                 LAYER)))
                                          (IF BASETYPE
                                              (MAKE-LOCCLS-LAYER BASETYPE)
                                              (MAKE-LOCCLS-SEPARATOR LAYER))))
                                    ',layer-list)))
               (WHEN (LOOKUP-LOCATION-CLASS *indexstyle* NAME)
                 (WARN "redefining location-class `~A'" NAME))
               (ADD *indexstyle*
                ,(if var
                     `(CHECKED-MAKE-VAR-LOCATION-CLASS NAME LAYERS
                       ,min-range-length)
                     `(CHECKED-MAKE-STANDARD-LOCATION-CLASS NAME LAYERS
                       ,min-range-length)))
               )))))
@ %def define-location-class

\subsubsection{Attributes}
\label{sec:intface:attributes}

<<Defining attributes>>=
(defmacro define-attributes (&optional attr-list)
  (cond ((null attr-list)
           (error "missing argument <attribute-list> !"))
        (t (let* ((wf-attr-list (make-well-formed-list attr-list))
                  (plain-list (apply #'concatenate 'list wf-attr-list))
                  )
             `(PROGN
               (MAPCAR #'(LAMBDA (CATATTR)
                           (IF (LOOKUP-CATATTR *indexstyle* CATATTR)
                               (WARN "ignoring redefinition of attribute `~A' !"
                                     CATATTR)
                               (ADD *indexstyle*
                                    (MAKE-CATEGORY-ATTRIBUTE CATATTR))))
                ',plain-list)
               (INITIALIZE-CATEGORY-ATTRIBUTES ',wf-attr-list *indexstyle*))
             ))))
@ %def define-attributes

\no Here we introduce a well-formed-list. In this term a well-formed
list is a list containing only non-empty lists as elements. All
elements of the latter lists must be strings. The input list must be a
list containing symbols, strings, numbers and lists. The latter lists
may only consist of symbols, strings and numbers. Function
[[make-well-formed-list]] transforms ist argument into a well-formed
list if possible and signals an error, if its argument is of wrong
type or structure.

<<Helpers>>=
(defun make-well-formed-list (attr-list)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (list (stringify x)))
                    ((listp x)
                       (map-to-strings x))))
          attr-list))

(defun map-to-strings (slist)
  (mapcar #'(lambda (x)
              (cond ((null x)
                       (error "empty lists are not allowed !"))
                    ((or (symbolp x) (stringp x) (numberp x))
                       (stringify x))
                    ((listp  x)
                       (error "nesting level too deep !"))
                    (t (error "~A is not a string !" x))))
          slist))
@ %def make-well-formed-list map-to-strings


\subsubsection{The submodule root}

<<Submodule \module{intface}>>=
;; $Id$

<<Destructuring-switch-bind macro>>
<<Defining alphabets>>
<<Defining location-classes>>
<<Defining attributes>>
<<Helpers>>
<<Check functions>>

<<User-interface-definitions>>

<<Export-list of submodule \module{intface}>>
@

<<RCS-Identifier>>=
("intface" . "$Id$")
@


%% $Log$
%% Revision 1.6  1996/03/13 16:50:49  kehr
%% Ok, here I am. Included support for regular expressions. Minor changes
%% in all other parts of this module. Made some tests but had some
%% problems with LISP stack overflow errors. Don't know where they came
%% from. We'll see. The next step is to implement the string replacement
%% mechanism and set up extensive tests. Maybe I can use the tests from
%% Henry Spencer's regexp library.
%%
%% Revision 1.5  1996/02/06  15:43:35  kehr
%% Added some code for define-alphabet. This code is buggy and must be
%% rewritten due to macro failures.
%%
%% Revision 1.4  1996/01/31  15:29:24  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.3  1995/12/19  10:58:50  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:28  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:26  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from
%% scratch.
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:

