%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    (idxstyle)
%% Submodule: user-interface to the indexstyle (intface)
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{user-interface}}

\subsection{Introduction}

This module contains all functions that are available in the user
interface of the indexstyle.


\subsection{Abstract Specification}


\subsubsection{Definition}


\subsubsection{Operation}



\subsection{Concrete Specification}

\subsubsection{Destructuring-switch-bind --- from Gabor Herr}

The following code was borrowed from Gabor Herr which he used in his
\textsf{ViEWS}-project. It is the heart of the interface macros.

<<Destructuring-switch-bind macro>>=
;;; $Id$
;;;----------------------------------------------------------------------

;;;
;;; util-lib                    LISP Utitlity Library
;;;
;;; (history at end)


;(provide 'util-lib)
;(in-package 'util-lib)

(export '(destructuring-switch-bind &switch))

(defmacro destructuring-switch-bind (lambdalist expr . body)
  "Similar to 'destructuring-bind' but also allows switch options at the
end of LAMBDALIST with the following syntax:

  &switch { var | (var key [defval]) | (var ({ key }*) [defval]) }*

In all cases VAR will be accessible in BODY as a variable.

If only VAR is specified, it is bound to the keyword with the same
name, if that keyword occured in EXPR. Otherwise it is bound to NIL.

If both a VAR and KEY were specified, VAR will be bound to KEY, if KEY
occured in EXPR and to NIL otherwise.

If VAR and a list of KEYs were specified, VAR will be bound to the
first KEY, which occured in EXPR. If none of the KEYS occured within
EXPR, VAR will be bound to NIL.

If DEFVAL was specified, variable will be bound to DEFVAL instead of
NIL in cases where no switch keyword was found in EXPR.
"

  (let* ((switchlist (member '&switch lambdalist))

         ;; 'remove' switches from lambdalist
         (lambdalist (ldiff lambdalist switchlist))

         ;; drop &switch keyword
         (switches (when switchlist (cdr switchlist)))

         ;; construct bindings for each switch and collect valid
         ;; keywords in 'switchkeys'
         (switchkeys '())
         (bindings
          (mapcar
           #'(lambda (spec)
               (cond

                 ;; spec simply consists of VAR
                 ((symbolp spec)
                    (let ((key (intern (symbol-name spec) 'keyword)))
                      (push key switchkeys)
                      `(,spec (FIND ,key <DESTRUCTURING-SWITCH-FORM>))
                      ))

                 ;; spec is (VAR form)
                 ((and (listp spec) (>= (list-length spec) 2))
                    (let ((var (first spec))
                          (keyspec (second spec))
                          (defval (when (cddr spec) (third spec))))
                      (cond
                        ;; spec is (VAR (KEY1 KEY2 ...))
                        ((listp keyspec)
                           `(,var
                             (COND
                               ,@(mapcar
                                  #'(lambda (key)
                                      (push key switchkeys)
                                      `((FIND ,key <DESTRUCTURING-SWITCH-FORM>)
                                        ,key))
                                  keyspec)
                               (T ,defval))))

                        ;; spec is (VAR KEY)
                        (t
                           (push keyspec switchkeys)
                           ` (,var (OR
                                    (FIND ,keyspec <DESTRUCTURING-SWITCH-FORM>)
                                    ,defval)))
                        )))

                 ;; illegal spec
                 (t (error "~A is not a valid switch specifier." spec))
                 ))
           switches))
         )

    ;; construct the expansion form
    ` (LET ((<DESTRUCTURING-SWITCH-FORM> ,expr))
        (LET ,bindings
          (DESTRUCTURING-BIND ,lambdalist
              (SET-DIFFERENCE <DESTRUCTURING-SWITCH-FORM>
                              ',switchkeys)
            ,@body))
        )
      ))


#|
(destructuring-switch-bind (name &rest args &key foo bar
                                 &switch
                                 on                     ; simple form
                                 (started :start)
                                 (speed (:fast :slow))
                                 (off :turn-off :turn-on) ; with switch key
                                 (choose (:one :two :three) :three))
                           '(width :foo 5 :bar 7 :on :turn-off :one)
  (list name foo bar args on started speed off choose))
|#
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Alphabets}

<<Defining alphabets>>=
(defmacro define-alphabet (name string-list)
  (cond ((or (symbolp name) (stringp name))
	   (t (error "~A is not a symbol or a string")))))
@ %def define-alphabet


<<Export-list of submodule \module{intface}>>=
@

\subsubsection{Location-classes}

<<Defining location-classes>>=
(defmacro define-location-class (name &rest args)
  (destructuring-switch-bind (layer-list
			      &switch
			      (var :var)
			      (min :min-range-length))
      args
    (check-type layer-list list)
    `(print (list ',layer-list (quote ,name) ,var ,min))))
@



\subsubsection{The submodule root}

<<Submodule \module{intface}>>=
;; $Id$

<<Destructuring-switch-bind macro>>

<<Export-list of submodule \module{intface}>>
@

<<RCS-Identifier>>=
("intface" . "$Id$")
@


%% $Log$
%% Revision 1.4  1996/01/31 15:29:24  kehr
%% Made a lot of modifications to the whole module. Currently I'm working
%% on the implementation of the indexstyle-interface.
%%
%% Revision 1.3  1995/12/19  10:58:50  kehr
%% Complete restructuring.
%%
%% Revision 1.2  1995/12/15  17:08:28  kehr
%% Rewrote module compilation with noweb and clisp.
%%
%% Revision 1.1  1995/12/07  18:14:26  kehr
%% Renamed module `idxclass' to 'idxstyle'. Resturcturing module from scratch.
%%

%% Local Variables:
%% mode: latex
%% TeX-master: t
%% End:

