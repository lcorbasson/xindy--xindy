%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    markup
%% Submodule: markup
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{markup}}

\subsection{Introduction}

As already described in the module preface this module implements the
markup-process.


\subsection{Abstract Specification}

The markup algorithm traverses the index data structure in in-order.
Each node contains a \emph{open-} and \emph{close-}markup description
which are triggered when the node is entered or left. The leaves of
the tree emit the actual information stored in the index.

To allow a fine-grained user-interface we also keep track of the
recursion level when walking through recursively defined parts of the
data structure (i.e.\ on entering the topmost indexentry we set its
\emph{depth} to zero and on entering his subentries we increment the
depth by one for these entries, and so on\ldots).

\subsubsection{Definition}


\subsubsection{Operation}


\subsection{Concrete Specification}


\subsubsection{Markup}

The markup-stream is stored in the global variable
[[*markup-output-stream*]]. All stream primitives \emph{must} use this
stream for output.

To help the user learning the markup-system we define a boolean toggle
named [[*markup-verbose-mode*]]. When turned on the predefined
default-methods print a identifier describing their markup-state,
otherwise these methods don't print anything.  Additionally these
identifiers are placed between the strings [[*markup-verbose-open*]]
and [[*markup-verbose-close*]], allowing the wrapping into a
typsetting macro that actually expands to something else (maybe
nothing).

<<Markup definitions>>=
(defparameter *markup-output-stream* *standard-output*)
(defparameter *markup-verbose-mode*  nil)
(defparameter *markup-verbose-open*  "<")
(defparameter *markup-verbose-close* ">")
@ %def *markup-output-stream*

<<Export-list of submodule \module{markup}>>=
(export '(*markup-output-stream*
          *markup-verbose-mode*
          *markup-verbose-open*
          *markup-verbose-close*))
@

\paragraph{Markup primitives}

The following primitives can be used for the implementation of the
markup algorithm.

<<Markup primitives>>=
(defun markup-string (str)
  (declare (inline))
  (write-string str *markup-output-stream*))
@ %def markup-string

\no This function can be used to implement the default-markup when
verbose-mode is turned on.

<<Markup primitives>>=
(defun markup-default (str &optional number)
  (declare (inline))
  (when *markup-verbose-mode*
    (markup-string *markup-verbose-open*)
    (markup-string str)
    (when number
      (markup-string "-")
      (write number :stream *markup-output-stream*))
    (markup-string *markup-verbose-close*)))
@ %def markup-default

\no The following macro is a convenience tool to express the markup of
lists at a very high level. The list [[some-list]] contains elements
that need to be processed. The [[open/close-body]] keyword-arguments
define code that is processed when \emph{opening} and \emph{closing}
the list, [[elt-body]] id processed for each element in turn and
[[sep-body]] is used to separate the first from the second element,
the second from the third, and so on until the $n$-1-th to the $n$-th.

<<Markup primitives>>=
(defmacro markup-list (some-list
                       &key
                       (identifier 'nil)
                       (elt-body   'nil) (sep-body 'nil)
                       (open-body 'nil)  (close-body 'nil))
  `(PROGN
    ,(when open-body `,open-body)
    (LET ((LIST-END (CAR (LAST ,some-list))))
      (DO ((SLIST ,some-list (CDR SLIST)))
          ((ENDP SLIST))
        (LET ((,identifier (CAR SLIST)))
          ,elt-body
          ,(if sep-body
               `(UNLESS (EQL ,identifier LIST-END)
                 ,sep-body)))))
    ,(when close-body close-body)))
@  %def markup-list

\no The following example demonstates its expansion:

<<Markup primitives>>=
#|
(macroexpand '(markup-list '(1 2 3) :identifier FOO
               :open-body  (print "open")
               :close-body (print "close")
               :elt-body   (print FOO)
               :sep-body   (print ",")))

expands to

(PROGN (PRINT "open")
  (LET ((LIST-END (CAR (LAST '(1 2 3)))))
    (DO ((SLIST '(1 2 3) (CDR SLIST))) ((ENDP SLIST))
      (LET ((FOO (CAR SLIST))) (PRINT FOO)
        (UNLESS (EQL FOO LIST-END) (PRINT ","))
  ) ) )
  (PRINT "close")
) ;
T
|#
@

<<Export-list of submodule \module{markup}>>=
(export '(markup-string markup-list))
@

\paragraph{Index markup}

The markup of an index currently consits of the open/close markups and
the markup of the list of all indexentries.

\begin{TODO}
  \item This must be changed when implementing the \emph{letter groups}.
\end{TODO}

<<Index markup>>=
(defmethod markup-index ((idx base-index))
  (markup-index-open  idx)
  (markup-list (get-entry-list idx)
               :identifier IDXENT #| the identifier to use in the expansion |#
               :open-body  (markup-indexentry-list-open  0 #|initial depth:=0|#)
               :elt-body   (markup-indexentry (cdr IDXENT) 0)
               :sep-body   (markup-indexentry-list-sep   0)
               :close-body (markup-indexentry-list-close 0))
  (markup-index-close idx))

(defmethod markup-index-open ((idx base-index))
  (markup-default "INDEX:OPEN"))

(defmethod markup-index-close ((idx base-index))
  (markup-default "INDEX:CLOSE"))
@ %def markup-index


\paragraph{Indexentry markup}

The parts of the indexentry being relevant for markup are the keyword,
the location-refererences and the subentries. Since the
location-references are actually location-class-groups we have 3
subtargets for an indexentry markup.

<<Indexentry markup>>=
(defmethod markup-indexentry ((idxent indexentry)
                              (depth number))
  (let ((new-depth  (1+ depth)))
    (markup-indexentry-open depth)

    (let ((print-key (get-print-key idxent)))
      (markup-list (or print-key (get-main-key idxent))
                   :identifier KEYWORD
                   :open-body  (markup-keyword-open  new-depth)
                   :elt-body   (markup-string        KEYWORD)
                   :sep-body   (markup-keyword-sep   new-depth)
                   :close-body (markup-keyword-close new-depth)))

    (markup-locclass-grps (get-locrefs idxent))

    (let ((subentries (get-subentries idxent)))
      (when subentries
        (markup-list subentries
                     :identifier IDXENT
                     :open-body  (markup-indexentry-list-open   new-depth)
                     :elt-body   (markup-indexentry IDXENT new-depth)
                     :sep-body   (markup-indexentry-list-sep    new-depth)
                     :close-body (markup-indexentry-list-close  new-depth))))

    (markup-indexentry-close depth)))
@ %def markup-indexentry

<<Indexentry markup>>=
(defmethod markup-keyword-open ((depth number))
  (declare (ignore depth))
  (markup-default "KEYWORD:OPEN"))

(defmethod markup-keyword-sep ((depth number))
  (declare (ignore depth))
  (markup-default "KEYWORD:SEP"))

(defmethod markup-keyword-close ((depth number))
  (declare (ignore depth))
  (markup-default "KEYWORD:CLOSE"))
@ %def markup-keyword-*

<<Indexentry markup>>=
(defmethod markup-indexentry-open ((depth number))
  (declare (ignore depth))
  (markup-default "IDXENT:OPEN"))

(defmethod markup-indexentry-close ((depth number))
  (declare (ignore depth))
  (markup-default "IDXENT:CLOSE"))
@ %def markup-indexentry-*

<<Indexentry markup>>=
(defmethod markup-indexentry-list-open ((depth number))
  (declare (ignore depth))
  (markup-default "IDXENT-LST:OPEN"))

(defmethod markup-indexentry-list-sep ((depth number))
  (declare (ignore depth))
  (markup-default "IDXENT-LST:SEP"))

(defmethod markup-indexentry-list-close ((depth number))
  (declare (ignore depth))
  (markup-default "IDXENT-LST:CLOSE"))
@ %def markup-indexentry-list-*



\paragraph{Indexentry markup}

<<Location-class-group markup>>=
(defmethod markup-locclass-grps (x)
  (print x))
@

\subsubsection{The module root}

<<*>>=
;; $Id$

(in-package "MARKUP")
(provide "MARKUP")

(eval-when (eval compile load)
  (use-package "CLOS")
  (use-package "XP")
  (require "base")
  (use-package "BASE")
  (require "index")
  (use-package "INDEX"))

<<Submodule \module{markup}>>

<<Pretty-printing>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))
@

\subsubsection{The submodule root}

<<Submodule \module{markup}>>=
;; $Id$

<<Markup definitions>>
<<Markup primitives>>
<<Indexentry markup>>
<<Index markup>>
<<Location-class-group markup>>

<<Export-list of submodule \module{markup}>>
@

<<RCS-Identifier>>=
("markup" . "$Id$")
@

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
@


%% $Log$
%% Revision 1.3  1996/04/29 08:38:39  kehr
%% Started to implement teh new `markup'-submodule.
%%
%% Revision 1.2  1996/03/13  16:53:47  kehr
%% Don't remember specific changes. Just time to check-in.
%%
%% Revision 1.1  1996/01/23  12:17:09  kehr
%% First version of the module `markup'.
%%
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:)
