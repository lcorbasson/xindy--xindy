%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    markup
%% Submodule: markup
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{markup}}

\subsection{Introduction}

As already described in the module preface this module implements the
markup-process.


\subsection{Abstract Specification}

The markup algorithm traverses the index data structure in in-order.
Each node contains a \emph{open-} and \emph{close-}markup description
which are triggered when the node is entered or left. The leaves of
the tree emit the actual information stored in the index.

To allow a fine-grained user-interface we also keep track of the
recursion level when walking through recursively defined parts of the
data structure (i.e.\ on entering the topmost indexentry we set its
\emph{depth} to zero and on entering his subentries we increment the
depth by one for these entries, and so on\ldots).

\subsubsection{Definition}


\subsubsection{Operation}


\subsection{Concrete Specification}


\subsubsection{Markup}

The markup-stream is stored in the global variable
[[*markup-output-stream*]]. All stream primitives \emph{must} use this
stream for output.

To help the user learning the markup-system we define a boolean toggle
named [[*markup-verbose-mode*]]. When turned on the predefined
default-methods print a identifier describing their markup-state,
otherwise these methods don't print anything.  Additionally these
identifiers are placed between the strings [[*markup-verbose-open*]]
and [[*markup-verbose-close*]], allowing the wrapping into a
typsetting macro that actually expands to something else (maybe
nothing).

<<Markup definitions>>=
(defparameter *markup-output-stream* *standard-output*)
(defparameter *markup-verbose-mode*  nil)
(defparameter *markup-verbose-open*  "<")
(defparameter *markup-verbose-close* ">")
(defparameter *markup-indentation* 2)
(defparameter *markup-indent-level* 0)
(defparameter *empty-markup* "")

(defun do-markup-indent ()
  (incf *markup-indent-level* *markup-indentation*))
(defun do-markup-outdent ()
  (decf *markup-indent-level* *markup-indentation*))
@ %def *do-markup-output-stream*

<<Export-list of submodule \module{markup}>>=
(export '(*markup-output-stream*
          *markup-verbose-mode*
          *markup-verbose-open*
          *markup-verbose-close*))
@

\paragraph{Markup primitives}

The following primitives can be used for the implementation of the
markup algorithm.

<<Markup primitives>>=
(defun do-markup-string (str)
  (declare (inline))
  (write-string str *markup-output-stream*))
@ %def do-markup-string

\no This function can be used to implement the default-markup when
verbose-mode is turned on.

<<Markup primitives>>=
(defun do-markup-default (str &optional object)
  (declare (inline))
  (when *markup-verbose-mode*
    (loop for x from 1 to *markup-indent-level*
          do (write-string " "))
    (do-markup-string *markup-verbose-open*)
    (do-markup-string str)
    (when object
      (etypecase object
        (string (do-markup-string " [")
                (do-markup-string object)
                (do-markup-string "]"))
        (number (do-markup-string " [")
                (write object :stream *markup-output-stream*)
                (do-markup-string "]"))))
    (do-markup-string *markup-verbose-close*)
    (terpri)
    ))
@ %def do-markup-default

\no The following macro is a convenience tool to express the markup of
lists at a very high level. The list [[some-list]] contains elements
that need to be processed. The [[open/close-body]] keyword-arguments
define code that is processed when \emph{opening} and \emph{closing}
the list, [[elt-body]] id processed for each element in turn and
[[sep-body]] is used to separate the first from the second element,
the second from the third, and so on until the $n$-1-th to the $n$-th.

<<Markup primitives>>=
(defmacro do-markup-list (some-list
                       &key
                       (identifier 'nil)
                       (elt-body   'nil) (sep-body 'nil)
                       (open-body 'nil)  (close-body 'nil))
  `(PROGN
    ,(when open-body `,open-body)
    (LET ((LIST-END (CAR (LAST ,some-list))))
      (DO ((SLIST ,some-list (CDR SLIST)))
          ((ENDP SLIST))
        (LET ((,identifier (CAR SLIST)))
          ,elt-body
          ,(if sep-body
               `(UNLESS (EQL ,identifier LIST-END)
                 ,sep-body)))))
    ,(when close-body close-body)))
@  %def do-markup-list

\no The following example demonstates its expansion:

<<Markup primitives>>=
#|
(macroexpand '(markup-list '(1 2 3) :identifier FOO
               :open-body  (print "open")
               :close-body (print "close")
               :elt-body   (print FOO)
               :sep-body   (print ",")))

expands to

(PROGN (PRINT "open")
  (LET ((LIST-END (CAR (LAST '(1 2 3)))))
    (DO ((SLIST '(1 2 3) (CDR SLIST))) ((ENDP SLIST))
      (LET ((FOO (CAR SLIST))) (PRINT FOO)
        (UNLESS (EQL FOO LIST-END) (PRINT ","))
  ) ) )
  (PRINT "close")
) ;
T
|#
@

<<Markup primitives>>=
(defmacro define-list-environment-methods (name
					   (&whole signature)
					   &key open close sep declare body)
  (let ((name (stringify name)))
    `(LET ()
      (CLOS:DEFMETHOD ,(intern (string-upcase (concatenate 'string name "-open")))
	  ,signature ,@declare ,@open ,@body)
      (CLOS:DEFMETHOD ,(intern (string-upcase (concatenate 'string name "-close")))
	  ,signature ,@declare ,@close ,@body)
      (CLOS:DEFMETHOD ,(intern (string-upcase (concatenate 'string name "-sep")))
	  ,signature ,@declare ,@sep ,@body))))
@ %def define-list-environment-methods

<<Markup primitives>>=
(defmacro define-environment-methods (name
				      (&whole signature)
				      &key open close declare body)
  (let ((name (stringify name)))
    `(LET ()
      (CLOS:DEFMETHOD ,(intern (string-upcase (concatenate 'string name "-open")))
	  ,signature ,@declare ,@open ,@body)
      (CLOS:DEFMETHOD ,(intern (string-upcase (concatenate 'string name "-close")))
	  ,signature ,@declare ,@close ,@body))))
@ %def define-environment-methods

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-string do-markup-list))
@

\paragraph{Index markup}

The markup of an index currently consits of the open/close markups and
the markup of the list of all indexentries.

\begin{TODO}
  \item This must be changed when implementing the \emph{letter groups}.
\end{TODO}

<<Index markup>>=
(defmethod do-markup-index ((idx base-index))
  (do-markup-index-open  idx)
  (do-markup-list (get-entry-list idx)
               :identifier IDXENT #| the identifier to use in the expansion |#
               :open-body  (do-markup-indexentry-list-open  0 #|initial depth:=0|#)
               :elt-body   (do-markup-indexentry (cdr IDXENT) 0)
               :sep-body   (do-markup-indexentry-list-sep   0)
               :close-body (do-markup-indexentry-list-close 0))
  (do-markup-index-close idx))

(define-environment-methods do-markup-index ((idx base-index))
  :open  ((do-markup-default "INDEX:OPEN"))
  :close ((do-markup-default "INDEX:CLOSE")))
#|
(defmethod do-markup-index-open ((idx base-index))
  (do-markup-default "INDEX:OPEN"))

(defmethod do-markup-index-close ((idx base-index))
  (do-markup-default "INDEX:CLOSE"))
|#
@ %def do-markup-index

<<Markup interface>>=
(defmacro markup-index (&key open close sep)
  `(DEFINE-LIST-ENVIRONMENT-METHODS do-markup-indexentry-list (idx index:base-index)
    :declare ((declare (ignore idx)))
    :open  ,(when open  `((do-markup-string ,open)))
    :close ,(when close `((do-markup-string ,close)))
    :sep   ,(when sep   `((do-markup-string ,sep)))))
@ %def markup-index

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-index do-markup-index-open do-markup-index-close))
@


\paragraph{Indexentry markup}

The parts of the indexentry being relevant for markup are the keyword,
the location-refererences and the subentries. Since the
location-references are actually location-class-groups we have 3
subtargets for an indexentry markup.

<<Indexentry markup>>=
(defmethod do-markup-indexentry ((idxent indexentry)
				 (depth number))
  (let ((new-depth  (1+ depth)))
    (do-markup-indexentry-open depth)

    (let ((print-key (get-print-key idxent)))
      (do-markup-list (or print-key (get-main-key idxent))
	:identifier KEYWORD
	:open-body  (do-markup-keyword-open  new-depth)
	:elt-body   (do-markup-string        KEYWORD)
	:sep-body   (do-markup-keyword-sep   new-depth)
	:close-body (do-markup-keyword-close new-depth)))

    (do-markup-list (get-locrefs idxent)
      :identifier LOCCLS-GRP
      :open-body  (do-markup-loccls-grp-list-open)
      :elt-body   (do-markup-loccls-grp LOCCLS-GRP)
      :sep-body   (do-markup-loccls-grp-list-sep)
      :close-body (do-markup-loccls-grp-list-close))

    (let ((subentries (get-subentries idxent)))
      (when subentries
        (do-markup-list subentries
	  :identifier IDXENT
	  :open-body  (do-markup-indexentry-list-open  new-depth)
	  :elt-body   (do-markup-indexentry IDXENT new-depth)
	  :sep-body   (do-markup-indexentry-list-sep   new-depth)
	  :close-body (do-markup-indexentry-list-close new-depth))))

    (do-markup-indexentry-close depth)))
@ %def do-markup-indexentry

<<Indexentry markup>>=
(define-list-environment-methods do-markup-keyword ((depth number))
  :declare ((declare (ignore depth)))
  :open  ((do-markup-default "KEYWORD:OPEN"))
  :close ((do-markup-default "KEYWORD:CLOSE"))
  :sep   ((do-markup-default "KEYWORD:SEP")))

#| The above macro expands to the following method declarations
(defmethod do-markup-keyword-open ((depth number))
  (declare (ignore depth))
  (do-markup-default "KEYWORD:OPEN"))

(defmethod do-markup-keyword-sep ((depth number))
  (declare (ignore depth))
  (do-markup-default "KEYWORD:SEP"))

(defmethod do-markup-keyword-close ((depth number))
  (declare (ignore depth))
  (do-markup-default "KEYWORD:CLOSE"))
|#
@ %def do-markup-keyword-*

<<Indexentry markup>>=
(define-environment-methods do-markup-indexentry ((depth number))
  :declare ((declare (ignore depth)))
  :open  ((do-markup-default ":IDXENT-OPEN"))
  :close ((do-markup-default ":IDXENT-CLOSE")))

#| The above macro expands to the following method declarations
(defmethod do-markup-indexentry-open ((depth number))
  (declare (ignore depth))
  (do-markup-default "IDXENT:OPEN"))

(defmethod do-markup-indexentry-close ((depth number))
  (declare (ignore depth))
  (do-markup-default "IDXENT:CLOSE"))
|#
@ %def do-markup-indexentry-*

<<Indexentry markup>>=
(define-list-environment-methods do-markup-indexentry-list ((depth number))
  :declare ((declare (ignore depth)))
  :open  ((do-markup-default "IDXENT-LST:OPEN")
	  (do-markup-indent))
  :close ((do-markup-default "IDXENT-LST:CLOSE")
	  (do-markup-outdent))
  :sep   ((do-markup-default "IDXENT-LST:SEP")))
@ %def do-markup-indexentry-list-*

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-indexentry
          do-markup-indexentry-open
          do-markup-indexentry-close
          do-markup-indexentry-list-open
          do-markup-indexentry-list-sep
          do-markup-indexentry-list-close
          do-markup-keyword-open
          do-markup-keyword-sep
          do-markup-keyword-close))
@


\paragraph{Location-class-group markup}

<<Location-class-group markup>>=
(defmethod do-markup-loccls-grp ((locref-cls-grp locref-class-group))
  (let ((locclass (get-locclass locref-cls-grp)))
    (do-markup-loccls-grp-open locclass)

    (do-markup-list (get-members locref-cls-grp)
      :identifier CATATTR-GRP
      :open-body  (do-markup-catattr-grp-list-open)
      :elt-body   (do-markup-catattr-grp CATATTR-GRP)
      :sep-body   (do-markup-catattr-grp-list-sep)
      :close-body (do-markup-catattr-grp-list-close))

    (do-markup-loccls-grp-close locclass)))

(define-environment-methods do-markup-loccls-grp ((loccls location-class))
  :open  ((do-markup-default "LOCCLS-GRP:OPEN" (get-name loccls)))
  :close ((do-markup-default "LOCCLS-GRP:CLOSE" (get-name loccls))))

(define-list-environment-methods do-markup-loccls-grp-list ()
  :open  ((do-markup-default "LOCCLS-GRP-LST:OPEN")
	  (do-markup-indent))
  :close ((do-markup-default "LOCCLS-GRP-LST:CLOSE")
	  (do-markup-outdent))
  :sep   ((do-markup-default "LOCCLS-GRP-LST:SEP")))
@ %def do-markup-loccls-grp*

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-loccls-grp
          do-markup-loccls-grp-open
          do-markup-loccls-grp-close
          do-markup-loccls-grp-list-open
          do-markup-loccls-grp-list-sep
          do-markup-loccls-grp-list-close))
@

\paragraph{Catattr-group markup}

<<Catattr-group markup>>=
(defmethod do-markup-catattr-grp ((catattr-grp category-attribute-group))
  (let ((ordnum (get-ordnum catattr-grp)))
    (do-markup-catattr-grp-open ordnum)

    (do-markup-list (get-members catattr-grp)
      :identifier LOCREF
      :open-body  (do-markup-locref-list-open)
      :elt-body   (do-markup-locref LOCREF)
      :sep-body   (do-markup-locref-list-sep)
      :close-body (do-markup-locref-list-close))

    (do-markup-catattr-grp-close ordnum)))

(define-environment-methods do-markup-catattr-grp ((ordnum number))
  :open  ((do-markup-default "CATATTR-GRP:OPEN" ordnum))
  :close ((do-markup-default "CATATTR-GRP:CLOSE" ordnum)))

(define-list-environment-methods do-markup-catattr-grp-list ()
  :open  ((do-markup-default "CATATTR-GRP-LST:OPEN")
	  (do-markup-indent))
  :close ((do-markup-default "CATATTR-GRP-LST:CLOSE")
	  (do-markup-outdent))
  :sep   ((do-markup-default "CATATTR-GRP-LST:SEP")))
@

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-catattr-grp
          do-markup-catattr-grp-open
          do-markup-catattr-grp-close
          do-markup-catattr-grp-list-open
          do-markup-catattr-grp-list-sep
          do-markup-catattr-grp-list-close))
@

\paragraph{Location-reference markup}

<<Location-reference markup>>=
(defmethod do-markup-locref ((locref layered-location-reference))
  (let ((loccls (get-locclass locref)))
    (do-markup-locref-open loccls)

    (do-markup-list (get-layers locref)
                 :identifier LOCREF-LAYER
                 :open-body  (do-markup-locref-layer-list-open)
                 :elt-body   (do-markup-string LOCREF-LAYER)
                 :sep-body   (do-markup-locref-layer-list-sep)
                 :close-body (do-markup-locref-layer-list-close))

    (do-markup-locref-close loccls)))

(define-environment-methods do-markup-locref ((loccls location-class))
  :open  ((do-markup-default "LOCREF:OPEN"))
  :close ((do-markup-default "LOCREF:CLOSE")))

(define-list-environment-methods do-markup-locref-list ()
  :open  ((do-markup-default "LOCREF-LST:OPEN")
	  (do-markup-indent))
  :close ((do-markup-default "LOCREF-LST:CLOSE")
	  (do-markup-outdent))
  :sep   ((do-markup-default "LOCREF-LST:SEP")))
@

<<Location-reference markup>>=
(define-list-environment-methods do-markup-locref-layer-list ()
  :open  ((do-markup-default "LOCREF-LAYER-LST:OPEN")
	  (do-markup-indent))
  :close ((do-markup-default "LOCREF-LAYER-LST:CLOSE")
	  (do-markup-outdent))
  :sep   ((do-markup-default "LOCREF-LAYER-LST:SEP")))
@

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-locref-grp
          do-markup-locref-grp-open
          do-markup-locref-grp-close
          do-markup-locref-grp-list-open
          do-markup-locref-grp-list-sep
          do-markup-locref-grp-list-close
          do-markup-locref-layer-list-open
          do-markup-locref-layer-list-sep
          do-markup-locref-layer-list-close))
@

\subsubsection{The module root}

<<*>>=
;; $Id$

(in-package "MARKUP")
(provide "MARKUP")

(use-package "CLOS")
(use-package "XP")
(require "base")
(use-package "BASE")
(require "locref")
(use-package "LOCREF")
(require "idxstyle")
(use-package "IDXSTYLE")
(require "index")
(use-package "INDEX")

<<Submodule \module{markup}>>

<<Pretty-printing>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))
@

\subsubsection{The submodule root}

<<Submodule \module{markup}>>=
;; $Id$

<<Markup definitions>>
<<Markup primitives>>
<<Indexentry markup>>
<<Index markup>>
<<Location-class-group markup>>
<<Catattr-group markup>>
<<Location-reference markup>>
<<Markup interface>>

<<Export-list of submodule \module{markup}>>
@

<<RCS-Identifier>>=
("markup" . "$Id$")
@

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
@


%% $Log$
%% Revision 1.6  1996/05/10 17:36:36  kehr
%% Wrote some more sophisticated macros that expand to several methods at
%% once. The source is now much more compact.
%%
%% Revision 1.5  1996/05/09  11:50:00  kehr
%% Changes in all submodules, due to macro-expansion problems during
%% compilation.
%%
%% Revision 1.4  1996/05/06  10:01:57  kehr
%% Minor changes in nearly all modules.
%%
%% Revision 1.3  1996/04/29  08:38:39  kehr
%% Started to implement teh new `markup'-submodule.
%%
%% Revision 1.2  1996/03/13  16:53:47  kehr
%% Don't remember specific changes. Just time to check-in.
%%
%% Revision 1.1  1996/01/23  12:17:09  kehr
%% First version of the module `markup'.
%%
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:)
