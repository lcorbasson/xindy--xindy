%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module:    markup
%% Submodule: markup
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{markup}}

\subsection{Introduction}

As already described in the module preface this module implements the
markup-process.


\subsection{Abstract Specification}

The markup algorithm traverses the index data structure in in-order.
Each node contains a \emph{open-} and \emph{close-}markup description
which are triggered when the node is entered or left. The leaves of
the tree emit the actual information stored in the index.

To allow a fine-grained user-interface we also keep track of the
recursion level when walking through recursively defined parts of the
data structure (i.e.\ on entering the topmost indexentry we set its
\emph{depth} to zero and on entering his subentries we increment the
depth by one for these entries, and so on\ldots).

\subsubsection{Definition}


\subsubsection{Operation}


\subsection{Concrete Specification}


\subsubsection{Markup}

The markup-stream is stored in the global variable
[[*markup-output-stream*]]. All stream primitives \emph{must} use this
stream for output.

To help the user learning the markup-system we define a boolean toggle
named [[*markup-verbose-mode*]]. When turned on the predefined
default-methods print a identifier describing their markup-state,
otherwise these methods don't print anything.  Additionally these
identifiers are placed between the strings [[*markup-verbose-open*]]
and [[*markup-verbose-close*]], allowing the wrapping into a
typsetting macro that actually expands to something else (maybe
nothing).

<<Markup definitions>>=
(defparameter *markup-output-stream* *standard-output*)
(defparameter *markup-verbose-mode*  nil)
(defparameter *markup-verbose-open*  "<")
(defparameter *markup-verbose-close* ">")
(defparameter *markup-indentation*   2)
(defparameter *markup-indent-level*  0)
(defparameter *empty-markup* "")

(defvar *markup-percentage-list*)
(defvar *current-number*)

(defun do-markup-indent ()
  (incf *markup-indent-level* *markup-indentation*))
(defun do-markup-outdent ()
  (decf *markup-indent-level* *markup-indentation*))
@ %def *do-markup-output-stream*

<<Export-list of submodule \module{markup}>>=
(export '(*markup-output-stream*
          *markup-verbose-mode*
          *markup-verbose-open*
          *markup-verbose-close*
          *indexstyle-readtable*))
@

\paragraph{Markup primitives}

The following primitives can be used for the implementation of the
markup algorithm.

<<Markup primitives>>=
(defun do-markup-string (str)
  (declare (inline))
  (write-string str *markup-output-stream*))
@ %def do-markup-string

\no This function can be used to implement the default-markup when
verbose-mode is turned on.

<<Markup primitives>>=
(defun do-markup-default (str &optional arg1 arg2 arg3)
  (when *markup-verbose-mode*
    (loop for x from 1 to *markup-indent-level*
          do (write-string " " *markup-output-stream*))
    (do-markup-string *markup-verbose-open*)
    (do-markup-string str)
    (when arg1
      (format *markup-output-stream* " [~S]" arg1)
      (when arg2
        (format *markup-output-stream* " [~S]" arg2)
        (when arg3
          (format *markup-output-stream* " [~S]" arg3)
          )))
    (do-markup-string *markup-verbose-close*)
    (terpri *markup-output-stream*)
    ))
@ %def do-markup-default

\no The following macro is a convenience tool to express the markup of
lists at a very high level. The list [[some-list]] contains elements
that need to be processed. The [[open/close-body]] keyword-arguments
define code that is processed when \emph{opening} and \emph{closing}
the list, [[elt-body]] id processed for each element in turn and
[[sep-body]] is used to separate the first from the second element,
the second from the third, and so on until the $n$-1-th to the $n$-th.

<<Markup primitives>>=
(defmacro do-markup-list (some-list
                          &key
                          identifier counter
                          elt-body   sep-body
                          open-body  close-body)
  `(PROGN
    ,(when open-body `,open-body)
    (LET ,(if counter
              `((LIST-END (CAR (LAST ,some-list)))
                (COUNTER ,counter))
              `((LIST-END (CAR (LAST ,some-list)))))
      (DO ((SLIST ,some-list (CDR SLIST)))
          ((ENDP SLIST))
        (LET ((,identifier (CAR SLIST)))
          ,elt-body
          ,(if sep-body
               `(UNLESS (EQL ,identifier LIST-END)
                 ,sep-body)))))
    ,(when close-body close-body)))
@  %def do-markup-list

\no The following example demonstates its expansion:

<<Markup primitives>>=
#|
(macroexpand '(markup-list '(1 2 3) :identifier FOO
               :open-body  (print "open")
               :close-body (print "close")
               :elt-body   (print FOO)
               :sep-body   (print ",")))

expands to

(PROGN (PRINT "open")
  (LET ((LIST-END (CAR (LAST '(1 2 3)))))
    (DO ((SLIST '(1 2 3) (CDR SLIST))) ((ENDP SLIST))
      (LET ((FOO (CAR SLIST))) (PRINT FOO)
        (UNLESS (EQL FOO LIST-END) (PRINT ","))
  ) ) )
  (PRINT "close")
) ;
T
|#
@

\paragraph{Method-defining primitives}

This paragraph contains macros that expand to CLOS-method-definitions.
These methods are used to assign appropriate markup to classes and
objects. The [[handler-bind]]-mechanism is used to hide the warnings
CLOS issues when redefining methods which can happen here.  The former
solution was to temporary bind the stream [[*ERROR-OUTPUT*]] to a
string-stream that was never printed.

<<Method-defining primitives>>=
(defmacro define-list-environment-methods (name
                                           (&whole signature)
                                           &key open close sep declare body)
  (let ((name (stringify name)))
    `(HANDLER-BIND ((WARNING #'MUFFLE-WARNING))
      (CLOS:DEFMETHOD
          ,(intern (string-upcase (concatenate 'string name "-open"))
                   'markup)
          ,signature ,@declare ,@open ,@body)
      (CLOS:DEFMETHOD
          ,(intern (string-upcase (concatenate 'string name "-close"))
                   'markup)
          ,signature ,@declare ,@close ,@body)
      (CLOS:DEFMETHOD
          ,(intern (string-upcase (concatenate 'string name "-sep"))
                   'markup)
          ,signature ,@declare ,@sep ,@body))))
@ %def define-list-environment-methods

<<Method-defining primitives>>=
(defmacro define-environment-methods (name
                                      (&whole signature)
                                      &key open close declare body)
  (let ((name (stringify name)))
    `(HANDLER-BIND ((WARNING #'MUFFLE-WARNING))
      (CLOS:DEFMETHOD
          ,(intern (string-upcase (concatenate 'string name "-open"))
                   'markup)
          ,signature ,@declare ,@open ,@body)
      (CLOS:DEFMETHOD
          ,(intern (string-upcase (concatenate 'string name "-close"))
                   'markup)
          ,signature ,@declare ,@close ,@body))))

(defmacro define-method (name
                         (&whole signature)
                         &key declare body)
  (let ((name (stringify name)))
    `(HANDLER-BIND ((WARNING #'MUFFLE-WARNING))
      (CLOS:DEFMETHOD
          ,(intern (string-upcase name) 'markup)
          ,signature ,@declare ,@body))))
@ %def define-environment-methods define-method

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Some chunks for checking correct arguments}

<<Check [[:open]] and [[:close]]>>=
((and open (not (stringp open)))
 (nraw "parameter `~S' is not a string! (ignored)~%" open))
((and close (not (stringp close)))
 (nraw "parameter `~S' is not a string! (ignored)~%" close))
@

<<Check [[:open-head]] and [[:close-head]]>>=
((and open-head (not (stringp open-head)))
 (nraw "parameter `~S' is not a string! (ignored)~%" open-head))
((and close-head (not (stringp close-head)))
 (nraw "parameter `~S' is not a string! (ignored)~%" close-head))
@

<<Check [[:open]], [[:close]] and [[:sep]]>>=
<<Check [[:open]] and [[:close]]>>
((and sep  (not (stringp sep)))
 (nraw "parameter `~S' is not a string! (ignored)~%" sep))
@

<<Check [[:depth]]>>=
((and depth (not (integerp depth)))
 (nraw "parameter `~S' is not a number! (ignored)~%" depth))
@

<<Check [[:group]]>>=
((and group (progn
              (setq group (stringify group))
              (not (lookup-letter-group-definition *indexstyle* group))))
 (nraw "parameter `~S' is not a valid letter-group! (ignored)~%" group))
@

<<Check [[:class]] for location-reference class>>=
((and class (progn (setq class (stringify class))
                   (not (lookup-locref-class *indexstyle* class))))
 (nraw "parameter `~S' is not a location-reference class! (ignored)~%" class))
@

<<Check [[:class]] for cross-reference class>>=
((and class (progn (setq class (stringify class))
                   (not (lookup-crossref-class *indexstyle* class))))
 (nraw "parameter `~S' is not a cross-reference class! (ignored)~%" class))
@

<<Check [[:attr]]>>=
((and attr (progn (setq attr (stringify attr))
                   (not (lookup-catattr *indexstyle* attr))))
 (nraw "parameter `~S' is not an attribute! (ignored)~%" attr))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Markup tracing}

<<Markup interface>>=
(defmacro markup-trace (&rest args)
  (destructuring-switch-bind (&key
                              (open  *markup-verbose-open*)
                              (close *markup-verbose-close*)
                              &switch
                              on)
      args
    (cond <<Check [[:open]] and [[:close]]>>
          (t `(LET ()
               (SETQ *markup-verbose-open*  ,open)
               (SETQ *markup-verbose-close* ,close)
               ,(when on `(SETQ *markup-verbose-mode* t)))))))
@ %def markup-trace

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Index markup}

The markup of an index currently consits of the open/close markups and
the markup of the list of all indexentries.

<<Index markup>>=
(defmethod do-markup-index ((idx base-index))
  (setq *current-number* 0)
  (setq *markup-percentage-list* index:*percentage-list*)
  (do-markup-index-open idx)
  (do-markup-list (get-entries idx)
    :identifier LETTER-GRP
    :open-body  (do-markup-letter-group-list-open)
    :elt-body   (do-markup-letter-group LETTER-GRP)
    :sep-body   (do-markup-letter-group-list-sep)
    :close-body (do-markup-letter-group-list-close))
  (index:print-rest-of-percentages *markup-percentage-list*)
  (do-markup-index-close idx))

(define-environment-methods do-markup-index ((idx base-index))
  :declare ((declare (ignore idx)))
  :open  ((do-markup-default "INDEX:OPEN")
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "INDEX:CLOSE")))
@ %def do-markup-index

<<Export-list of submodule \module{markup}>>=
(export '(do-markup-index))
@

<<Index markup>>=
(defmacro markup-index (&whole whole &rest args)
  (destructuring-switch-bind (&key
                              open close hierdepth
                              &switch
                              tree flat)
      args
    (let (hierdepth-cmd)
      (when (or hierdepth tree flat)
        (cond
          ((and tree flat)
             (error "you can't specify :tree and :flat simultaneously in ~%~S~%"
                     whole))
          ((and hierdepth (or tree flat))
             (error "you can't specify :hierdepth with :tree or :flat simultaneously in ~%~S~%"
                     whole))
          (flat (setq hierdepth-cmd
                      `(SET-HIERDEPTH 0 *INDEX*)));; no tree-structure
          ;; MOST-POSITIVE-FIXNUM means make all trees
          (tree (setq hierdepth-cmd
                      `(SET-HIERDEPTH MOST-POSITIVE-FIXNUM *INDEX*)))
          (hierdepth
             (when (not (numberp hierdepth))
               (error "~S is not a number in ~S~%" whole))
             (setq hierdepth-cmd
                   `(SET-HIERDEPTH ,hierdepth *INDEX*))))
        `(LET ()
          (markup::define-environment-methods
              DO-MARKUP-INDEX ((idx index:base-index))
            :declare ((declare (ignore idx)))
            :open  ,(when open  `((do-markup-string ,open)))
            :close ,(when close `((do-markup-string ,close))))
          ,hierdepth-cmd)))))
@ %def markup-index

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Letter group markup}

<<Letter group markup>>=
(define-list-environment-methods do-markup-letter-group-list ()
  :open  ((do-markup-default "LETTER-GROUP-LIST:OPEN")
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LETTER-GROUP-LIST:CLOSE"))
  :sep   ((do-markup-default "LETTER-GROUP-LIST:SEP")))
@ %def do-markup-letter-group-list

<<Markup interface>>=
(defmacro markup-letter-group-list (&key open close sep)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-LETTER-GROUP-LIST ()
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-letter-group-list

<<Letter group markup>>=
(defmethod do-markup-letter-group ((letter-grp letter-group))
  (let ((group-definition (get-group-definition letter-grp)))
    (do-markup-letter-group-open       group-definition)
    (do-markup-letter-group-head-open  group-definition)
    (do-markup-letter-group-head       group-definition)
    (do-markup-letter-group-head-close group-definition)
    (do-markup-list (get-members letter-grp)
      :identifier IDXENT #| the identifier to use in the expansion |#
      :open-body  (do-markup-indexentry-list-open  0
                    #|initial depth:=0|#)
      :elt-body   (do-markup-indexentry IDXENT     0)
      :sep-body   (do-markup-indexentry-list-sep   0)
      :close-body (do-markup-indexentry-list-close 0))
    (do-markup-letter-group-close group-definition)))

(define-environment-methods do-markup-letter-group
    ((group letter-group-definition))
  :open  ((do-markup-default "LETTER-GROUP:OPEN"  (get-name group))
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LETTER-GROUP:CLOSE" (get-name group))))

(define-environment-methods do-markup-letter-group-head
    ((group letter-group-definition))
  :open  ((do-markup-default "LETTER-GROUP-HEAD:OPEN"  (get-name group))
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LETTER-GROUP-HEAD:CLOSE" (get-name group))))

(define-method do-markup-letter-group-head ((group letter-group-definition))
  :body ((do-markup-default "LETTER-GROUP-HEAD" (get-name group))))
@ %def do-markup-letter-group do-markup-letter-group-head do-markup-letter-group-head

<<Markup interface>>=
(defmacro markup-letter-group (&whole whole &rest args)
  (destructuring-switch-bind (&key
                              open close group
                              open-head close-head
                              &switch
                              upcase downcase capitalize)
      args
    (cond <<Check [[:open]] and [[:close]]>>
          <<Check [[:open-head]] and [[:close-head]]>>
          <<Check [[:group]]>>
          ((or (and upcase downcase)
               (and upcase capitalize)
               (and downcase capitalize))
             (error "more than one modifier in~%~S" whole))
          (t `(LET ()
               (markup::define-environment-methods
                   DO-MARKUP-LETTER-GROUP
                   (,(if group
                         `(lg-def (EQL ,(lookup-letter-group-definition
                                         *indexstyle* group)))
                         '(lg-def letter-group-definition)))
                 :declare ((declare (ignore lg-def)))
                 :open  ,(when open  `((do-markup-string ,open)))
                 :close ,(when close `((do-markup-string ,close))))
               (markup::define-environment-methods
                   DO-MARKUP-LETTER-GROUP-HEAD
                   (,(if group
                         `(lg-def (EQL ,(lookup-letter-group-definition
                                         *indexstyle* group)))
                         '(lg-def letter-group-definition)))
                 :declare ((declare (ignore lg-def)))
                 :open  ,(when open-head  `((do-markup-string ,open-head)))
                 :close ,(when close-head `((do-markup-string ,close-head))))
               ,(when (or open-head close-head)
                      `(markup::define-method
                        DO-MARKUP-LETTER-GROUP-HEAD
                        (,(if group
                              `(lg-def (EQL ,(lookup-letter-group-definition
                                              *indexstyle* group)))
                              '(lg-def letter-group-definition)))
                        :body ((do-markup-string
                                   ,(cond (upcase     `(string-upcase
                                                        (get-name lg-def)))
                                          (downcase   `(string-downcase
                                                        (get-name lg-def)))
                                          (capitalize `(string-capitalize
                                                        (get-name lg-def)))
                                          (t `(get-name lg-def))))))))))))
@ %def markup-letter-group

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Indexentry markup}

The parts of the indexentry being relevant for markup are the keyword,
the location-refererences and the subentries. Since the
location-references are actually location-class-groups we have 3
subtargets for an indexentry markup.

<<Indexentry markup>>=
(define-list-environment-methods do-markup-indexentry-list ((depth number))
  :open  ((do-markup-default "INDEXENTRY-LIST:OPEN"  depth)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "INDEXENTRY-LIST:CLOSE" depth))
  :sep   ((do-markup-default "INDEXENTRY-LIST:SEP"   depth)))
@ %def do-markup-indexentry-list

<<Markup interface>>=
(defmacro markup-indexentry-list (&key open close sep depth)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        <<Check [[:depth]]>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-INDEXENTRY-LIST
             (,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-indexentry-list

<<Indexentry markup>>=
(defmethod do-markup-indexentry ((idxent index-entry)
                                 (depth number))
  (when (>= (incf *current-number*) (caar *markup-percentage-list*))
    (index:print-percent (pop *markup-percentage-list*)))

  (do-markup-indexentry-open depth)

  (let ((print-key (get-print-key idxent)))
    (do-markup-list (merge-print-and-main-key print-key (get-main-key idxent))
      :identifier KEYWORD
      :open-body  (do-markup-keyword-list-open  depth)
      :elt-body   (do-markup-keyword   KEYWORD  depth)
      :sep-body   (do-markup-keyword-list-sep   depth)
      :close-body (do-markup-keyword-list-close depth)))

  (let ((locrefs (get-locrefs idxent)))
    (unless (endp locrefs)
      (do-markup-list locrefs
        :identifier LOCCLS-GRP
        :open-body  (do-markup-locclass-list-open)
        :elt-body   (do-markup-locclass LOCCLS-GRP)
        :sep-body   (do-markup-locclass-list-sep)
        :close-body (do-markup-locclass-list-close))))

  (let ((subentries (get-subentries idxent)))
    (unless (endp subentries)
      (let ((new-depth (1+ depth)))
        (do-markup-list subentries
          :identifier IDXENT
          :open-body  (do-markup-indexentry-list-open  new-depth)
          :elt-body   (do-markup-indexentry IDXENT     new-depth)
          :sep-body   (do-markup-indexentry-list-sep   new-depth)
          :close-body (do-markup-indexentry-list-close new-depth)))))

  (do-markup-indexentry-close depth))

(defun merge-print-and-main-key (print-key main-key)
  ;;(info "~&(merge-print-and-main-key ~S ~S)" print-key main-key)
  (if print-key
      (mapcar #'(lambda (print main)
		  (or print main))
	      print-key main-key)
      main-key))
@ %def do-markup-indexentry

<<Indexentry markup>>=
(define-environment-methods do-markup-indexentry ((depth number))
  :open  ((do-markup-default "INDEXENTRY:OPEN"  depth)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "INDEXENTRY:CLOSE" depth)))
@ %def do-markup-indexentry

<<Markup interface>>=
(defmacro markup-indexentry (&key open close depth)
  (cond <<Check [[:open]] and [[:close]]>>
        <<Check [[:depth]]>>
        (t `(markup::define-environment-methods
             DO-MARKUP-INDEXENTRY
             (,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))))))
@ %def markup-indexentry

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Keyword markup}

<<Keyword markup>>=
(define-list-environment-methods do-markup-keyword-list ((depth number))
  :open  ((do-markup-default "KEYWORD-LIST:OPEN"  depth)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "KEYWORD-LIST:CLOSE" depth))
  :sep   ((do-markup-default "KEYWORD-LIST:SEP"   depth)))
@ %def do-markup-keyword-list

<<Markup interface>>=
(defmacro markup-keyword-list (&key open close sep depth)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        <<Check [[:depth]]>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-KEYWORD-LIST
             (,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-keyword-list

<<Keyword markup>>=
(defmethod do-markup-keyword (keyword (depth number))
  (do-markup-keyword-open depth)
  (do-markup-string keyword)
  (do-markup-keyword-close depth))
@ %def do-markup-keyword

<<Keyword markup>>=
(define-environment-methods do-markup-keyword ((depth number))
  :open  ((do-markup-default "KEYWORD:OPEN"  depth)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "KEYWORD:CLOSE" depth)))
@ %def do-markup-keyword-*

<<Markup interface>>=
(defmacro markup-keyword (&key open close depth)
  (cond <<Check [[:open]] and [[:close]]>>
        <<Check [[:depth]]>>
        (t `(markup::define-environment-methods
             DO-MARKUP-KEYWORD
             (,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))))))
@ %def markup-keyword


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Location-class markup}

The following methods define the markup of a list of location-class
groups. The elements of this group are of type
\type{locref-class-group} or \type{crossref-class-group} and
dispatching braches to the right methods.

<<Location-class-group markup>>=
(define-list-environment-methods do-markup-locclass-list ()
  :open  ((do-markup-default "LOCCLASS-LIST:OPEN")
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LOCCLASS-LIST:CLOSE"))
  :sep   ((do-markup-default "LOCCLASS-LIST:SEP")))
@ %def do-markup-locclass-list

<<Markup interface>>=
(defmacro markup-locclass-list (&key open close sep)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-LOCCLASS-LIST ()
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-locclass-list

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subparagraph{Location-reference-class markup}

<<Location-class-group markup>>=
(defmethod do-markup-locclass ((locref-cls-grp locref-class-group))
  (let ((locclass (get-locclass locref-cls-grp)))
    (do-markup-locref-class-open locclass)

    (do-markup-list (get-members locref-cls-grp)
      :identifier ATTRIBUTE-GRP
      :open-body  (do-markup-attribute-group-list-open)
      :elt-body   (do-markup-attribute-group ATTRIBUTE-GRP locclass)
      :sep-body   (do-markup-attribute-group-list-sep)
      :close-body (do-markup-attribute-group-list-close))

    (do-markup-locref-class-close locclass)))

(define-environment-methods do-markup-locref-class
    ((locrefcls layered-location-class))
  :open  ((do-markup-default "LOCREF-CLASS:OPEN"  (get-name locrefcls))
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LOCREF-CLASS:CLOSE" (get-name locrefcls))))
@ %def do-markup-locclass do-markup-locref-class

<<Markup interface>>=
(defmacro markup-locref-class (&key open close class)
  (cond <<Check [[:open]] and [[:close]]>>
        <<Check [[:class]] for location-reference class>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-LOCREF-CLASS
             (,(if class
                   `(locrefcls (EQL ,(cdr (lookup-locref-class
                                           *indexstyle* class))))
                   '(locrefcls layered-location-class)))
             :declare ((declare (ignore locrefcls)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))))))
@ %def markup-locref-class

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Attribute-group markup}

<<Attribute-group markup>>=
(define-list-environment-methods do-markup-attribute-group-list ()
  :open  ((do-markup-default "ATTRIBUTE-GROUP-LIST:OPEN")
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "ATTRIBUTE-GROUP-LIST:CLOSE"))
  :sep   ((do-markup-default "ATTRIBUTE-GROUP-LIST:SEP")))
@ %def do-markup-attribute-group-list

<<Markup interface>>=
(defmacro markup-attribute-group-list (&key open close sep)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-ATTRIBUTE-GROUP-LIST ()
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-attribute-group-list

<<Attribute-group markup>>=
(defmethod do-markup-attribute-group ((attribute-group category-attribute-group)
                                      (loccls layered-location-class))
  (let ((ordnum (get-ordnum attribute-group)))
    (do-markup-attribute-group-open ordnum)

    (do-markup-list (get-members attribute-group)
      :identifier LOCREF
      :open-body  (do-markup-locref-list-open  loccls 0)
      :elt-body   (do-markup-locref     LOCREF loccls 0)
      :sep-body   (do-markup-locref-list-sep   loccls 0)
      :close-body (do-markup-locref-list-close loccls 0))

    (do-markup-attribute-group-close ordnum)))

(define-environment-methods do-markup-attribute-group ((ordnum number))
  :open  ((do-markup-default "ATTRIBUTE-GROUP:OPEN"  ordnum)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "ATTRIBUTE-GROUP:CLOSE" ordnum)))
@ %def do-markup-attribute-group

<<Markup interface>>=
(defmacro markup-attribute-group (&key open close group)
  (cond <<Check [[:open]] and [[:close]]>>
        <<Check [[:group]]>>
        (t `(markup::define-environment-methods
             DO-MARKUP-ATTRIBUTE-GROUP
             (,(if group
                   `(ordnum (EQL ,group))
                   '(ordnum number)))
             :declare ((declare (ignore ordnum)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))))))
@ %def markup-attribute-group


\subparagraph{Layered location-reference markup}

<<Location-reference markup>>=
(define-list-environment-methods do-markup-locref-list
    ((loccls layered-location-class) (depth number))
  :open  ((do-markup-default "LOCREF-LIST:OPEN"  (get-name loccls) depth)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LOCREF-LIST:CLOSE" (get-name loccls) depth))
  :sep   ((do-markup-default "LOCREF-LIST:SEP"   (get-name loccls) depth)))
@ %def do-markup-locref-list

<<Markup interface>>=
(defmacro markup-locref-list (&key open close sep class depth)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        <<Check [[:depth]]>>
        <<Check [[:class]] for location-reference class>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-LOCREF-LIST
             (,(if class
                   `(locrefcls (EQL ,(cdr (lookup-locref-class
                                           *indexstyle* class))))
                   '(locrefcls layered-location-class))
              ,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore locrefcls depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-locref-list

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Location-reference markup}

<<Location-reference markup>>=
(defmethod do-markup-locref ((locref location-reference)
                             (loccls layered-location-class)
                             (depth  number))
  #+ASSERT! (assert! (and (typep locref 'layered-location-reference)
                          (typep depth 'number)))
  (let ((attr    (get-catattr  locref))
        (subrefs (get-subrefs  locref))
        (new-depth (1+ depth)))

    (do-markup-locref-open attr loccls depth)

    (cond
      (subrefs
         (do-markup-list (get-layers locref)
           :identifier LAYER
           :counter    depth
           :open-body  (do-markup-locref-layer-list-open  loccls depth)
           :elt-body   (do-markup-locref-layer LAYER loccls (INCF COUNTER))
           :sep-body   (do-markup-locref-layer-list-sep   loccls depth)
           :close-body (do-markup-locref-layer-list-close loccls depth))

         (do-markup-list subrefs
           :identifier LOCREF
           :open-body  (do-markup-locref-list-open  loccls new-depth)
           :elt-body   (do-markup-locref     LOCREF loccls new-depth)
           :sep-body   (do-markup-locref-list-sep   loccls new-depth)
           :close-body (do-markup-locref-list-close loccls new-depth)))

      ((= 0 depth)
         (do-markup-string (get-locref-string locref)))

      (t (do-markup-list (get-layers locref)
           :identifier LAYER
           :counter    depth
           :open-body  (do-markup-locref-layer-list-open  loccls depth)
           :elt-body   (do-markup-locref-layer LAYER loccls (INCF COUNTER))
           :sep-body   (do-markup-locref-layer-list-sep   loccls depth)
           :close-body (do-markup-locref-layer-list-close loccls depth))))

    (do-markup-locref-close attr loccls depth)))
@ %def do-markup-layered-locref

<<Location-reference markup>>=
(define-list-environment-methods do-markup-locref-layer-list
    ((loccls layered-location-class) (depth  number))
  :open  ((do-markup-default "LOCREF-LAYER-LIST:OPEN"  (get-name loccls) depth)
          (do-markup-indent))
  :sep   ((do-markup-default "LOCREF-LAYER-LIST:SEP"   (get-name loccls) depth))
  :close ((do-markup-outdent)
          (do-markup-default "LOCREF-LAYER-LIST:CLOSE" (get-name loccls) depth)))

(defun do-markup-locref-layer (layer loccls depth)
  (declare (ignore loccls depth))
  ;;(do-markup-locref-layer-open  loccls depth)
  (do-markup-string layer)
  ;;(do-markup-locref-layer-close loccls depth)
  )
@ %def do-markup-locref-layer-list

<<Markup interface>>=
(defmacro markup-locref-layer-list (&key open close sep class depth)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        <<Check [[:depth]]>>
        <<Check [[:class]] for location-reference class>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-LOCREF-LAYER-LIST
             (,(if class
                   `(locrefcls (EQL ,(cdr (lookup-locref-class
                                           *indexstyle* class))))
                   '(locrefcls layered-location-class))
              ,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore locrefcls depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-locref-layer-list


<<Location-reference markup>>=
(define-environment-methods do-markup-locref ((attr   category-attribute)
                                              (loccls layered-location-class)
                                              (depth  number))
  :open  ((do-markup-default "LOCREF:OPEN"
            (get-name attr) (get-name loccls) depth)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "LOCREF:CLOSE"
            (get-name attr) (get-name loccls) depth)))
@ %def do-markup-locref

<<Markup interface>>=
(defmacro markup-locref (&key open close class attr depth)
  (cond <<Check [[:open]] and [[:close]]>>
        <<Check [[:attr]]>>
        <<Check [[:depth]]>>
        <<Check [[:class]] for location-reference class>>
        (t `(markup::define-environment-methods
             DO-MARKUP-LOCREF
             (,(if attr
                   `(attr (EQL ,(lookup-catattr *indexstyle* attr)))
                   '(attr category-attribute))
              ,(if class
                   `(locrefcls (EQL ,(cdr (lookup-locref-class
                                           *indexstyle* class))))
                   '(locrefcls layered-location-class))
              ,(if depth `(depth (EQL ,depth)) '(depth number)))
             :declare ((declare (ignore attr locrefcls depth)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))))))
@ %def markup-locref

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Range markup}

<<Location-reference markup>>=
(defmethod do-markup-locref ((range location-range)
                             (loccls layered-location-class)
                             (depth number))
  (let ((length (get-length range)))
    (do-markup-range-open  loccls length)
    (do-markup-locref (get-first range) loccls depth)
    (do-markup-range-sep   loccls length)
    (when (markup-range-print-end-p loccls length)
      (do-markup-locref (get-last range)  loccls depth))
    (do-markup-range-close loccls length)))

(define-list-environment-methods do-markup-range
    ((loccls layered-location-class) (length number))
  :open  ((do-markup-default "RANGE:OPEN"  (get-name loccls) length)
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "RANGE:CLOSE" (get-name loccls) length))
  :sep   ((do-markup-default "RANGE:SEP"   (get-name loccls) length)))

(defmethod markup-range-print-end-p ((loccls layered-location-class)
				     (length number))
  (declare (ignore loccls length))
  t)
@ %def do-markup-range

<<Markup interface>>=
(defmacro markup-range (&whole whole &rest args)
  (destructuring-switch-bind (&key
			      open close sep class length
			      &switch ignore-end)
      args
    (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
	  <<Check [[:class]] for location-reference class>>
	  ((and length (not (numberp length)))
	     (nraw "parameter `~S' is not a number! (ignored)~%" length))
	  (t `(let ()
	       (markup::define-list-environment-methods
		   DO-MARKUP-RANGE
		   (,(if class
			 `(locrefcls (EQL ,(cdr (lookup-locref-class
						 *indexstyle* class))))
			 '(locrefcls layered-location-class))
		    ,(if length
			 `(length (EQL ,length))
			 '(length number)))
		 :open  ,(when open  `((do-markup-string ,open)))
		 :close ,(when close `((do-markup-string ,close)))
		 :sep   ,(when sep   `((do-markup-string ,sep))))
	       (define-method markup::MARKUP-RANGE-PRINT-END-P
		   (,(if class
			 `(locrefcls (EQL ,(cdr (lookup-locref-class
						 *indexstyle* class))))
			 '(locrefcls layered-location-class))
		    ,(if length
			 `(length (EQL ,length))
			 '(length number)))
		 :declare ((declare (ignore locrefcls length)))
		 :body    (,(not ignore-end))))))))
@ %def markup-locref

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subparagraph{Crossref-class-group markup}

Cross-reference-groups are not separated any further into subgroups.
Their elements are simple cross-references.

<<Crossref-class-group markup>>=
(defmethod do-markup-locclass ((xref-cls-grp crossref-class-group))
  (let ((xrefclass (get-locclass xref-cls-grp)))

    (do-markup-list (get-members xref-cls-grp)
      :identifier XREF
      :open-body  (do-markup-crossref-list-open  xrefclass)
      :elt-body   (do-markup-crossref            XREF)
      :sep-body   (do-markup-crossref-list-sep   xrefclass)
      :close-body (do-markup-crossref-list-close xrefclass))))

(define-list-environment-methods do-markup-crossref-list
    ((xrefclass crossref-location-class))
  :open  ((do-markup-default "CROSSREF-LIST:OPEN"  (get-name xrefclass))
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "CROSSREF-LIST:CLOSE" (get-name xrefclass)))
  :sep   ((do-markup-default "CROSSREF-LIST:SEP"   (get-name xrefclass))))
@ %def do-markup-crossref-grp

<<Markup interface>>=
(defmacro markup-crossref-list (&key open sep close class)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        <<Check [[:class]] for cross-reference class>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-CROSSREF-LIST
             (,(if class
                   `(xrefcls (EQL ,(cdr (lookup-crossref-class *indexstyle*
                                                               class))))
                   '(xrefcls crossref-location-class)))
             :declare ((declare (ignore xrefcls)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-crossref-list

<<Crossref-class-group markup>>=
(defmethod do-markup-crossref ((xref crossref-location-reference))
  (let ((xrefclass (get-locclass xref)))

    (do-markup-list (get-target xref)
      :identifier XREF-LAYER
      :open-body  (do-markup-crossref-layer-list-open  xrefclass)
      :elt-body   (do-markup-crossref-layer XREF-LAYER xrefclass)
      :sep-body   (do-markup-crossref-layer-list-sep   xrefclass)
      :close-body (do-markup-crossref-layer-list-close xrefclass))))

(define-list-environment-methods do-markup-crossref-layer-list
    ((xref-class crossref-location-class))
  :open  ((do-markup-default "CROSSREF-LAYER-LIST:OPEN"
            (get-name xref-class))
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "CROSSREF-LAYER-LIST:CLOSE"
            (get-name xref-class)))
  :sep   ((do-markup-default "CROSSREF-LAYER-LIST:SEP"
            (get-name xref-class))))
@ %def do-markup-crossref-layer-list

<<Markup interface>>=
(defmacro markup-crossref-layer-list (&key open sep close class)
  (cond <<Check [[:open]], [[:close]] and [[:sep]]>>
        <<Check [[:class]] for cross-reference class>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-CROSSREF-LAYER-LIST
             (,(if class
                   `(xrefcls (EQL ,(cdr (lookup-crossref-class *indexstyle*
                                                               class))))
                   '(xrefcls crossref-location-class)))
             :declare ((declare (ignore xrefcls)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))
             :sep   ,(when sep   `((do-markup-string ,sep)))))))
@ %def markup-crossref-grp

<<Crossref-class-group markup>>=
(defmethod do-markup-crossref-layer (xref-layer
                                     (xref-class crossref-location-class))
  (do-markup-crossref-layer-open  xref-class)
  (do-markup-string               xref-layer)
  (do-markup-crossref-layer-close xref-class))

(define-environment-methods do-markup-crossref-layer
    ((xref-class crossref-location-class))
  :open  ((do-markup-default "CROSSREF-LAYER:OPEN"  (get-name xref-class))
          (do-markup-indent))
  :close ((do-markup-outdent)
          (do-markup-default "CROSSREF-LAYER:CLOSE" (get-name xref-class))))
@ %def do-markup-crossref-layer

<<Markup interface>>=
(defmacro markup-crossref-layer (&key open close class)
  (cond <<Check [[:open]] and [[:close]]>>
        <<Check [[:class]] for cross-reference class>>
        (t `(markup::define-list-environment-methods
             DO-MARKUP-CROSSREF-LAYER
             (,(if class
                   `(xrefcls (EQL ,(cdr (lookup-crossref-class *indexstyle*
                                                               class))))
                   '(xrefcls crossref-location-class)))
             :declare ((declare (ignore xrefcls)))
             :open  ,(when open  `((do-markup-string ,open)))
             :close ,(when close `((do-markup-string ,close)))))))
@ %def markup-crossref-layer


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The module root}

<<*>>=
;; $Id$

(lisp:in-package "MARKUP")
(lisp:provide "MARKUP")

(lisp:use-package "CLOS")
(lisp:require "base")
(lisp:use-package "BASE")
#+:XP (lisp:use-package "XP")
(lisp:require "locref")
(lisp:use-package "LOCREF")
(lisp:require "idxstyle")
(lisp:use-package "IDXSTYLE")
(lisp:require "index")
(lisp:use-package "INDEX")

<<Submodule \module{markup}>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))

;; this should be the last of the module since it defines the
;; additional package `xindy'.
<<Submodule \module{startup}>>
@

\subsubsection{The submodule root}

<<User-interface-definitions>>=
(eval-when (compile load eval)
  (defparameter *markup-user-interface-definitions*
    '(*markup-verbose-mode*
      *markup-verbose-open*
      *markup-verbose-close*
      markup-crossref-layer
      markup-crossref-layer-list
      markup-crossref-list
      markup-index
      markup-letter-group
      markup-letter-group-list
      markup-indexentry
      markup-indexentry-list
      markup-keyword
      markup-keyword-list
      markup-locclass-list
      markup-locref-class
      markup-attribute-group-list
      markup-attribute-group
      markup-locref-list
      markup-locref
      markup-locref-layer-list
      markup-locref-layer
      markup-range
      markup-trace
      )))
@ %def *markup-user-interface-definitions*

<<Export-list of submodule \module{markup}>>=
(export '*markup-user-interface-definitions*)
(export *markup-user-interface-definitions*)
@

<<Submodule \module{markup}>>=
;; $Id$

<<Markup definitions>>
<<Markup primitives>>
<<Method-defining primitives>>
<<Index markup>>
<<Letter group markup>>
<<Indexentry markup>>
<<Keyword markup>>
<<Location-class-group markup>>
<<Crossref-class-group markup>>
<<Attribute-group markup>>
<<Location-reference markup>>
<<Markup interface>>

<<User-interface-definitions>>
<<Export-list of submodule \module{markup}>>
@

<<RCS-Identifier>>=
("markup" . "$Id$")
@


%% $Log$
%% Revision 1.19  1997/01/23 15:10:41  kehr
%% Removed forgotten debug-output.
%%
%% Revision 1.18  1997/01/23 15:04:42  kehr
%% Added (markup-range :ignore-end).
%%
%% Revision 1.17  1997/01/23 14:11:45  kehr
%% Added support for (markup-range :length).
%%
%% Revision 1.16  1997/01/17 16:43:05  kehr
%% Several changes for new version 1.1.
%%
%% Revision 1.15  1996/08/02  14:11:59  kehr
%% Corrected bug when printing the percentage-list.
%%
%% Revision 1.14  1996/07/22  15:55:27  kehr
%% Replaced some of the oops-macros by nraw-macros. Removed apply-oops
%% macros.
%%
%% Revision 1.13  1996/07/18  15:54:28  kehr
%% Checkin after all changes that resulted from the define-letter-group
%% modification were finished.
%%
%% Revision 1.12  1996/07/16  14:06:21  kehr
%% Checkin after all the changes to the `define-letter-group(s)' commands
%% have been made.
%%
%% Revision 1.11  1996/07/03  18:41:43  kehr
%% Checkin after some modifications of the error-system and the loading of
%% indexstyle-modules have been made. Affects all modules.
%%
%% Revision 1.10  1996/06/24  09:13:17  kehr
%% Several changes in all Lisp-modules due to the new startup-module and
%% the implementation of the percentage bar appearing in the processing
%% phases.
%%
%% Revision 1.9  1996/06/03  10:01:53  kehr
%% Added support for treeing layered-location-references.
%%
%% Revision 1.8  1996/05/29  14:16:03  kehr
%% Complete checkin after the major changes in the markup. See ChangeLog
%% for details.
%%
%% Revision 1.7  1996/05/20  08:49:56  kehr
%% Minor modifications.
%%
%% Revision 1.6  1996/05/10  17:36:36  kehr
%% Wrote some more sophisticated macros that expand to several methods at
%% once. The source is now much more compact.
%%
%% Revision 1.5  1996/05/09  11:50:00  kehr
%% Changes in all submodules, due to macro-expansion problems during
%% compilation.
%%
%% Revision 1.4  1996/05/06  10:01:57  kehr
%% Minor changes in nearly all modules.
%%
%% Revision 1.3  1996/04/29  08:38:39  kehr
%% Started to implement teh new `markup'-submodule.
%%
%% Revision 1.2  1996/03/13  16:53:47  kehr
%% Don't remember specific changes. Just time to check-in.
%%
%% Revision 1.1  1996/01/23  12:17:09  kehr
%% First version of the module `markup'.
%%
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:)
