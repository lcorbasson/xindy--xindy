% $Id$
%----------------------------------------------------------------------
%
% xindy -- A Flexible Indexing System
% Technical Report 1997
% Institut für Theoretische Informatik, TH Darmstadt
%
% [LaTeX2e]
% (history at end)

\documentclass[titlepage,11pt]{article}
%\documentclass[titlepage,11pt,draft]{article}

\hyphenation{
  strength-en
  Make-In-dex
  }

\usepackage{jsdoc}
\usepackage{a4-9}
\usepackage{xspace}
\usepackage{itititle}
\usepackage{environments}
\usepackage{ssqquote}
\usepackage{ifthen}
\usepackage{theorem}
\usepackage{bslash}
\usepackage{alltt}
\usepackage{enumerate}
\usepackage{verbatim}
\usepackage{afterpage}
\usepackage{rotating}
\usepackage{epsfig}
\usepackage[hang,sf]{caption}
%\usepackage[textures,bottomafter]{draftcopy}
%\usepackage{version}

\def\TechReport{1}
\def\ReportMode{0}
\usepackage{stdwrk}

\usepackage{xindy}

\makeatletter
\renewcommand{\@oddfoot}{\textsf{DRAFT}\hfil\textsf{\thepage}\hfil\textsf{DRAFT}}
\makeatother

\frenchspacing

%%\def\mkidx{{\texttt{makeindex}}\xspace}
\def\mkidx{\emph{MakeIndex}\xspace}
\def\Xindy{{\normalfont\textsf{xindy}}\xspace}
\def\imkidx{{\emph{International MakeIndex}}\xspace}

\newcommand{\xindy}{%%
   \mbox{\normalfont%%
     \textsf{x\kern-0.6pt%%
       \shortstack{{\scriptsize$\circ$}\\[-2pt]\i}%%
       \kern-1pt%%
       ndy}%%}%%
     }\xspace}

\newcommand{\XINDY}{%
   \mbox{\normalfont\huge%%
         \textsf{x\shortstack{{\large$\circ$}\\\i}ndy}}}

%\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newlength\vertspace

\newenvironment{mfigure}[2]{%
  \begin{figure}[htbp]%
    \renewcommand{\tfigurecaption}%
                 {\caption{#1}}        % save the caption
    \renewcommand{\tfigurelabel}%
                 {\label{#2}}          % save the label
    \Hrule                             % start with horizontal line
    \vspace*{3mm}                      % small vertical space
}
{\vspace*{3mm}                         % another skip at the end
  \Hrule                               % another line
  \normalfont                          %
  \vskip\vertspace                     %
  \tfigurecaption                      % insert caption
  \tfigurelabel                        % and label
\end{figure}%                          % ok, we're done
}

\newenvironment{mtable}[2]{%
  \begin{table}[htbp]%
    \renewcommand{\ttablecaption}%
                 {\caption{#1}}        % save the caption
    \renewcommand{\ttablelabel}%
                 {\label{#2}}          % save the label
    \Hrule                             % start with horizontal line
    \vspace*{3mm}                      % small vertical space
}
{\vspace*{3mm}                         % another skip at the end
  \Hrule                               % another line
  \normalfont                          %
  \vskip\vertspace                     %
  \ttablecaption                       % insert caption
  \ttablelabel                         % and label
\end{table}%                           % ok, we're done
}

\begin{document}

\date{February 1997}
\title{\XINDY{}\\[1ex]%%
  Definition of an Indexing Model\\and its Implementation\\[2ex]
  \Huge\sffamily DRAFT VERSION}%%
\author{Roger Kehr}

\iti{Bericht TI-XXX/97}

\maketitle

{
  \let\oldbfseries\bfseries
  \def\newbfseries{\sffamily\oldbfseries}
  \let\bfseries\sffamily

  \begin{abstract}
    This report describes a new indexing model and its implementation.
    The model is the result of an analysis of existing indexes and an
    evaluation of several index processors, mainly \mkidx and \imkidx,
    for which we have analyzed their features and weaknesses in
    practical application areas.

    We have identified two orthogonal dimensions in an index, a
    vertical and a horizontal one. The vertical dimension consisting
    of index entries and keywords is mostly well understood. The
    theoretical part of our work mainly contributes to a formalization
    of the horizontal dimension of indexing, namely the location
    references and mechanisms involved in their processing.

    Based on this index model we have implemented the \xindy-system,
    an index processor that is a nearly full implementation of our
    model. Additionally, it contains a powerful declarative
    event-based dispatching scheme to implement complex markup
    strategies.

    We describe our model and some of the implementation details that
    may be of general interest, especially at the declarative
    object-oriented nature not only of the implementation, but also of
    the user interface itself.
  \end{abstract}

%%  \sffamily
%%  \tableofcontents
}
\parskip=0.2\baselineskip plus 2pt minus 1pt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\nocite{chicago}
%\nocite{texbook}
%\nocite{latex}
%\nocite{Chen:UCB-TR-87-347}
%\nocite{Schrod:Makeindex30}
%\nocite{Chen:SPE-19-9-897}
%\nocite{Schrod:CG-10-81}
%\nocite{Bentley:EPODD-1-1-3}
%\nocite{Lamb:EPODD-6-1-23}
%\nocite{Steele:common-lisp-2}
%\nocite{xindy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\emdash{--}

\def\Lisp{{\normalfont\textsc{Lisp}}\xspace}
\def\CL{{\normalfont\textsc{Common Lisp}}\xspace}
\def\CLOS{{\normalfont\textsc{Clos}}\xspace}
\def\dps{document preparation system\xspace}
\def\nroff{{\tt nroff}\xspace}
\def\term#1{\emph{#1}}
\def\pair#1{\mbox{$\langle$}#1\mbox{$\rangle$}}
\def\ts{\hspace*{0.9ex}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Introduction}

%%\mbox{}\medskip

\begin{raggedleft}
  \footnotesize\ssqfamily Sometimes it is desirable to index words
  that don't actually appear on the page.\\\ldots For example,
  Appendix I lists page 1 under `beauty', even though page 1 only
  contains the word `beautiful'. (The author felt that it was
  important to index `beauty'\\ because he had already indexed
  `truth'.)

  \smallskip

  \textsc{Donald E. Knuth}, The \TeX{}book (1984)%% p. 423

\end{raggedleft}

%\begin{zitat}
%  Sometimes it is desirable to index words that don't actually appear
%  on the page.\\%%
%  \ldots For example, Appendix I lists page 1 under
%  `beauty', even though page 1\\%%
%  only contains the word `beautiful'.  (The author felt that it was
%  important to index `beauty' because he had already indexed `truth'.)

%  \smallskip

%  \textsc{Donald E. Knuth}, The \textrm{\TeX{}book}
%  {\normalfont\textrm{(1984)}}%% p. 423

%\end{zitat}

\bigskip

\noindent%%
Today, the need to index information becomes more and more important,
to guide readers in finding the desired information efficiently and
effective. For large documents indexes are traditionally one form of
service that helps finding the desired information.

Compiling an index is still tedious work. First of all the indexer has
to decide what items should appear in the index. Furthermore it has to
be decided to which locations in the document the reader should be
guided first, separating important from less important occurrences of
items in a document.

Books are often not indexed by the authors themselves. For textbooks
it is necessary that the indexer has sufficient knowledge of the
problem area to make appropriate indexing decisions.  Unfortunately,
the index is very often the most neglected part of a
book.\footnote{Especially as they can be the source of inspiration (as
  the quotation of \textsc{D. E. Knuth} shows), as well as humour (see
  under \emph{kludges} in~\cite{Steele:common-lisp-2}).}

Most of nowadays word processors are still weak in supporting the
production of high-quality indexes, this might be one reason for the
deficiencies in many textbooks. Our work is an approach to give a
model of what an index is and how a good indexing system should
operate. Based on this model we present \xindy, our implementation of
this indexing model.

The rest of this paper is organized as follows:
section~\ref{sec:data-flow} describes the data flow between a \dps and
the indexing system and we characterize the involved processing
phases. In section~\ref{sec:index-model} we analyze the structure of
indexes, thus identifying the components an index consists of and
achieving detailed insight into the processing of location references.
Section~\ref{sec:implementation} describes the current implementation.
We present details of the processes involved in the transformation of
an index into its final form and how the internal representation
inside the model is tagged with markup information and fed back to the
\dps. Necessary design decisions in the implementation of the
\xindy-system are described and lessons learned from the project are
reported.


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Process of Indexing}
\label{sec:data-flow}

Current \dps{}s can be roughly divided into two categories: (a)
markup-based batch-processing systems such as
\TeX/\LaTeX~\cite{texbook,latex} or the \nroff family of document
formatters~\cite{nroff}, and (b) direct manipulation word processors
typically operating under some windowing system. One of the most
widespread used index processor in the first group is
\mkidx~\cite{Chen:UCB-TR-87-347,Chen:SPE-19-9-897}. The indexing
capabilities of the latter group are application dependent and
currently less flexible than \mkidx. Since they are not controllable
from outside we have concentrated mainly on \mkidx.
Figure~\ref{fig:data-flow} describes the typical data flow in the
first group of systems.

{\vertspace=-3ex
\begin{mfigure}
  {Typical data flow in \dps{}s}
  {fig:data-flow}
  \hspace*{1cm}\input{dataflow.latex}
\end{mfigure}}

\noindent The document is processed by the \dps{} that extracts the
indexing information, the so-called \term{raw index}. The raw index
comes in a system dependent format containing information about the
raw index entries.

The \term{parser} reads the raw index and transforms it into a
representation suitable for the index processor. Thus, it must be
adopted to the format of the \dps and the index processor.

The \term{index processor} reads two different data streams: (1) the
\term{index style}, describing how the index is to be processed and
tagged, and (2) the raw index. Typical processing tasks are: (a)
merging and sorting the index entries according to some alphabet, (b)
accumulating all location references with the same keyword into an
index entry, (c) decomposing and classifying location references, and
(d) merging and sorting the location references optionally followed by
a range-building phase.

After the index has been processed, its internal representation must
be fed back into the document preparation cycle. This is done through
the \term{markup backend} that outputs the internal format tagged with
appropriate markups defined in the index style in a representation
that can be used by the \dps to typeset the index.

From an abstract point of view the indexing process can be described
as an homomorphism mapping the raw index to the tagged index.
Figure~\ref{fig:homomorphism} illustrates this view.

{\vertspace=-1ex
\begin{mfigure}
  {Index processing as an homomorphism}
  {fig:homomorphism}
  \begin{center}
    \hspace*{-2.5cm}\input{homomorphism.latex}
    \vspace*{-1em}
  \end{center}
\end{mfigure}}

\noindent{}The raw index is mapped into an internal representation
through an \term{abstraction process}. This task is effectively done
with a parser. It transforms the raw index in a representation
suitable for processing the index. The indexing process is a
\term{transformation} yielding an abstract representation of the
index. In our system the result of the transformation is a tree
structure. This structure must now be output using a
\term{representation mapping} done with the markup backend.

The \mkidx system does not cleanly separate the three mappings of this
homomorphism. In \mkidx the parser is part of the indexing system. It
can be configured to accept a certain range of raw index formats, but
essentially the formats are rather restricted because it was designed
primarily as an index processor for the \TeX-system and its raw index
format. Additionally, the markup is partially directly derived from
the raw index. Thus, \mkidx operates on a level that more or less
directly maps the raw index to the tagged index. We have removed the
parser from the core indexing system and defined a general raw index
specification format.

In our specification format a \term{raw index entry} consists of a
keyword and a raw location reference. A \term{keyword} consists of a
list of strings. A \term{string} is a word over the underlying
\term{document alphabet}. The \term{raw location reference} is a
string.

Additionally, we have made the representation mapping highly
controllable by the user. This is a major improvement in the design of
index processors.

In this report we mainly concentrate on a description of the
transformation mapping and a brief description of the representation
mapping. A detailed description of the representation mapping can be
found in~\cite{CBM}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Indexing Model}
\label{sec:index-model}

\subsection{Definition of an Index}

Typically, indexes are collections of ordered keywords each one
followed by a list of \term{location references}. Usually the index is
part of the indexed document and the location references represent
locations in that document. At some stage in the document preparation
process the index is generated from the document information and fed
back to the \dps. This may actually change the locations at which some
of the keywords appear in the document. This could lead to an infinite
regression if the preparation cycle missed some form of fix-point
behaviour which is usually not a problem in practice.

Figure~\ref{fig:adv-index} shows an example index. Despite the fact
that such confusing indexes probably do not exist in practice, we
recognize the two-dimensional structure of an index.

{\vertspace=-1ex%%
  \begin{mfigure}%
  {Sample index with  section numbers and page numbers}%
  {fig:adv-index}%
  \centering%
  \begin{minipage}{9cm}%
    \begin{mkindex}
      \idx trees
      \subidx AVL, {\sffamily 2.3}
      \subidx natural, A-1, {\sffamily 2.1}
      \idx Fibonacci queues, \emph{see} priority queues
      \idx search
      \subidx binary, 11, 11a, {\sffamily 1.3}
      \subidx sequential, A-2, {\sffamily 1.2}
      \subidx ordered, {\sffamily 1.2.1}, \emph{see also} unordered search
      \subidx unordered, {\sffamily 1.2.2}
      \idx sorting
      \subidx quick sort, 37--41
      \idx priority queues
      \subidx Fibonacci, {\sffamily 3.3}
    \end{mkindex}%
  \end{minipage}%
\end{mfigure}}

\noindent In the \term{vertical dimension} the index is structured by
the keywords, since they actually serve as the key for the reader's
search.  The keywords form a hierarchy which is often visualized by
the level of indentation. This is not always the practice. For
example, the Chicago Manual of Style~\cite{chicago} recommends the
so-called \term{flush-and-hang style} or the \term{run-in indented
  style} that are visualizations of the appearance of index
hierarchies. As opposed to hierarchical indexes there is often need
for so-called \term{flat} indexes.

Along the \term{horizontal dimension} we identify the list of
\term{location references}. A location reference is an object that
serves as a reference to some location within the document. We can
observe different types of locations in documents such as page
numbers, section numbers, parts of the appendix, cross references,
etc.\ Most indexes contain only references to pages but there is a
wide application area in which pages are of less concern.


\subsection{Index Entries}

An index entry consists of a keyword which is a list of strings and a
list of location references.  Most indexes have a recursive structure
since an index entry can possibly be composed of other index entries.
Thus index entries may form a recursive structure.

A keyword consists of a list of \term{strings}. Strings are
\term{character sequences} over the underlying \term{alphabet} that is
used in the document preparation system such as ASCII or the ISO~Latin
family. Strings are denoted using the quote characters ``\ldots''. An
example keyword consisting of two strings might be (``search''
``sequential'').\footnote{We use parenthesis to denote list-based
  structures.} A keyword can be interpreted as the \term{path} in the
tree structure to the corresponding location references. This view
raises two basic questions: (a) how do we recognize that two keywords
and therefore strings are equal, and (b) how do we order them?

We first discuss the ordering process. Strings are usually ordered
according to the lexicographic order of the sequence of characters.
The order of characters in the underlying \dps often does not
correctly represent the language specific lexicographic order, being a
problem for most of the European languages. For instance, in many
Roman languages the accented letters such as \emph{\'a}, \emph{\`a},
\emph{\~a}, \emph{\^a}, \emph{\"a}, etc.\ are sorted like the
corresponding letter without an accent. Sorting based on the encoding
of these letters in the ISO~Latin-1 alphabet would frequently yield
undesired results. Another problem is that in many languages a letter
is actually composed of two or more letters of the underlying document
alphabet. For example, in Hungarian there are letters such as
\emph{Cs}, \emph{Ly}, \emph{Ny}, and Spanish has the letters
\emph{Ch}, \emph{Ll}. Furthermore, a keyword might contain formatter
dependent markup information that must be ignored when comparing
keywords.

This problem is discussed in detail in~\cite{Schrod:CG-10-81} and a
scheme called \term{keyword mappings} is proposed. A \term{merge key}
is generated from the initial key through the \term{merge mapping}.
Based on the merge key the so-called \term{sort key} is derived
through the \term{sort mapping}. The keyword mappings have been
incorporated into version three of \mkidx named
\imkidx~\cite{Schrod:Makeindex30} and are implemented using string and
regular expression substitutions. With these mapping mechanism an
initial string $s$ with its lexicographic order $l_s$ can be mapped
onto a string $t$ having a lexicographic order $l_t$ that better
represents the order of the language specific alphabet.

Additionally, the problem of \term{letter groups} has been solved
there, too. Letter groups usually appear as separate groups in the
tagged index, and thus must be identified correctly. In \imkidx the
letter groups are identified using a comparison of a prefix of a sort
key with a list of all letter groups declared in the index style.

The \imkidx project has shown that keyword mappings are an adequate
mechanism to describe (a) language dependent sorting orders, (b)
language dependent letter groups, and (c) to appropriately handle the
formatting information that might be part of the keywords itself.
Thus, we have incorporated this scheme with minor extensions into the
\xindy-system.


\subsection{Location References}
\label{sec:locations}

The second part of an index entry is the set of location references.
Mostly locations pointed to by the index are page numbers. In many
application areas this \term{physical location} of an indexed item is
of less interest, since often documents are built according to a more
\term{logical} structure the index must refer to. For example, in
Hypertext systems there are no page numbers. We give some examples of
these logical structures:
%%
\begin{description}
\item[Section-based Pages.]  References of the form
  ([arabic]--[arabic]): \emph{2--8}, \emph{2--12}, \emph{4--7},
  \emph{4--9}.

  This kind of structure appears often in large manuals or books
  divided into several parts.

\item[Hierarchical Sections.] References of the form
  ([arabic].[arabic].[\ldots]): \emph{1.1}, \emph{1.2.1}, \emph{2.1}.

\item[Regular Structures.] We give some examples:
  \begin{list}{$\circ$}{%
      \settowidth{\labelwidth}{x}%%
      \setlength{\leftmargin}{\labelwidth}%%
      \advance\leftmargin\labelsep}
  \item Bible verses: \emph{Genesis 1, 31}; \emph{Exodus 1, 7};
    \emph{Leviticus 2, 3}.
  \item Texts of Law: \textbf{1} \S436, \S446; \textbf{2} \S546.
  \item URLs:
    {\small\texttt{http://www.iti.informatik.th-darmstadt.de/xindy/}}.
  \end{list}

\item[Irregular Structures.] References of the form
  ([arabic]\{[alpha]\}): \emph{11}, \emph{11a}, \emph{17}, \emph{17c}.

  This kind of irregular structures consisting of mandatory and
  optional parts\footnote{Denoted with curly braces \{\ldots\}.}
  sometimes occurs in manuals that have new pages inserted between old
  ones. This preserves the overall structure by inserting, for
  instance, page \emph{11a} between page \emph{11} and \emph{12}.
\end{description}
%%
The different structures listed allow a characterization and
definition of location references.


\subsection{Location classes}

The detailed analysis of the requirements on location references and
their formal definition is the most important new aspect on processing
indexes. Typically, the \dps represents the location references as a
simple string. Thus, the index processor needs to parse the location
reference string and identify the components of the location reference
conforming to some description. Our model is based on the idea that
the location structures appearing in a document must be explicitly
defined in the index style. Such a definition is called a
\term{location class}. It intensionally describes all possible
location references matching this class. The index processor then
tries to match each location reference against its known location
classes and decomposes its structure, if a match was found.

The description of a location class $C$ consists of a list of
\term{alphabets} $\{\alpha_0, \alpha_1, \ldots, \alpha_n\}$. Typical
alphabets we encountered are: (a) arabic numbers, (b) roman numerals,
(c) letters, (d) words over the document alphabet such as
`\emph{Genesis}' or `\texttt{http}'. Thus, there are alphabets that
have a finite set of elements, e.g.\ the letters \{`A',
\ldots{},~`Z'\} or the alphabet \{`\emph{Genesis}', `\emph{Exodus}',
`\emph{Leviticus}'\}. An example of an \term{infinite} alphabet is the
set of arabic numbers. A finite alphabet can be declared by simply
listing all of its elements, thus $\alpha_i=\{l_0, l_1, \ldots, l_k\}$
with $l_j$ being the letters of the alphabet. Each letter is a string.
The sorting order inside an alphabet is simply derived from the
definition order ($l_i<l_j \Leftrightarrow i<j$). An alphabet
consisting of only one letter defines a \emph{separator}, i.e.\ a
string that is used to separate several components of a location
reference. Typical examples are dashes, dots, and blanks (`--', `.',
`\verb*| |').

Infinite alphabets cannot be enumerated and thus must be represented
as a function, mapping a string to an ordinal number.  \xindy, has
several built-in infinite alphabets such as arabic numbers and roman
numerals. If there is a need to define more infinite alphabets, this
can be done with a user-definable function implementing the necessary
mapping.

A location reference $L$ \term{matches} a location class $C$ if there
exists a sequence $L=s_1s_2\ldots{}s_n$ of strings such that holds
$\forall i.s_i\in \alpha_i$. Using alphabets to declare the structure
of a location class makes it possible to directly derive an ordinal
number for each $s_i$ separately. This enables one to define a natural
sorting order on a complete location class based on the
\term{lexicographic order} on the sequence $s$. For example, the bible
verses can be described in the index style using the following
definition:
%%
{\small\begin{alltt}
 (define-alphabet "bible-chapters" ("Genesis" "Exodus" "Leviticus"))
 (define-location-class "bible-verses"
   ("bible-chapters" :sep\footnote{The argument \texttt{:sep} declares the following argument to be a separator.} "\verb*| |" "arabic-numbers" :sep "," "arabic-numbers"))
\end{alltt}}
%%
\noindent This effectively matches all of the examples \emph{Genesis
  1, 31}; \emph{Exodus 3, 12}; and \emph{Leviticus 2, 3}. The sort key
of the location reference `\emph{Exodus 3, 12}' would then be
represented by the list of ordinal numbers
(2\ts3\ts12).\footnote{Assuming the first element of an alphabet has
  ordinal number `1' we obtain \emph{Exodus}$\rightarrow$2,
  \emph{3}$\rightarrow$3, and \emph{12}$\rightarrow$12.} Sorting bible
verses lexicographically based on these sort keys is now a trivial
task. Since some of the identified location structures exhibit
optional parts, such as the irregular structures presented above, our
model allows the definition of optional postfixes as well. These
location classes are named \term{variable location classes}. The
example of the manual with inserted pages is one instance of this type
of location classes.

Another problem is the potential ambiguity in the matching process.
Given the location classes ([arabic][alpha]) and ([arabic][roman]),
the following location references match both classes: \emph{1c},
\emph{2i}, \emph{7m}, since the set of the lowercase roman numerals
$\{c,i,l,m,v,x\}$ and the set of the lowercase latin letters
$\{a,\ldots,z\}$ are not disjoint.  We argue that this situation is
unlikely to occur in practice since the reader would be confused by
such location references, making this a rather pathological
case.\footnote{I hope so, since I actually found no meaningful
  counter-example.}

Location classes like index entries can have a recursive structure,
too. Often location references of the structure ([Alpha].[page]) are
typeset as \emph{A 1,3,7; B 5,12} instead of \emph{A.1, A.3, A.7, B.5,
  B.12}. The former example consists of two location references each
one containing other (sub-)location references, whereas the latter
consists of five different location references. \xindy offers
additional declarations to define \term{recursive location classes}.


\subsection{Attributes}

In practice location references are often typeset using different
font-shapes, informing the reader that a keyword occurs in different
meanings. For instance, in mathematical texts one wants to optically
distinguish the definition of a term from its usage. Systems such as
\mkidx defined the concept of \term{encapsulators} that were used to
encapsulate the location reference in a markup that caused the \dps to
typeset the location reference as needed.

In \xindy one can attach a so-called \term{attribute} to a location
reference. It is a tag that is used for processing purposes as well as
markup tasks. The markup mechanism is described in more detail in
section~\ref{sec:tagging}. We continue with a description of the
processing schemes for location references our model offers.


\subsection{Attribute Groups}

The analyzation of indexes has shown that location references of
different location classes usually appear separated from each other in
an index entry. Actually, it would be of dubious value to freely mix,
for instance, page numbers with section numbers. The list of location
references can therefore be partitioned into subsets for each
occurring location class.

Another observation is that some indexes separate the location
references of a location class under certain circumstances based on
criteria depending on the attributes of a location reference. For
example, we might want all definitions of a term appear before its
usage. To illustrate these ideas we use the font-shape roman for
location references with the attribute \emph{default} and the shape
boldface for \emph{definitions}. The difference between the two
versions would look like this:
%%
\begin{enumerate}[\quad a)]
\item 7, \textbf{10}, 11, \textbf{12}, \textbf{14}, 15, 17
\item \textbf{10}, \textbf{12}, \textbf{14}, 7, 11, 15, 17
\end{enumerate}
%%
Sequence a) is sorted according to the sort key of the location
references. In sequence b) all definitions appear first, thus the
attributes define a sorting criteria which is of higher priority than
the sort key. We describe these properties with the so-called
\term{attribute groups} that are an abstraction of the observed
phenomenon. An attribute group is defined by a set of attributes
belonging to it, such that the defined attribute groups constitute a
partition on the set of all attributes.\footnote{We have not modeled
  the case that an attribute appears in more than one attribute group,
  though under certain circumstances it might be an useful extension.}
The appropriate definitions in the index style for both examples are
shown here:
%%
\begin{enumerate}[\quad a)]
\item {\small\verb| (define-attributes ( ("definition"   "default") ))|}
\item {\small\verb| (define-attributes ( ("definition") ("default") ))|}
\end{enumerate}
%%
The argument of the declaration \texttt{define-attributes} must be a
list of all attribute groups. The only element in example~a) is the
attribute group consisting of both attributes. In contrast, example~b)
defines two attribute groups each consisting of only one attribute. In
this notation it is possible to define attributes groups as needed.


\subsection{Relations on Location References}

Beyond simply sorting the location references within an attribute
group there are other tasks that must be performed. The most important
one is that successive location references should under certain
circumstances be joined to form a \term{range}. For example, the
location references \emph{11}, \emph{12}, \emph{13}, \emph{14} should
be joined into the range \emph{11--14}.

\paragraph{Successor Relationship.} To be able to join successive
location references we need an exact definition of the successor
relationship among location references. We have already introduced a
total ordering on the location references using the sort key of a
location reference, but this is in general not enough to derive the
successor relationship. It may work for page numbers consisting of
arabic numbers or roman numerals, but in case of hierarchically
structured location classes it is not sufficient and may depend on the
actual document as we show now.

For example, we have page numbers of the form ([arabic]\{[alpha]\})
matching the location references \emph{11, 11a, 12}. The corresponding
sort keys are (11), (11\ts1) and (12). We can perhaps infer that (11)
could be written as (11\ts0) and then conclude that \emph{11a} is a
successor of \emph{11}, but we actually don't know if \emph{11a} and
\emph{12} are successors. As long as we do not know if there is
another location\footnote{Here we actually mean \emph{location} and
  not \emph{location reference}.} between \emph{11a} and \emph{12} we
cannot build the range \emph{11--12}, though it might be desirable in
the concrete case.

What actually causes the problem is a missing bijective mapping from
the sort key to the set of natural numbers, for which a well-defined
successor relationship exists. If this mapping would exist, we could
verify if \emph{11a} and \emph{12} are mapped onto two successive
natural numbers to decide if \emph{12} directly follows \emph{11a}.
There are two solutions to this problem: (a) the author of a document
explicitly declares \emph{12} to be a successor of \emph{11a}, tedious
but under certain circumstances acceptable, or (b) the \dps generates
this information automatically and adds it to the raw index as well.
We call this kind of missing information \term{document knowledge}
since it is contained in the document itself and must be made
available to the index processor for entirely solving the successor
problem.


\paragraph{The Principle of Superseding.} Till now we have concentrated
on building ranges among location references with the same attribute.
The next problem is how to solve this task in an attribute group
consisting of a mixture of location references with different
attributes.  First of all we observe that the location references
\textbf{11} and \emph{11} might indicate two different types of
occurrences of a term on page eleven. But how should this appear in
the index? Sometimes it may be desirable that there exists a natural
precedence among the attributes of an attribute group. For example, we
want to drop the location reference pointing to an usage of a term on a
page in favour of a definition on the same page. This saves space in
the resulting index and emphasizes the importance of a definition of a
term over its usage. But for other documents the author may want to
let both references coexist next to each other.

Thus the attributes among an attribute group must define a
superseding-relation indicating what location references with certain
attributes can be dropped in favour of the same location references
with other attributes.

\paragraph*{Virtual Location References.}

Sometimes a range cannot be built from a set of location references
with the same attribute, due to missing location references necessary
to complete a sequence. For example the location references \emph{11,
  12, 14, 15} cannot be joined to a range because \emph{13} is
missing. In case of an additional location reference \textbf{13}, one
could wish to build the range \emph{11--15} and show the \textbf{13}
separately resulting in the following sequence: \textbf{13},
\emph{11--15}.

This can be accomplished if the location references with the attribute
\emph{definition} would be seen as \emph{default} location references
in the phase of range building as well. We call these location
references \term{virtual} location references, because they do not
exist as real objects but are rather a way to simplify the process of
range building. A virtual object can be seen as the child of a real
object from which it is derived. Thus, virtual location references
appear if there is a relation among the attributes appearing in an
attribute group.\footnote{Actually it may be a relation among
  attributes appearing in different attribute groups as well.} In our
case there exists the virtual location reference [\emph{13}] behaving
as a normal \emph{default} location reference that helps to form the
range \emph{11--15}. If no range can be built, the virtual location
references disappear. Another option can be to eliminate the original
location reference (the one the virtual location reference is a child
of), if the virtual one helps building a range. There are two ways to
describe the relations among the attributes: (a) the so-called
\term{merge-to} relation $M$ between a source attribute and a target
attribute, and additionally (b) a \term{drop-if-merged} relation $D$,
for which must hold: $D\subseteq M$. Table~\ref{tab:virtuals} gives
examples of possible combinations for some specific relations.

{\vertspace=-2ex%%
  \begin{mtable}%
  {Range building in presence of virtual location references}
  {tab:virtuals}%
  \centering%

  \begin{tabular}{|c|r|c|c|l|c|}
    \hline
    \medrule\textsl{No.} &
    \multicolumn{4}{|c|}{\textsl{Ranges}} &
    \textsl{Location references}\\ \hline
    & \textsl{none} & \multicolumn{3}{|c|}{\textsl{allowed}} &\\ \cline{4-5}
    & & & \multicolumn{2}{|c|} {\term{merge-to}} &
    11 13 14 15 17 25\ \textbf{12 15 25}\\ \cline{5-5}
    & & & & \emph{drop-if-merged} &\\
    \hline\hline
    1 &$\circ$& & & & 11 13 14 17\ \textbf{12 15 25} \\
    2 & &$\circ$& & & 11 13--15 17\ \textbf{12 15 25} \\
    3 & &$\circ$&$\circ$& & 11--15 17\ \textbf{12 15 25} \\
    4 & &$\circ$&$\circ$&$\circ$& 11--15 17\ \textbf{25} \\
    \hline
    5 &$\circ$& & & & 11 \textbf{12} 13 14 \textbf{15} 17
    \textbf{25}\\
    6 & &$\circ$& & & 11 \textbf{12} 13--15 \textbf{15} 17
    \textbf{25}\\
    7 & &$\circ$ &$\circ$& & 11--15 \textbf{12 15} 17 \textbf{25}\\
    8 & &$\circ$ &$\circ$ &$\circ$& 11--15 17 \textbf{25} \\
    \hline%
  \end{tabular}%
\end{mtable}}

\enlargethispage{\baselineskip}

\noindent Examples~1--4 characterize the situation in which the attributes
\term{definition} and \emph{default} appear in two separate attribute
groups, whereas in the examples~5--8 both are in the same attribute
group and attribute \emph{definition} also supersedes attribute
\emph{default}. Without this restriction there would exist even more
alternatives. As we can see the additional relations may help to
compress the list of location references under certain circumstances.


\paragraph*{Dropping Across Hierarchies.}

The principle of dropping location references in favour of a more
compact representation has to be generalized to variable location
classes. Location references could be dropped across hierarchies if
they are subsumed by location references of a higher level. For
example, one may wish to transform the location references \emph{1, 2,
  2.1, 2.2, 2.2.1, 2.3, 3} of class ([arabic].\{[arabic].[arabic]\})
into one of the following representations:
%%
\begin{list}{$\circ$}{%
      \settowidth{\labelwidth}{x}%%
      \setlength{\leftmargin}{\labelwidth}%%
      \advance\leftmargin\labelsep}
\item Building of ranges separately for some layers:

  \emph{1--3, 2.1--2.3, 2.2.1} \ \ or \ \ \emph{1--3, 2.1, 2.2, 2.2.1, 2.3} .

\item Joining at higher levels is done in favour of joining at lower levels:

  \emph{1--3, 2.1--2.3} \ \ or just \ \ \emph{1--3} .

\item Not everything is joined and the explicit enumeration of
  remaining location references is varied:

  \emph{1, 2, 2.1--2.3, 3}

  \emph{1, 2, 2.1--2.3, 2.2.1, 3}

  \emph{1, 2, 2.1, 2.2, 2.2.1, 2.3, 3} .
\end{list}
%%
We will not further investigate the exact semantics of these examples,
since the rules for the different variants especially in conjunction
with virtual location references are complicated. One possible
formalization can be found in~\cite{xindy}.


\subsection{Cross References}

Cross references are references to redirect the readers interest to
other index entries. Often they are typeset as `\emph{see}\ldots' if
there are no location references in this index entry or `\emph{see
  also}\ldots' in case the reader should also look at another index
entry.

Cross references were accomplished in \mkidx using the encapsulators
presented previously. We have made cross references separate objects
in our indexing model. The user may define cross reference classes in
the index style. A cross reference can be attached an attribute in the
raw index specification format identifying the class of a cross
reference. This class attribute can be used to assign specific markup
to cross references. This allows for a much more flexible markup and
grouping mechanism than other index processors.

As an additional feature we distinguish between \term{checked} and
\term{unchecked} cross reference classes. Members of the former group
are checked, if they point to an existing entry in the index, thus
avoiding the annoying presence of cross references pointing to
non-existent index entries.


\subsection{Summary}

An index consists of a two-dimensional structure represented as a
tree. Figure~\ref{fig:index-tree} illustrates the structure of the
components an index consists of. The vertical dimension, the index
entries and their associated keywords are quite well understood. The
model of the keyword mappings covers many needs.  Our main
contribution is a formalization of the objects and processes that
participate in the horizontal dimension, namely alphabets, location
classes, attributes, attribute groups, the superseding relation, the
merge-to relation and the drop-if-merged relation. We have identified
the involved objects and have presented appropriate processing
schemes.

From an abstract point of view there are several topics the vertical
and horizontal dimensions share. Along both dimensions we have to
solve a \term{classification problem}. In terms of location references
we must decide the location class of a location reference, and for
keywords we must decide the equality of two keywords following a
\term{normalization} step. In terms of keywords the keyword mappings
are a solution to this problem, whereas in the horizontal dimension
the different relations (superseding, merge-to and drop-if-merged) are
solutions to this problem.

Another correspondence occurs with the sorting problem, which in both
cases is solved using appropriate mappings. In the vertical dimension
we use a mapping from keywords, consisting of a list of words over the
document alphabet, to another list in which each element is generated
using a injective mapping, namely the merge and sort mappings. This
list is then sorted lexicographically. The same process appears at the
horizontal dimension, except that we use a list of ordinal numbers to
represent the sort key of a location reference. It is possible for the
user to define arbitrary alphabets along both dimensions using two
completely different mechanisms.

Despite of these similarities we have shown that more complex
formalizations are necessary to describe the horizontal dimension than
are needed for the vertical dimension.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}
\label{sec:implementation}

Like \mkidx and \imkidx, \xindy is a \term{monolithic} system.
In~\cite{Bentley:EPODD-1-1-3} a \term{pipeline-based} system is
presented and the authors argue in favour of using \textsc{Unix} text
processing tools such as \texttt{awk} to write a tailored index
processor for each application. They emphasize the functional
decomposition of each member of the pipeline and compare it with
\mkidx. In fact, the indexes they processed with their tools are
simple compared to the model we present here. We believe that
developing an index processor capable of our indexing model will not
be possible using pipelines. Additionally, we wanted to implement a
system that is usable by many people, not only by experienced
\textsc{Unix}-programmers.


\subsection{Why Common Lisp?}

We started using \cpp{} as the programming language of our choice. We
aimed at a prototype implementation to verify the new aspects of our
indexing model in practice. We have found \cpp{} to be an inadequate
language for productively building such prototypes and switched to
\CL~\cite{Steele:common-lisp-2}. All necessary data structures are
part of the core language ready for use. The powerful macro-mechanism
enabled us to implement a system without writing a dedicated parser.
The \Lisp-interpreter is well suited for this purpose. This has
encouraged us to write the production system in \Lisp as well.

We have chosen the freely available
\texttt{clisp}-implementation\footnote{Available at
  \texttt{ftp://ma2s2.mathematik.uni-karlsruhe.de/pub/lisp/clisp/}.},
and have extended it with the GNU \texttt{rx} regular expression
library\footnote{Available at
  \texttt{ftp://prep.ai.mit.edu/pub/gnu/}.} for the keyword mappings.

The system was written using the literate programming system
\texttt{noweb}~\cite{Ramsey:LPT93}. It consists of about 4\,500 lines
of \Lisp code and 600 lines of \textsf{C} code. A parser for the
transformation from the \TeX{}-specific raw index in the format used
by \xindy has been implemented using 150 lines of \texttt{lex} code.
The printed \texttt{noweb} code covers around 150 pages of text. As a
comparison, \mkidx is written in 4\,300 lines of \textsf{C}.


\paragraph{The Raw Index}

The raw index specification format \xindy understands currently
consists of one polymorphic command that can be used to describe an
index entry consisting of the main key, an optional print key, the
location reference, its associated attribute, cross references and
other options. Each front end to \xindy must produce the format of the
raw index interface. Due to the length of the specification we do not
describe it here. The details can be found in~\cite{xindy:man}.


\paragraph{The Index Style}

As shown in figure~\ref{fig:data-flow} the index processor is
configured with the index style. The index style language consists of
about 35 different commands, most of them are used to specify the
markup of the final index. For a detailed description of all commands
refer to~\cite{xindy:man}. Since a complete description of an index
style can be rather complex we have adopted a module concept, that
enables one to decompose a complete index style into submodules. This
allows the reuse of components which in practice makes writing a style
file an easy task.  We have implemented a set of predefined styles
that can be used in an ad-hoc manner. Though compatibility with \mkidx
was not a design goal the distribution contains tools and modules,
that make \xindy mostly behave as a plug-in for \mkidx.

The superseding relation is implicitly implemented using the attribute
groups. We have implemented the superseding relation as the transitive
hull over the successor relation of the list defining an attribute
group. For example, the attribute group $(a_1, a_2, a_3)$ implicitly
defines the relation $\{ (a_1, a_2), (a_1, a_3), (a_2, a_3)\}$. This
is in our opinion a useful simplification of the model covering almost
all practical needs. Building ranges is only allowed on the last
hierarchy layer of a location reference. For variable location classes
it is not supported due to the lack of experience with useful
application domains. The merge-to and drop-if-merged relations are
implemented.


\subsection{Tagging the Index using Context Based Markup}
\label{sec:tagging}

%\afterpage{%%
%  {\vertspace=-2ex%%
%    \begin{mfigure}
%      {Tree structure of an index}
%      {fig:index-tree}
%      \begin{center}
%        \input{index.latex}
%      \end{center}
%    \end{mfigure}}
%  }

The tagging process directly operates on the tree representation as
illustrated in figure~\ref{fig:index-tree}. Framed items are
components that are directly derived from the raw index. The other
nodes are created in the processing phase and serve to structure the
index.

\begin{sidewaysfigure}
  \begin{center}
    \input{index-tree.latex}
  \end{center}
  \caption{Tree structure of an index}
  \label{fig:index-tree}
\end{sidewaysfigure}

We have chosen to support an environment-based style of defining
markup.  This kind of markup is used in \dps{}s such as \TeX{}, SGML
(with its instance HTML) and many others. The markup algorithm simply
traverses the index tree and when a node is entered or left a
\term{markup event} is generated. The user specifying the markup in
the index style needs to establish appropriate \term{event bindings}
that emit meaningful formatting info for the \dps.

Event bindings can be specialized relative to the context in which the
event was generated. This scheme is mostly inspired by the
\textsc{Stil}-project~\cite{stil}. At the time of the event the
traversing algorithm is in a context that consists of the path in the
index tree it came across from the root to the current node.

\begin{comment}

  Starting from the root-node in figure~\ref{fig:index-tree}, such a
  path could look like
%%
\def\emrm#1{\mbox{\normalfont\emph{#1}}}%%
{\small\begin{alltt}
       \emrm{index}
         \emrm{letter group =} "G"
           \emrm{index entry =} "foo"
             \emrm{location class =} "page-numbers"
               \emrm{attribute group =} 1
                 \emrm{location reference attribute =} "definition"
\end{alltt}}
%%
\enlargethispage{\baselineskip}%%
\noindent All markup commands in index
style have the following form:
%%
\def\itarg#1{\mbox{\normalfont\emph{#1}}}
\def\rmarg#1{\mbox{\normalfont #1}}
{\small\begin{alltt}
   (markup-\itarg{index-tree-node-name}
       \rmarg{[}:open \itarg{markup}\rmarg{]} \rmarg{[}:close \itarg{markup}\rmarg{]} \rmarg{[}:sep \itarg{markup}\rmarg{]}\footnote{Option \texttt{:sep} is applicable for list nodes only.}
       \rmarg{[\emph{context-dependent options such as} \texttt{:attr}, \texttt{:group}, \texttt{:class}, \texttt{:depth}, \ldots]})

\end{alltt}}

\noindent Since, by default, all fields are optional one can assign
the markup to only a subset of the context arguments. The accessible
context arguments depend on the type of the object that is to be
output. For example, the markup of ranges can be specialized on their
length allowing different markup for ranges of different length. Thus,
one can specify markup of the form \emph{22\,f.} for ranges of
length~1, \emph{31\,ff.} for ranges of length~2, and \emph{11--15} for
all other ranges. We have not made the whole context available to the
user, but instead have selected a meaningful subset for each markup
command.

This \term{context-based markup specification} allows to assign a
generic markup, for instance, for all location reference classes with
the command
{\small%%
\begin{verbatim}
 (markup-locref :open "\generic{" :close "}")
\end{verbatim}%%
}%%
\noindent but redefining the markup for the instances of a certain
location class as follows:
{\small%%
\begin{verbatim}
 (markup-locref :open "\special{" :close "}" :class "special-class")
\end{verbatim}%%
}%%

\end{comment}

\noindent The event dispatcher must decide which of the markup schemes
is the most specialized one that matches the current context. In the
above situation the second markup is selected for a location reference
of class \texttt{special-class}, but for all others the generic markup
is used, as defined by the first command. This kind of multi-argument
dispatching is based directly on the multi-method dispatching scheme
of \CLOS~\cite{Keene:88}. Internally, the system generates
\CLOS-methods at run-time when reading the index style that specialize
on the given arguments. At markup time the method dispatcher of \CLOS
to find the appropriate method.

The user interface represented by the index style is therefore itself
of object-oriented nature. The user declares objects such as alphabets
and location classes, of which location references are instances.
Markup can be attached orthogonally to these objects using
multi-argument dispatching. For users not familiar with this kind of
operation we have added a feature that traces the whole markup phase
so that generated events are shown and the markup is reported that is
emitted in response to these events. For a detailed description of the
markup model see~\cite{CBM}.


\paragraph{Open Problems} A markup specific problem we encountered is
that many flat indexes are typeset in the following way: \emph{index,
  1--10; $\widetilde{\ \ }$processor, 5--9, 13; $\widetilde{\ \
    }$style, 6, 8, 13}.  Thus repetitions of keywords are indicated
with an \term{abbreviation sign} (the tilde character in our case).
Allowing markup schemes of this kind can be implemented by making the
information that a keyword is repeated available in the markup
context. But for indexes appearing in textbooks this is only one part
of the solution. Usually the abbreviation signs are always suppressed
at the beginning of a new page in the document. This simplifies the
readers search for a keyword in the index. We argue that suppressing
abbreviation signs is mainly a problem that has to be solved by the
\dps but further investigation of the interaction of \dps{}s and index
processors is necessary to solve this problem.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\enlargethispage{\baselineskip}

\section{Conclusion}

An index consists of a two-dimensional structure. The vertical
dimension, the index entries and their corresponding keywords is
rather good understood due to the results of the \imkidx
project~\cite{Schrod:CG-10-81}. The horizontal dimension describing
the structure of location references and the processes in which they
are involved is explored. This work gives a first terminology of
involved components such as alphabets, location classes, attributes
and attribute groups and supposes a processing model that covers a
wide range of nowadays indexes. We have shown that there exist some
similarities in the processing of index entries and location
references that can be described as classification, normalization,
merging and sorting based on words over underlying alphabets in both
cases. The details of this analysis can be found in~\cite{xindy}.

Based on this model we have implemented \xindy{}, a system that is far
more flexible than comparable systems. It is tailorable to a wide
range of application domains, ranging from multi-language support to
quite complex document structures such as the bible or HTML-documents,
which can now be processed with our system. Its markup scheme based on
a highly declarative multi-argument dispatching strategy has proven to
be an adequate mechanism of describing context-based markup.

The implementation, a manual and a tutorial are available via WWW
under the URL
\texttt{http://www.iti.informatik.th-darmstadt.de/xindy}.  The author
is reachable via electronic mail under
\texttt{kehr@iti.informatik.th-darmstadt.de}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
\section{Acknowledgements}

I would like to thank Joachim Schrod and Klaus Guntermann for their
inspiring discussions, their valuable comments and precise corrections
and who made me feel comfortable in their working group. I'd also like
to thank Gabor Herr who was as excellent adviser in many
implementation questions especially concerning \Lisp. Without him this
project would not be in its current state. Finally, I'd like to thank
Prof.\ Waldschmidt who gave me the opportunity to continue this
project in his working group with financial support.
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\bibliographyIntroduction={The following books and papers were
  referenced in this report.}

\bibliography{bibliographie}
\bibliographystyle{abbrv}


\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% $Log$
% Revision 1.2  1997/02/14 17:30:40  kehr
% New version.
%
% Revision 1.1  1997/02/14 09:10:34  kehr
% New checkin for xindy.
%
%
