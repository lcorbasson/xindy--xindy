% $Id$
%----------------------------------------------------------------------
%
% xindy -- A Flexible Indexing System
% Technical Report 1997
% Institut für Theoretische Informatik, TH Darmstadt
%
% [LaTeX2e]
% (history at end)

%\documentclass[titlepage,11pt]{article}
\documentclass[titlepage,11pt,draft]{article}

\hyphenation{
  strength-en
  Make-In-dex
  }

\usepackage{jsdoc}
\usepackage{a4-9}
\usepackage{xspace}
\usepackage{itititle}
\usepackage{environments}
\usepackage{ssqquote}
\usepackage{ifthen}
\usepackage{theorem}
\usepackage{bslash}
\usepackage{alltt}
\usepackage{enumerate}
\usepackage{verbatim}
\usepackage{afterpage}
\usepackage{rotating}
\usepackage{epsfig}
\usepackage[hang,sf]{caption}
%\usepackage[textures,bottomafter]{draftcopy}
%\usepackage{version}

\def\TechReport{1}
\def\ReportMode{0}
\usepackage{stdwrk}

\usepackage{xindy}

\makeatletter
\renewcommand{\@oddfoot}{\textsf{DRAFT}\hfil\textsf{\thepage}\hfil\textsf{DRAFT}}
\makeatother

\frenchspacing

%%\def\mkidx{{\texttt{makeindex}}\xspace}
\def\mkidx{\emph{MakeIndex}\xspace}
\def\Xindy{{\normalfont\textsf{xindy}}\xspace}
\def\imkidx{{\emph{International MakeIndex}}\xspace}

\newcommand{\xindy}{%%
   \mbox{\normalfont%%
     \textsf{x\kern-0.6pt%%
       \shortstack{{\scriptsize$\circ$}\\[-2pt]\i}%%
       \kern-1pt%%
       ndy}%%}%%
     }\xspace}

\newcommand{\XINDY}{%
   \mbox{\normalfont\huge%%
         \textsf{x\shortstack{{\large$\circ$}\\\i}ndy}}}

%\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newlength\vertspace

\newenvironment{mfigure}[2]{%
  \begin{figure}[htbp]%
    \renewcommand{\tfigurecaption}%
                 {\caption{#1}}        % save the caption
    \renewcommand{\tfigurelabel}%
                 {\label{#2}}          % save the label
    \Hrule                             % start with horizontal line
    \vspace*{3mm}                      % small vertical space
}
{\vspace*{3mm}                         % another skip at the end
  \Hrule                               % another line
  \normalfont                          %
  \vskip\vertspace                     %
  \tfigurecaption                      % insert caption
  \tfigurelabel                        % and label
\end{figure}%                          % ok, we're done
}

\newenvironment{mtable}[2]{%
  \begin{table}[htbp]%
    \renewcommand{\ttablecaption}%
                 {\caption{#1}}        % save the caption
    \renewcommand{\ttablelabel}%
                 {\label{#2}}          % save the label
    \Hrule                             % start with horizontal line
    \vspace*{3mm}                      % small vertical space
}
{\vspace*{3mm}                         % another skip at the end
  \Hrule                               % another line
  \normalfont                          %
  \vskip\vertspace                     %
  \ttablecaption                       % insert caption
  \ttablelabel                         % and label
\end{table}%                           % ok, we're done
}

\begin{document}

\date{May 1997}
\title{\mbox{}\\[0.5ex]%%
  \XINDY{}\\[1ex]%%
  Definition of an Indexing Model\\and its Implementation\\[2ex]
  %%\Huge\sffamily DRAFT VERSION
  }
\author{Roger Kehr}

\iti{Bericht TI-11/97}

\maketitle

{
  \let\oldbfseries\bfseries
  \def\newbfseries{\sffamily\oldbfseries}
  \let\bfseries\sffamily

  \begin{abstract}
    This report describes a new indexing model and its implementation.
    The model is the result of an analysis of existing indexes and an
    evaluation of several index processors, mainly \mkidx and \imkidx,
    for which we have analysed their features and weaknesses in
    practical applications.

    We have identified two orthogonal dimensions in an index. The
    vertical dimension consisting of index entries and keywords is
    mostly well understood. The theoretical part of our work mainly
    contributes to a formalisation of the horizontal dimension of
    indexing, namely the location references and mechanisms involved
    in their processing.

    Based on our indexing model we have implemented the \xindy-system,
    an index processor that is a nearly full implementation of our
    model.  Additionally, it contains a powerful declarative
    event-based dispatching scheme to support complex markup
    strategies.

    We describe our model and some of the implementation details that
    may be of general interest, especially the declarative
    object-oriented nature of the user interface.

  \end{abstract}

%%  \sffamily
%%  \tableofcontents
}
\parskip=0.2\baselineskip plus 2pt minus 1pt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\nocite{chicago}
%\nocite{texbook}
%\nocite{latex}
%\nocite{Chen:UCB-TR-87-347}
%\nocite{Schrod:Makeindex30}
%\nocite{Chen:SPE-19-9-897}
%\nocite{Schrod:CG-10-81}
%\nocite{Bentley:EPODD-1-1-3}
%\nocite{Lamb:EPODD-6-1-23}
%\nocite{Steele:common-lisp-2}
%\nocite{xindy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\emdash{--}

\def\Lisp{{\normalfont\textsc{Lisp}}\xspace}
\def\STIL{{\normalfont\textsc{Stil}}\xspace}
\def\CL{{\normalfont\textsc{Common Lisp}}\xspace}
\def\CLOS{{\normalfont\textsc{Clos}}\xspace}
\def\dps{document preparation system\xspace}
\def\nroff{{\tt nroff}\xspace}
\def\term#1{\emph{#1}}
\def\pair#1{\mbox{$\langle$}#1\mbox{$\rangle$}}
\def\ts{\hspace*{0.9ex}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Introduction}

%%\mbox{}\medskip

\begin{raggedleft}
  \footnotesize\ssqfamily Sometimes it is desirable to index words
  that don't actually appear on the page.\\\ldots For example,
  Appendix I lists page 1 under `beauty', even though page 1 only
  contains the word `beautiful'. (The author felt that it was
  important to index `beauty'\\ because he had already indexed
  `truth'.)

  \smallskip

  \textsc{Donald E. Knuth}, The \TeX{}book (1984)%% p. 423

\end{raggedleft}

%\begin{zitat}
%  Sometimes it is desirable to index words that don't actually appear
%  on the page.\\%%
%  \ldots For example, Appendix I lists page 1 under
%  `beauty', even though page 1\\%%
%  only contains the word `beautiful'.  (The author felt that it was
%  important to index `beauty' because he had already indexed `truth'.)

%  \smallskip

%  \textsc{Donald E. Knuth}, The \textrm{\TeX{}book}
%  {\normalfont\textrm{(1984)}}%% p. 423

%\end{zitat}

\bigskip

\noindent%%
Today, the need to index information becomes more and more important,
to guide readers in finding the desired information efficiently and
effective. For large documents indexes are traditionally one form of
service that helps finding the desired information.

Compiling an index is still a tedious work. First of all the indexer
has to decide what items should appear in the index. Furthermore it
has to be decided to which locations in the document the reader should
be guided first, separating important from less important occurrences
of items in a document.

Books are often not indexed by the authors themselves. For textbooks
it is necessary that the indexer has sufficient knowledge of the
problem area to make appropriate indexing decisions.  Unfortunately,
the index is very often the most neglected part of a
book.\footnote{Especially as it can be used to express feelings (as
  shown by the quotation of \textsc{D. E. Knuth}), as well as humour
  (see index entry for \emph{kludges}
  in~\cite{Steele:common-lisp-2}).}

Most of nowadays word processors are still weak in supporting the
production of high-quality indexes, which might be one reason for the
deficiencies found in many textbooks. Our work is an approach to give
a model of what an index is and how a good indexing system should
operate. Based on this model we present \xindy, our implementation of
this indexing model.

The rest of this paper is organised as follows:
section~\ref{sec:data-flow} describes the data flow between a \dps and
the indexing system and we characterise the involved processing
phases. In section~\ref{sec:index-model} we analyse the structure of
indexes, thus identifying the components an index consists of and
achieving detailed insight into the processing of location references.
Section~\ref{sec:implementation} describes the current implementation.
We present details of the processes involved in the transformation of
an index into its final form and how the internal representation
inside the model is tagged with markup information and fed back to the
\dps. Necessary design decisions in the implementation of the
\xindy-system are described and lessons learned from the project are
reported.


\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Flow in the Indexing Process}
\label{sec:data-flow}

Current \dps{}s can be roughly divided into two categories: (a)
markup-based batch-processing systems such as
\TeX/\LaTeX~\cite{texbook,latex} or the \nroff family of document
formatters~\cite{nroff}, and (b) direct manipulation word processors
typically operating under some windowing system. One of the most
widespread used index processor in the first group is
\mkidx~\cite{Chen:UCB-TR-87-347,Chen:SPE-19-9-897}. The indexing
capabilities of the latter group are less powerful than \mkidx and not
controllable from outside. Therefore, we have concentrated on indexing
functionalities in the first group. Figure~\ref{fig:data-flow}
describes the typical data flow in this group of systems.

{\vertspace=-3ex
\begin{mfigure}
  {Typical data flow in \dps{}s}
  {fig:data-flow}
  \hspace*{1cm}\input{dataflow.latex}
\end{mfigure}}

\noindent The document is processed by the \dps{} that extracts the
indexing information, the so-called \term{raw index}. The raw index
comes in a system dependent format containing information about the
raw index entries.

The \term{parser} reads the raw index and transforms it into a
representation suitable for the index processor. That means, it must
be adopted to the format of the \dps and the index processor.

The \term{index processor} reads two different data streams: (1) the
\term{index style}, describing how the index is to be processed and
tagged, and (2) the raw index. Typical processing tasks are: (a)
merging and sorting the index entries according to some alphabet, (b)
accumulating all location references with the same keyword into an
index entry, (c) decomposing and classifying location references, and
(d) merging and sorting the location references optionally followed by
a range-building phase.

After the index has been processed, its internal representation must
be fed back into the document preparation cycle. This is done through
the \term{markup backend} that outputs the internal format tagged with
appropriate markups defined in the index style in a representation
that can be used by the \dps to typeset the index.

From an abstract point of view the indexing process can be described
as a homomorphism, mapping the raw index to the tagged index.
Figure~\ref{fig:homomorphism} illustrates this view.

{\vertspace=-1ex
\begin{mfigure}
  {Index processing as a homomorphism}
  {fig:homomorphism}
  \begin{center}
    \hspace*{-2.5cm}\input{homomorphism.latex}
    \vspace*{-1em}
  \end{center}
\end{mfigure}}

\noindent{}The raw index is mapped into an internal representation
through an \term{abstraction process}. This task is effectively done
with a parser. It transforms the raw index in a representation
suitable for processing the index. The indexing process is a
\term{transformation} yielding an abstract representation of the
index. In our system the result of the transformation is a tree
structure. An appropriate output form is achieved through the
\term{representation mapping} done with the markup backend.

The \mkidx system does not cleanly separate the three mappings of this
homomorphism. In \mkidx the parser is part of the indexing system. It
can be configured to accept a certain range of raw index formats, but
essentially the formats are rather restricted because it was designed
primarily as an index processor for the \TeX-system and its raw index
format. Additionally, the markup is in parts directly derived from the
raw index. Thus, \mkidx operates on a level that more or less directly
maps the raw index to the tagged index. We have removed the parser
from the core indexing system and defined a general raw index
specification format.

In our specification format a \term{raw index entry} consists of a
keyword and a raw location reference. A \term{keyword} consists of a
list of strings. A \term{string} is a word over the underlying
\term{document alphabet}. The \emph{raw location reference} is a
string.

Additionally, we have made the representation mapping highly
controllable by the user. This is a major improvement in the design of
index processors.

In this report we mainly concentrate on a description of the
transformation mapping and a brief description of the representation
mapping. A detailed description of the representation mapping can be
found in~\cite{CBM}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Indexing Model}
\label{sec:index-model}

\enlargethispage{\baselineskip}

\subsection{Definition of an Index}

Typically, indexes are collections of ordered keywords each one
followed by a list of \term{location references}. Usually the index is
part of the indexed document and the location references represent
locations within that document. At some stage in the document
preparation process the index is generated from the document
information and fed back to the \dps.

Figure~\ref{fig:adv-index} shows an example index. Despite the fact
that such confusing indexes probably do not exist in practice, we
recognise the two-dimensional structure of an index.

{\vertspace=-1ex%%
  \begin{mfigure}%
  {Sample index with  section numbers and page numbers}%
  {fig:adv-index}%
  \centering%
  \begin{minipage}{9cm}%
    \begin{mkindex}
      \idx trees
      \subidx AVL, {\sffamily 2.3}
      \subidx natural, A-1, {\sffamily 2.1}
      \idx Fibonacci queues, \emph{see} priority queues
      \idx search
      \subidx binary, 11, 11a, {\sffamily 1.3}
      \subidx sequential, A-2, {\sffamily 1.2}
      \subidx ordered, {\sffamily 1.2.1}, \emph{see also} unordered search
      \subidx unordered, {\sffamily 1.2.2}
      \idx sorting
      \subidx quick sort, 37--41
      \idx priority queues
      \subidx Fibonacci, {\sffamily 3.3}
    \end{mkindex}%
  \end{minipage}%
\end{mfigure}}

\noindent In the \term{vertical dimension} the index is structured by
the keywords, since they actually serve as the key for the reader's
search.  The keywords form a hierarchy which is often visualised by
the level of indentation. This is not always the practice. For
example, the Chicago Manual of Style~\cite{chicago} recommends the
so-called \term{flush-and-hang style} or the \term{run-in indented
  style} that are visualisations of the appearance of index
hierarchies. As opposed to hierarchical indexes there is often need
for so-called \term{flat} indexes.

Along the \term{horizontal dimension} we identify the list of
\term{location references}. A location reference is an object that
serves as a reference to some location within the document. We can
observe different types of locations in documents such as page
numbers, section numbers, parts of the appendix, cross references,
etc.\ Most indexes contain only references to pages but there are many
application areas in which pages are of less concern or don't even
exist.


\subsection{Index Entries}

An index entry consists of a keyword which is a list of strings and a
list of location references.  Most indexes have a recursive structure
since an index entry can possibly be composed of other (sub-)index
entries. Thus index entries may form a recursive structure.

A keyword consists of a list of \term{strings}. Strings are
\term{character sequences} over the underlying \term{alphabet} that is
used in the document preparation system such as ASCII or the ISO~Latin
family. Strings are denoted using the quote characters ``\ldots''. An
example keyword consisting of two strings might be (``search''
``sequential''). We use parenthesis to denote list-based structures. A
keyword can be interpreted as the \term{path} in the tree structure to
the corresponding location references. This view raises two basic
questions: (a) how do we recognise that two keywords and therefore
strings are equal, and (b) how do we order them?

We first discuss the ordering problem. Strings are usually ordered
according to the lexicographic order of the sequence of characters.
The order of characters in the underlying \dps often does not
correctly represent the language specific lexicographic order, being a
problem for most of the European languages. For instance, in many
Roman languages the accented letters such as \emph{\'a}, \emph{\`a},
\emph{\~a}, \emph{\^a}, \emph{\"a}, etc.\ are sorted like the
corresponding letter without an accent. Sorting based on the encoding
of these letters in the ISO~Latin-1 alphabet would frequently yield
undesired results. Another problem is that in many languages a letter
is actually composed of two or more letters of the underlying document
alphabet. For example, in Hungarian there are letters such as
\emph{Cs}, \emph{Ly}, \emph{Ny}, and Spanish has the letters
\emph{Ch}, \emph{Ll}. Furthermore, a keyword might contain formatter
dependent markup information that must be ignored when comparing
keywords. This problem is discussed in detail
in~\cite{Schrod:CG-10-81} and a scheme called \term{keyword mappings}
is proposed. A \term{merge key} is generated from the initial key
through the \term{merge mapping}. From the merge key the so-called
\term{sort key} is derived through the \term{sort mapping}.  Keyword
mappings have been incorporated into version three of \mkidx named
\imkidx~\cite{Schrod:Makeindex30} and are implemented using string and
regular expression substitutions. With these mapping mechanism an
initial string $s$ with its lexicographic order $l_s$ can be mapped
onto a string $t$ having a lexicographic order $l_t$ that better
represents the order of the language specific alphabet.

The problem of equality is solved with the merge mapping. Two keywords
are \term{equal} iff they are mapped onto the same merge key. The sort
key is then used to order the keywords solving the ordering problem.

The problem of \term{letter groups} has been solved in \imkidx, too.
Letter groups usually appear as separate groups in the tagged index,
and thus must be identified correctly. Letter groups are identified
using a comparison of a prefix of a sort key with a list of all letter
groups declared in the index style. This model assumes that letter
groups are built using a prefix of the sort key. Other models are not
supported.

Though keyword mappings can be used to describe (a) language dependent
sorting orders, (b) language dependent letter groups, and (c) to
appropriately handle the formatting information that might be part of
the keywords itself, it is still weak from the users perspective.
Complex sorting schemes such as the French sorting rules described in
the ISO~14651 standard \emph{International String
  Ordering}~\cite{ISO14651} are hard to express in the current model.
The \imkidx model is essentially a \term{string rewriting system}
implemented with string and regular expression substitutions. The most
important weakness with such a system is that it operates at the
character level and does not work for more abstract objects, which
might simplify the specification of sort rules. The ISO standard
describes a different method for sorting strings that is based on a
table-lookup specification of sorting rules which in some cases
simplifies the specification of sorting rules.

We have incorporated the keyword mapping scheme from \imkidx
with minor extensions into \xindy. A new scheme is under development
that unifies and extends the concepts of the \imkidx and the ISO
standard.


\subsection{Location References}
\label{sec:locations}

The second part of an index entry is the set of location references.
Mostly locations pointed to by the index are page numbers. In many
application areas this \term{physical location} of an indexed item is
of less interest, since often documents are built according to a more
\term{logical} structure the index must refer to. For example, in
Hypertext systems there are no page numbers. We give some examples of
these logical structures:
%%
\begin{description}
\item[Regular Structures]\mbox{}\par
  \begin{list}{$\circ$}{%
      \settowidth{\labelwidth}{x}%%
      \setlength{\leftmargin}{\labelwidth}%%
      \advance\leftmargin\labelsep}
  \item Chapter-based pages of the form ([arabic]--[arabic]): \emph{2--8},
    \emph{2--12}, \emph{4--7}, \emph{4--9}.
  \item Texts of Law: \textbf{1} \S436, \S446; \textbf{2} \S546.
  \item URLs:
    {\small\texttt{http://www.iti.informatik.th-darmstadt.de/xindy/}}.
  \end{list}

\item[Variable Structures]\mbox{}\par
  \begin{list}{$\circ$}{%
      \settowidth{\labelwidth}{x}%%
      \setlength{\leftmargin}{\labelwidth}%%
      \advance\leftmargin\labelsep}
  \item Manual pages of the form ([arabic]\{[alpha]\}): \emph{11},
    \emph{11a}, \emph{17}, \emph{17c}.

    This kind of irregular structures consisting of mandatory and
    optional parts\footnote{Denoted with curly braces \{\ldots\}.}
    sometimes occurs in manuals that have new pages inserted between
    old ones. This preserves the overall structure by inserting, for
    instance, page \emph{11a} between page \emph{11} and \emph{12}.

  \item Bible verses: \emph{Genesis 1, 31}; \emph{Exodus 1, 7};
    \emph{Leviticus 2, 3}; \emph{Psalm 47}.

  \item Hierarchical Sections of the form
    ([arabic]\{.[arabic].[\ldots]\}): \emph{1.1}, \emph{1.2.1},
    \emph{2.1}.
  \end{list}
\end{description}
%%
A structural description of location references is done with the
concept of \term{location classes}.


\subsection{Location classes}

The detailed analysis of the requirements on location references and
their formal definition is the most important new aspect on processing
indexes. Typically, the \dps represents the location references as a
simple string. Thus, the index processor needs to parse the location
reference string and identify the components of the location reference
conforming to some description. Our model is based on the idea that
the location structures appearing in a document must be explicitly
defined in the index style. A so-called \term{location class}
intensionally describes all possible location references matching this
class. The index processor then tries to match each location reference
against its known location classes and decomposes its structure, if a
match was found.

The description of a location class $C$ is a list of \term{alphabets}
$(\alpha_0, \alpha_1, \ldots, \alpha_n)$. Typical alphabets we
encountered are: (a) arabic numbers, (b) roman numerals, (c)~letters,
(d) words over the document alphabet such as `\emph{Genesis}' or
`\texttt{http}'. Thus, there are alphabets that are actually sequences
of elements of \term{finite length}, e.g.\ the letters \{`A',
\ldots{},~`Z'\} or the alphabet \{`\emph{Genesis}', `\emph{Exodus}',
`\emph{Leviticus}'\}. A sequence of finite length can be declared by
simply listing all of its elements, thus $\alpha_i=\{l_0, l_1, \ldots,
l_k\}$ with $l_j$ being the letters of the alphabet. The sorting order
inside an alphabet is simply derived from the order of its letters
($l_i<l_j \Leftrightarrow i<j$). An alphabet consisting of only one
letter defines a \term{separator}, i.e.\ a string that is used to
separate several components of a location reference. Typical examples
are dashes, dots, and blanks (`--', `.', `\verb*| |').

An example of a sequence of \term{infinite length} is the set of
arabic numbers. Sequences of infinite length must at least be
\term{enumerable} to be processed by our system. They cannot be
entirely enumerated and thus must be represented as a function,
mapping a string to an ordinal number. \xindy, has several built-in
\term{enumerable sequences} such as arabic numbers and roman numerals.
If there is a need to define more such sequences, this can be done
with a user-definable function implementing the necessary mapping. In
the following the notion of alphabet covers both, alphabets and
enumerable sequences.

A location reference $L=s_1\ldots{}s_n$ \term{matches} a location
class $C$ iff $\forall i.s_i\in \alpha_i$. Using alphabets to declare
the structure of a location class allows to directly derive an ordinal
number for each $s_i$ separately. A location reference can then be
represented by the sequence of ordinal numbers of all $\alpha_i$. This
sequence is called the \term{sort key} of a location reference. This
enables one to define a natural sorting order on a location class
based on the \term{lexicographic order} of the sort key.

%\newpage

\noindent For example, bible verses can be described in the index
style using the following definition:
%%
{\small\begin{alltt}
 (define-alphabet "bible-chapters" ("Genesis" "Exodus" "Leviticus"))
 (define-location-class "bible-verses"
   ("bible-chapters" :sep\footnote{The argument \texttt{:sep} declares the following argument to be a separator.} "\verb*| |" "arabic-numbers" :sep "," "arabic-numbers"))
\end{alltt}}
%%
\noindent This effectively matches all of the examples \emph{Genesis
  1, 31}; \emph{Exodus 3, 12}; and \emph{Leviticus 2, 3}. The sort key
of the location reference `\emph{Exodus 3, 12}' is then the sequence
of ordinal numbers (2\ts3\ts12).\footnote{Assuming the first element
  of an alphabet has ordinal number `1' we obtain
  \emph{Exodus}$\rightarrow$2, \emph{3}$\rightarrow$3, and
  \emph{12}$\rightarrow$12.} Sorting bible verses lexicographically
based on sort keys is now a trivial task. Since some of the identified
location structures have optional parts, such as the irregular
structures presented above, our model allows the definition of
optional suffixes as well. These location classes are named
\term{variable location classes}. The example of the manual with
inserted pages is one instance of this type of location classes.

Another problem is the potential ambiguity in the matching process.
Given the location classes ([arabic][alpha]) and ([arabic][roman]),
the following location references match both classes: \emph{1c},
\emph{2i}, \emph{7m}, since the set of the lowercase roman numerals
$\{c,i,l,m,v,x\}$ and the set of the lowercase Latin letters
$\{a,\ldots,z\}$ are not disjoint.  We argue that this situation is
unlikely to occur in practice since the reader would be confused by
such location references, making this a rather pathological
case.\footnote{We hope so, since we actually found no meaningful
  counter-example.}

Location classes like index entries can have a recursive structure,
too. Often location references of the structure ([Alpha].[arabic]) are
typeset as \emph{A 1,3,7; B 5,12} instead of \emph{A.1, A.3, A.7, B.5,
  B.12}. The example shows of two location references each one
containing other (sub-)location references, whereas the latter
consists of five different location references. \xindy offers
additional declarative means to define \term{recursive location
  classes}.


\subsection{Attributes}

In practice location references are often typeset using different
font-shapes, informing the reader of the occurence of a keyword in
different meanings. For instance, in mathematical texts one wants to
optically distinguish the definition of an entity from its usage.
Systems such as \mkidx defined the concept of \term{encapsulators}
used to encapsulate the location reference in a markup that caused the
\dps to typeset the location reference as needed.

In \xindy one can attach a so-called \term{attribute} to a location
reference. It is a tag that is used for index processing purposes as
well as markup tasks. The markup mechanism is described in more detail
in section~\ref{sec:tagging}. We continue with a description of the
processing schemes for location references offered in our model.


\subsection{Attribute Groups}

The analysis of indexes has shown that location references of
different location classes usually appear separated from each other in
an index entry. Actually, it would be of dubious value to freely mix,
for instance, page numbers with section numbers. The list of location
references can therefore be partitioned into subsets for each
occurring location class.

Another observation is that some indexes separate the location
references of a location class under certain circumstances based on
criteria depending on the attributes of a location reference. For
example, we might want all references to a definition of a term to
appear before the references to its usage. To illustrate these ideas
we use the font-shape roman for location references with the attribute
\emph{default} and the shape boldface for \emph{definitions}. The
difference between the two versions would look like this:
%%
\begin{enumerate}[\quad a)]
\item \ \ 7, \textbf{10}, 11, \textbf{12}, \textbf{14}, 15, 17
\item \ \ \textbf{10}, \textbf{12}, \textbf{14}, 7, 11, 15, 17
\end{enumerate}
%%
Sequence a) is sorted according to the sort key of the location
references. In sequence b) all definitions appear first, thus the
attributes define a sorting criteria which is of higher priority than
the sort key. We describe these properties with the so-called
\term{attribute groups} that are an abstraction of the observed
phenomenon. An attribute group is defined by a set of attributes
belonging to it, such that the defined attribute groups constitute a
partition on the set of all attributes.\footnote{We have not modeled
  the case that an attribute appears in more than one attribute group,
  though under certain circumstances it might be an useful extension.}
The appropriate definitions in the index style for both examples are
shown here:
%%
\begin{enumerate}[\quad a)]
\item {\small\verb| (define-attributes ( ("definition"   "default") ))|}
\item {\small\verb| (define-attributes ( ("definition") ("default") ))|}
\end{enumerate}
%%
The argument of the declaration \texttt{define-attributes} must be a
list of all attribute groups. The only element in example~a) is the
attribute group consisting of both attributes. In contrast, example~b)
defines two attribute groups each consisting of only one attribute. In
this notation it is possible to define attributes groups as needed.
Location references are sorted for each attribute group separately
based on the position of an attribute in an attribute group.


\subsection{Relations on Location References}

Beyond simply sorting the location references within an attribute
group there are other tasks that must be performed. The most important
one is that successive location references should under certain
circumstances be joined to form a \term{range}. For example, the
location references \emph{11}, \emph{12}, \emph{13}, \emph{14} should
be joined into the range \emph{11--14}.

\paragraph{Successor Relationship.} To be able to join successive
location references we need an exact definition of the successor
relationship among location references. We have already introduced a
total ordering on the location references using the sort key of a
location reference, but in general this is not enough to derive the
successor relationship. It may work for page numbers consisting of
arabic numbers or roman numerals, but in case of hierarchically
structured location classes it is not sufficient and may depend on the
actual document as we show now.

For example, we have page numbers of the form ([arabic]\{[alpha]\})
matching the location references \emph{11, 11a, 12}. The corresponding
sort keys are (11), (11\ts1) and (12). We can perhaps infer that (11)
could be written as (11\ts0) and then conclude that \emph{11a} is a
successor of \emph{11}, but we actually don't know if \emph{11a} and
\emph{12} are successors. As long as we do not know if there is
another location\footnote{Here we actually mean \emph{location} and
  not \emph{location reference}.} between \emph{11a} and \emph{12} we
cannot build the range \emph{11--12}, though it might be desirable in
the concrete case.

What actually causes the problem is a missing bijective mapping from
the sort key to the set of natural numbers, for which a well-defined
successor relationship exists. If this mapping would exist, we could
verify if \emph{11a} and \emph{12} are mapped onto two successive
natural numbers to decide if \emph{12} directly follows \emph{11a}.
There are two solutions to this problem: (a) the author of a document
explicitly declares \emph{12} to be a successor of \emph{11a}, tedious
but under certain circumstances acceptable, or (b) the \dps generates
this information automatically and adds it to the raw index as well.
We call this kind of missing information \term{document knowledge}
since it is contained in the document itself and must be made
available to the index processor for entirely solving the successor
problem.


\paragraph{The Principle of Superseding.} Till now we have concentrated
on building ranges among location references with the same attribute.
The next problem is how to solve this problem in an attribute group
consisting of a mixture of location references with different
attributes.  First of all we observe that the location references
\textbf{11} and \emph{11} might indicate two different types of
occurrences of a term on page eleven. But how should this appear in
the index? Sometimes it may be desirable that there exists a natural
precedence among the attributes of an attribute group. For example, we
want to drop the location reference pointing to an usage of a term on
a particular page in favour of its definition on the same page. This
saves space in the resulting index and emphasises the importance of a
definition of a term over its usage. But for other documents the
author may want to let both references coexist simultaneously.

Thus the attributes of an attribute group must define a superseding
relation indicating what location references with certain attributes
can be dropped in favour of the same location references with other
attributes.

\paragraph*{Virtual Location References.}

Sometimes a range cannot be built from a set of location references
with the same attribute, due to missing location references necessary
to complete a sequence. For example the location references \emph{11,
  12, 14, 15} cannot be joined to a range because \emph{13} is
missing. In case of an additional location reference \textbf{13}, one
could wish to build the range \emph{11--15} and show the \textbf{13}
separately resulting in the following sequence: \textbf{13},
\emph{11--15}.

This can be accomplished if the location references with the attribute
\emph{definition} would be seen as \emph{default} location references
in the phase of range building as well. We call these location
references \term{virtual location references}, because they do not
exist as real objects but are rather a way to simplify the process of
range building. A virtual object can be seen as the child of a real
object from which it is derived. Thus, virtual location references
appear if there is a relation among the attributes appearing in an
attribute group.\footnote{Actually it may be a relation among
  attributes appearing in different attribute groups as well.} In our
case there exists the virtual location reference [\emph{13}] behaving
as a normal \emph{default} location reference that helps to form the
range \emph{11--15}. If no range can be built, the virtual location
references disappear. Another option can be to eliminate the original
location reference (the one the virtual location reference is a child
of), if the virtual one helps building a range. There are two ways to
describe the relations among the attributes: (a) the so-called
\term{merge-to} relation $M$ between a source attribute and a target
attribute, and additionally (b) a \term{drop-if-merged} relation $D$,
for which $D\subseteq M$ must hold. Table~\ref{tab:virtuals} gives
examples of possible combinations for some specific relations.

{\vertspace=-2ex%%
  \begin{mtable}%
  {Range building in presence of virtual location references}
  {tab:virtuals}%
  \centering%

  \begin{tabular}{|c|r|c|c|l|c|}
    \hline
    \medrule\textsl{No.} &
    \multicolumn{4}{|c|}{\textsl{Ranges}} &
    \textsl{Location references}\\ \hline
    & \textsl{none} & \multicolumn{3}{|c|}{\textsl{allowed}} &\\ \cline{4-5}
    & & & \multicolumn{2}{|c|} {\term{merge-to}} &
    11 13 14 15 17 25\ \textbf{12 15 25}\\ \cline{5-5}
    & & & & \emph{drop-if-merged} &\\
    \hline\hline
    1 &$\circ$& & & & 11 13 14 17\ \textbf{12 15 25} \\
    2 & &$\circ$& & & 11 13--15 17\ \textbf{12 15 25} \\
    3 & &$\circ$&$\circ$& & 11--15 17\ \textbf{12 15 25} \\
    4 & &$\circ$&$\circ$&$\circ$& 11--15 17\ \textbf{25} \\
    \hline
    5 &$\circ$& & & & 11 \textbf{12} 13 14 \textbf{15} 17
    \textbf{25}\\
    6 & &$\circ$& & & 11 \textbf{12} 13--15 \textbf{15} 17
    \textbf{25}\\
    7 & &$\circ$ &$\circ$& & 11--15 \textbf{12 15} 17 \textbf{25}\\
    8 & &$\circ$ &$\circ$ &$\circ$& 11--15 17 \textbf{25} \\
    \hline%
  \end{tabular}%
\end{mtable}}

\noindent Examples~1--4 characterise the situation in which the attributes
\term{definition} and \emph{default} appear in two separate attribute
groups, whereas in the examples~5--8 both are in the same attribute
group and attribute \emph{definition} also supersedes attribute
\emph{default}. Without this restriction there exist even more
alternatives. As we can see the additional relations may help to
compress the list of location references under certain circumstances.


\paragraph*{Dropping Across Hierarchies.}

The principle of dropping location references in favour of a more
compact representation has to be generalised to variable location
classes. Location references could be dropped across hierarchies if
they are subsumed by location references of a higher level. For
example, one may wish to transform the location references \emph{1, 2,
  2.1, 2.2, 2.2.1, 2.3, 3} of class ([arabic].\{[arabic].[arabic]\})
into one of the following representations:
%%
\begin{list}{$\circ$}{%
      \settowidth{\labelwidth}{x}%%
      \setlength{\leftmargin}{\labelwidth}%%
      \advance\leftmargin\labelsep}
\item Building of ranges separately for some layers:

  \emph{1--3, 2.1--2.3, 2.2.1} \ \ or \ \ \emph{1--3, 2.1, 2.2, 2.2.1, 2.3} .

\item Joining at higher levels is done in favour of joining at lower levels:

  \emph{1--3, 2.1--2.3} \ \ or just \ \ \emph{1--3} .

\item Not everything is joined and the explicit enumeration of
  remaining location references is varied:

  \emph{1, 2, 2.1--2.3, 3}

  \emph{1, 2, 2.1--2.3, 2.2.1, 3}

  \emph{1, 2, 2.1, 2.2, 2.2.1, 2.3, 3} .
\end{list}
%%
We will not further investigate the exact semantics of these examples,
since the rules for the different variants especially in conjunction
with virtual location references are complicated. One possible
formalisation can be found in~\cite{xindy}.


\subsection{Cross References}

Cross references are references to redirect the readers interest to
other index entries. Often they are typeset as `\emph{see}\ldots' if
there are no location references in this index entry or `\emph{see
  also}\ldots' in case the reader should also look at another index
entry.

Cross references were accomplished in \mkidx using the encapsulators
presented previously. We have made cross references separate objects
in our indexing model. The user may define cross reference classes in
the index style. A cross reference can be attached an attribute in the
raw index specification format identifying the class of a cross
reference. This class attribute can be used to assign specific markup
to cross references and allows for a much more flexible markup and
grouping mechanism than other index processors.

As an additional feature we distinguish between \term{checked} and
\term{unchecked} cross reference classes. Members of the former group
are checked, if they point to an existing entry in the index, thus
avoiding the annoying presence of cross references pointing to
non-existent index entries.


\begin{comment}
\subsection{Summary}

An index consists of a two-dimensional structure represented as a
tree. Figure~\ref{fig:index-tree} illustrates the structure of the
components an index consists of. The vertical dimension, the index
entries and their associated keywords are quite well understood. The
model of the keyword mappings covers many needs.  Our main
contribution is a formalisation of the objects and processes that
participate in the horizontal dimension, namely alphabets, location
classes, attributes, attribute groups, the superseding relation, the
merge-to relation and the drop-if-merged relation. We have identified
the involved objects and have presented appropriate processing
schemes.

From an abstract point of view there are several topics the vertical
and horizontal dimensions share. Along both dimensions we have to
solve a \term{classification problem}. In terms of location references
we must decide the location class of a location reference, and for
keywords we must decide the equality of two keywords following a
\term{normalisation} step. In terms of keywords the keyword mappings
are a solution to this problem, whereas in the horizontal dimension
the different relations (superseding, merge-to and drop-if-merged) are
solutions to it.

Another correspondence occurs with the sorting problem, which in both
cases is solved using appropriate mappings. In the vertical dimension
we use a mapping from keywords, consisting of a list of words over the
document alphabet, to another list in which each element is generated
using a injective mapping, namely the merge and sort mappings. This
list is then sorted lexicographically. The same process appears at the
horizontal dimension, except that we use a list of ordinal numbers to
represent the sort key of a location reference. It is possible for the
user to define arbitrary alphabets along both dimensions.

Despite of these similarities we have shown that more complex
formalisations are necessary to describe the horizontal dimension than
are needed for the vertical dimension.

\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}
\label{sec:implementation}

Like \mkidx and \imkidx, \xindy is a \term{monolithic} system.
In~\cite{Bentley:EPODD-1-1-3} a \term{pipeline-based} system is
presented and the authors argue in favour of using \textsc{Unix} text
processing tools such as \texttt{awk} to write a tailored index
processor for each application. They emphasise the functional
decomposition of each member of the pipeline and compare it with
\mkidx. In fact, the indexes they processed with their tools are
simple compared to the model we presented. We believe that developing
an index processor with the capabilities of our indexing model will
not be possible by using pipelines. Additionally, we wanted to
implement a system that is usable by many people, not only by
experienced \textsc{Unix}-programmers.


\subsection{Why Common Lisp?}

We started using \cpp{} as the programming language of our choice. We
aimed at a prototype implementation to verify the new aspects of our
indexing model in practice. We have found \cpp{} to be an inadequate
language for productively building such prototypes and switched to
\CL~\cite{Steele:common-lisp-2}. All necessary data structures are
part of the core language ready for use. The powerful macro-mechanism
enabled us to implement a system without writing a dedicated parser.
The \Lisp-interpreter is well suited for this purpose. This has
encouraged us to write the production system in \Lisp as well.

We have chosen the freely available
\texttt{clisp}-implementation\footnote{Available at
  \texttt{ftp://ma2s2.mathematik.uni-karlsruhe.de/pub/lisp/clisp/}.},
and have extended it with the GNU \texttt{rx} regular expression
library\footnote{Available at
  \texttt{ftp://prep.ai.mit.edu/pub/gnu/}.} for the keyword mappings.

The system was written using the literate programming system
\texttt{noweb}~\cite{Ramsey:LPT93}. It consists of about 4\,500 lines
of \Lisp code and 600 lines of \textsf{C} code. A parser for the
transformation from the \TeX{}-specific raw index in the format used
by \xindy has been implemented using 150 lines of \texttt{lex} code.
The printed \texttt{noweb} code covers about 150 pages of text. As a
comparison, \mkidx is written in 4\,300 lines of \textsf{C}.


\subsection{Design Decisions}

\paragraph{The Raw Index.}

The raw index specification format understood by \xindy currently
consists of one polymorphic command that can be used to describe an
index entry consisting of the main key, an optional print key, the
location reference, its associated attribute, cross references and
other options. Each front-end to \xindy must produce the format of the
raw index interface. Due to the length of the specification we do not
describe it here. The details can be found in~\cite{xindy:man}.


\paragraph{The Index Style.}

As shown in figure~\ref{fig:data-flow} the index processor is
configured with the index style. The index style language consists of
about 35 different commands, most of them are used to specify the
markup of the final index. For a detailed description of all commands
we refer to~\cite{xindy:man}. Since a complete description of an index
style can be rather complex we have adopted a module concept that
enables the decomposition of a complete index style into submodules.
This allows the reuse of components simplifying the task of writing
style files. We have implemented a set of predefined styles that can
be used in an ad-hoc manner. Though compatibility with \mkidx was not
a design goal the distribution contains tools and modules, that make
\xindy mostly behave as a plug-in for \mkidx.

The superseding relation is implicitly implemented using the attribute
groups. We have implemented the superseding relation as the transitive
hull over the successor relation of the list defining an attribute
group. For example, the attribute group $(a_1, a_2, a_3)$ implicitly
defines the relation $\{ (a_1, a_2), (a_1, a_3), (a_2, a_3)\}$. This
is in our opinion an useful simplification of the model covering almost
all practical needs. Building ranges is only allowed on the last
hierarchy layer of a location reference. For variable location classes
it is not supported due to the lack of experience with useful
application domains. The merge-to and drop-if-merged relations are
implemented.


\subsection{Tagging the Index using Context Based Markup}
\label{sec:tagging}

%\afterpage{%%
%  {\vertspace=-2ex%%
%    \begin{mfigure}
%      {Tree structure of an index}
%      {fig:index-tree}
%      \begin{center}
%        \input{index.latex}
%      \end{center}
%    \end{mfigure}}
%  }

The tagging process directly operates on the tree representation as
illustrated in figure~\ref{fig:index-tree}. Boxed items are
components that are directly derived from the raw index. The other
nodes are created in the processing phase and serve to structure the
index.

\begin{sidewaysfigure}
  \begin{center}
    \input{index-tree.latex}
  \end{center}
  \caption{Skeleton tree structure of an index}
  \label{fig:index-tree}
\end{sidewaysfigure}

We have chosen to support an environment-based style of defining
markup.  This kind of markup is used in \dps{}s such as \TeX{}, SGML
(e.g.\ its instance HTML) and many others. The markup algorithm simply
traverses the index tree and when a node is entered or left a
\term{markup event} is generated. The user specifying the markup in
the index style needs to establish appropriate \term{event bindings}
that emit meaningful formatting info for the \dps.

Event bindings can be specialised relative to the context in which the
event was generated. This scheme is mostly inspired by the
\textsc{Stil}-project~\cite{stil}. At event generation time the
traversing algorithm is in a context that consists of the path in the
index tree it came across from the root to the current node.

\begin{comment}

  Starting from the root-node in figure~\ref{fig:index-tree}, such a
  path could look like
%%
\def\emrm#1{\mbox{\normalfont\emph{#1}}}%%
{\small\begin{alltt}
       \emrm{index}
         \emrm{letter group =} "G"
           \emrm{index entry =} "foo"
             \emrm{location class =} "page-numbers"
               \emrm{attribute group =} 1
                 \emrm{location reference attribute =} "definition"
\end{alltt}}
%%
\noindent All markup commands in index
style have the following form:
%%
\def\itarg#1{\mbox{\normalfont\emph{#1}}}
\def\rmarg#1{\mbox{\normalfont #1}}
{\small\begin{alltt}
   (markup-\itarg{index-tree-node-name}
       \rmarg{[}:open \itarg{markup}\rmarg{]} \rmarg{[}:close \itarg{markup}\rmarg{]} \rmarg{[}:sep \itarg{markup}\rmarg{]}\footnote{Option \texttt{:sep} is applicable for list nodes only.}
       \rmarg{[\emph{context-dependent options such as} \texttt{:attr}, \texttt{:group}, \texttt{:class}, \texttt{:depth}, \ldots]})

\end{alltt}}

\noindent Since, by default, all fields are optional one can assign
the markup to only a subset of the context arguments. The accessible
context arguments depend on the type of the object that is to be
output. For example, the markup of ranges can be specialised on their
length allowing different markup for ranges of different length. Thus,
one can specify markup of the form \emph{22\,f.} for ranges of
length~1, \emph{31\,ff.} for ranges of length~2, and \emph{11--15} for
all other ranges. We have not made the whole context available to the
user, but instead have selected a meaningful subset for each markup
command.

This \term{context-based markup specification} allows to assign a
generic markup, for instance, for all location reference classes with
the command
{\small%%
\begin{verbatim}
 (markup-locref :open "\generic{" :close "}")
\end{verbatim}%%
}%%
\noindent but redefining the markup for the instances of a certain
location class as follows:
{\small%%
\begin{verbatim}
 (markup-locref :open "\special{" :close "}" :class "special-class")
\end{verbatim}%%
}%%

\end{comment}

\noindent The event dispatcher must decide which of the markup schemes
is the most specialised one that matches the current context.
\begin{comment}
  In the above situation the second markup is selected for a location
  reference of class \texttt{special-class}, but for all others the
  generic markup is used, as defined by the first command.
\end{comment}
This kind of multi-argument dispatching is directly expressible in the
multi-method dispatching scheme of \CLOS~\cite{Keene:88}. Internally,
the system generates \CLOS-methods at run-time when reading the index
style that specialise on the given arguments. At markup time the
method dispatcher of \CLOS is used to find the appropriate method.

The user interface represented by the index style is therefore itself
of object-oriented nature. The user declares objects such as alphabets
and location classes, of which location references are instances.
Markup can be attached orthogonally to these objects using
multi-argument dispatching. For users not familiar with this kind of
operation we have added a feature that traces the whole markup phase
so that generated events are shown and the markup is reported that is
emitted in response to these events. For a detailed description of the
markup model see~\cite{CBM}.


\subsection{Open Problems}

A markup specific problem we encountered is that many flat indexes are
typeset in the following way: \emph{index, 1--10; $\widetilde{\ \
    }$processor, 5--9, 13; $\widetilde{\ \ }$style, 6, 8, 13}.  Thus
repetitions of keywords are indicated with an \term{abbreviation sign}
(the tilde character in our case).  Allowing markup schemes of this
kind can be implemented by making the information that a keyword is
repeated available in the markup context. But for indexes appearing in
textbooks this is only one part of the solution. Usually the
abbreviation signs are always suppressed at the beginning of a new
page in the document. This simplifies the readers search for a keyword
in the index. We argue that suppressing abbreviation signs is mainly a
problem that has to be solved by the \dps but further investigation of
the interaction of \dps{}s and index processors is necessary to solve
this problem.

As already noted we are currently exploring new sorting mechanisms
based on an object-oriented view on letters to simplify the
user-interface of our system for complex sorting schemes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

\begin{comment}
An index consists of a two-dimensional structure. The vertical
dimension, the index entries and their corresponding keywords is
rather well understood due to the results of the \imkidx
project~\cite{Schrod:CG-10-81}. The horizontal dimension describing
the structure of location references and the processes in which they
are involved is explored. This work gives a first terminology of
entities such as alphabets, location classes, attributes and attribute
groups and proposes a processing model that covers a wide range of
nowadays indexes. We have shown that there exist some similarities in
the processing of index entries and location references that can be
described as classification, normalisation, merging and sorting based
on words over underlying alphabets in both cases. The details of this
analysis can be found in~\cite{xindy}.
\end{comment}


An index consists of a two-dimensional structure represented as a
tree. Figure~\ref{fig:index-tree} illustrates the structure of the
components an index consists of. The vertical dimension, the index
entries and their associated keywords are quite well understood due to
the results of the \imkidx project~\cite{Schrod:CG-10-81}. The model
of the keyword mappings covers many needs. Our main contribution is a
formalisation of the objects and processes that participate in the
horizontal dimension, namely alphabets, location classes, attributes,
attribute groups, the superseding relation, the merge-to relation and
the drop-if-merged relation. We have identified the involved objects
and have presented appropriate processing schemes. The details of this
analysis can be found in~\cite{xindy}.

From an abstract point of view there are several topics the vertical
and horizontal dimensions share. Along both dimensions we have to
solve a \term{classification problem}. In terms of location references
we must decide the location class of a location reference, and for
keywords we must decide the equality of two keywords following a
\term{normalisation} step. In terms of keywords the keyword mappings
are a solution to this problem, whereas in the horizontal dimension
the different relations (superseding, merge-to and drop-if-merged) are
solutions to it.

Another correspondence occurs with the sorting problem, which in both
cases can be solved using appropriate mappings. In the vertical
dimension we use a mapping from keywords, consisting of a list of
words over the document alphabet, to another list in which each
element is generated using the merge and sort mappings. This list is
then sorted lexicographically. The same process appears at the
horizontal dimension, except that we use a list of ordinal numbers to
represent the sort key of a location reference. It is possible for the
user to define arbitrary alphabets along both dimensions.

\begin{comment}
  Despite of these similarities we have shown that more complex
  formalisations are necessary to describe the horizontal dimension
  than are needed for the vertical dimension.
\end{comment}

Based on this model we have implemented \xindy{}, a system that is
more flexible than former systems. It is tailorable to a wide range of
application domains, ranging from multi-language support to quite
complex document structures such as the bible or HTML-documents, which
can now be processed with our system. Its markup scheme based on a
highly declarative multi-argument dispatching strategy has proven to
be an adequate mechanism of describing context-based markup.

The implementation, a manual and a tutorial are available via WWW
under the URL
\texttt{http://www.iti.informatik.th-darmstadt.de/xindy}.  The author
is reachable via electronic mail under
\texttt{kehr@iti.informatik.th-darmstadt.de}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
\section{Acknowledgements}

I would like to thank Joachim Schrod and Klaus Guntermann for their
inspiring discussions, their valuable comments and precise corrections
and who made me feel comfortable in their working group. I'd also like
to thank Gabor Herr who was as excellent adviser in many
implementation questions especially concerning \Lisp. Without him this
project would not be in its current state. Finally, I'd like to thank
Prof.\ Waldschmidt who gave me the opportunity to continue this
project in his working group with financial support.
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\enlargethispage{\baselineskip}

\bibliographyIntroduction={The following books and papers were
  referenced in this report.}

\bibliography{bibliographie}
\bibliographystyle{abbrv}


\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% $Log$
% Revision 1.5  1997/05/05 15:22:08  kehr
% Some more corrections after the last proof reading of Prof. Waldschmidt.
%
% Revision 1.4  1997/04/24 15:44:52  kehr
% Modifications after Waldschmidts annotations.
%
% Revision 1.3  1997/02/19 18:41:49  kehr
% Check in after Klaus' corrections.
%
% Revision 1.2  1997/02/14 17:30:40  kehr
% New version.
%
% Revision 1.1  1997/02/14 09:10:34  kehr
% New checkin for xindy.
%
%
