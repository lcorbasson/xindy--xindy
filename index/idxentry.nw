%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Submodule: indexentry
%%
%%
\RCS $Id$
\RCS $Author$
\RCS $Revision$
\RCS $RCSfile$
\RCS $State$
\RCS $Date$
%

\ModuleTitle{}


\section{Submodule \module{indexentry}}


\subsection{Introduction}

This module is responsible for the management of an indexentry. It is
one of the main submodules of the whole system. An indexentry is an
object that holds the keywords of the indexentry (we currently
distinguish the \emph{main-key, merge-key, sort-key} and
\emph{print-key}), the corresponding list of location-references and
the reference to the indexclass the entry belongs to. We must be able
to process the location-references, and to markup the indexentry
during output-tagging.


\subsection{Abstract Specification}

\subsubsection{Definition}

An \term{indexentry} is a set
\begin{center}
  $\{$\emph{main-key, merge-key, sort-key, print-key, locrefs,
    indexclass}$\}$
\end{center}
with
\begin{deflistit}{indexclass}
\item [main-key] is a \tstrlist representing the main-key.
\item [merge-key] is a \tstrlist representing the merge-key.
\item [sort-key] is a \tstrlist representing the sort-key.
\item [print-key] is a \tstrlist representing the print-key.
\item [locrefs] is a list of \tlocref and contains all
  location-references that belong to this indexentry.
\item [indexclass] is a \type{indexclass}. It points to the whole
    indexclass description.
\end{deflistit}


\subsubsection{Operation}


\subsection{Concrete Specification}

\subsubsection{External interface}

The following symbols are exported:

\begin{defcls}{indexentry}{}
  Decribes indexentries.
\end{defcls}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{indexentry}}

Class \class{indexentry} is directly derived from the specification
above.

<<Class \class{indexentry}>>=
(defclass indexentry ()
    ((main-key  :reader get-main-key  :writer set-main-key  :initarg :main-key)
     (merge-key :reader get-merge-key                       :initarg :merge-key)
     (sort-key  :reader get-sort-key  :writer set-sort-key  :initarg :sort-key)
     (print-key :reader get-print-key :writer set-print-key :initarg :print-key)
     (locrefs   :reader get-locrefs   :writer set-locrefs   :initarg :locrefs)
     (idxclass  :reader get-idxclass                        :initarg :idxclass)))

(defun make-indexentry (&key (main-key '()) (merge-key '())
                             (sort-key '()) (print-key '())
                             (locrefs '())  (idxclass nil)
                             &allow-other-keys)
  (make-instance 'indexentry :main-key main-key :merge-key merge-key
                             :sort-key sort-key :print-key print-key
                             :locrefs  locrefs  :idxclass  idxclass))
@ %def indexentry make-indexentry

\no To add a location-reference to an indexentry we use the generic
function [[add]]. (For a detailed description see
\look{sec:precondition})

<<Class \class{indexentry}>>=
(defmethod add ((idxent indexentry) (locref location-reference))
  (unless (some #'(lambda (lref) (locref= locref lref))
                (get-locrefs idxent))
    (set-locrefs (cons locref (get-locrefs idxent)) idxent))
  idxent)
@ %def add

<<Export-list of submodule \module{idxentry}>>=
(export '(indexentry make-indexentry
          get-main-key get-merge-key get-sort-key get-print-key
          get-locrefs set-locrefs get-idxclass
          add))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\no The following function takes an indexentry and scans all possible
location-classes if the location-reference matches with them. If it
matches it creates a new indexentry with the corresponding
location-reference that was built with the matching-information. We
use the [[forall]]-construct to iterate over all location-classes and
call [[gen-indexentry-if-matched]] as the apply-function.

<<generate indexentries>>=
(defun gen-indexentries (&rest keyword-arguments
                         &key locref-str
                         &allow-other-keys)
  (forall-location-classes #'gen-indexentry-if-matched
                           locref-str keyword-arguments))
@ %def gen-indexentries

\no Remember that the applier-function of [[forall-location-classes]]
takes the three arguments indexclass, locationclass and given
parameter-list. As the parameter-list we have constructed a list whose
first element is the location-string and the rest is the given
keyword-list. They are needed for instatiaton of the
location-reference and the indexentry. Allowed keywords can be found
in the corresponding class definitions. Keywords that will explicitely
determined in this function (such as [[:layers]] and [[:ordnums]] for
the location-reference. [[:locrefs]] and [[:idxclasses]] for
indexentries) mustn't be set.

<<generate indexentries>>=
(defun gen-indexentry-if-matched (idxcls loccls keyword-arguments)
  (let ((locref-str        (car  keyword-arguments))
        (keyword-arguments (cadr keyword-arguments)))
    (multiple-value-bind (layers ordnums)
        (match-locclass-by-string locref-str loccls)
      (unless (or (endp layers) (endp ordnums))
        (let ((locref (apply #'make-structured-locref
                             :layers   layers :ordnums ordnums
                             :locclass (get-name loccls)
                             keyword-arguments)))
          (add-indexentry (apply #'make-indexentry
                                 :locrefs (list locref)
                                 keyword-arguments)
                          :idxcls-name (get-name idxcls)))))))
@ %def gen-indexentry

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Processing an indexentry ---  a semi-formal description}

Processing an indexentry is one of the central parts of the system.
Since a lot of different rules parametrize this process, the
underlying algorithm must consider several topics in parallel. We
start to describe a short theoretical overview, which shall remind us
what tasks to perform and what to consider generally.

During marking up, the list of location-references an indexentry owns
must be sorted, merged into ranges and finally be tagged. We're given
a list of location-references and have to perform the following tasks
in the order below.

\newcommand{\Real}{\textsf{normal}\xspace}
\newcommand{\Virt}{\textsf{virtual}\xspace}

Before starting with the process' description we introduce some
slot-functions (which are both readable and setable) according to the
slots that appear in the description of class
\class{location-refererence} extended by some new slots:
\begin{deflist}{XXXXXX}
  \item [\fcatattr{$l$}] returns the category-attribute of $l$.
  \item [\floccls{$l$}] returns the location-class $l$ belongs to.
  \item [\fordnum{$l$}] returns the list of ordnums of $l$.
  \item [\fstat{$l$}] returns the state of $l$ with
    $\fstat{l}\in\{\Real,\Virt\}$. This slot is initially set to
    \Real.
  \item [\fparent{$l$}] returns a reference to the location-reference
    $l$ was generated from. This value is initially set to \fnil.
\end{deflist}
Additionally we introduce an operator $[\ldots]$ which is used in
the form
\[k := l\,[s_1:=v_1,\ldots,s_n:=v_n]\]
with $k,l$ location-references and $s_i$~slot, $v_i$~new slot-value.
With this notation we describe that $k$ inherits all slot-values from
$l$ except those mentioned in the $[\ldots]$-list. This operator is
called \term{inheritance-operator}.\footnote{The idea is simply
  borrowed from similar notations which are used with variable
  substitutions in denotational semantics and unification.}

<<Processing an indexentry>>=
<<Separating into location-class-groups>>
<<Processing location-reference-groups>>
<<Separation into category-attribute-groups>>
@

\subsubsection{Precondition}
\label{sec:precondition}

\no We start with an initial set $R$ of location-references such that
\[\forall l,k\in R: l\not=k\Rightarrow\fcatattr{l}\not=\fcatattr{k}\vee
\fordnum{l}\not=\fordnum{k}\vee \floccls{l}\not=\floccls{k}.\] So we
can assume that there exist no \term{duplicates} in $R$.

\begin{note}
  Method [[add]]~\emph{idxent}~\emph{locref} already assures that this
  condition is always satisfied.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Separating into location-class-groups}

Divide $R$ into equivalence-classes of location-references based on
the location-classes. We receive a set of disjoint sets of
location-references $R:=\{L_1,\ldots,\L_n\}$, where in each subset
$L_i$ for each pair $l,k\in{}L_i$, $i=1\ldots{}n$ of
location-references holds \func{loccls}($l$)=\func{loccls}($k$).
Additionally holds $\forall x\in~L_j,\forall y\in~L_k,
j\not=k\Rightarrow\func{loccls}(j)\not=\func{loccls}(k)$.

\smallskip

\noindent The process itself is more or less a operation of refinement
on the underlying structure. For example, we subgroup the list of
location-references into location-class-groups. Later we need to
subgroup the location-class-groups into separated/mixed--groups, \etc.
This process continues until we reach ranges of location-references.

The idea is to define a generally usable function [[split-list]] that
may be used to subgroup and sort a list with a [[split-function]] and
a [[sort-function]]. Additionally we define a conversion-function
[[convert-sublists-to-group-object]] that can be used to turn the
generated sublists into \emph{group-objects}. A more flexible function
[[convert-sublists-to-specialized-groups]] is used to create instances
of different classes of group-objects. The idea of group-objects is to
easily bind action-methods with them to simplify overall work.

At first I started with working on highly nested lists in which every
sublist has a special meaning. Because I must concentrate on managing
those lists more than giving new features the idea of groups was born.
It is also easier to maintain for future extensions.

The resulting code is now:

<<Separating into location-class-groups>>=
<<Splitting lists into sublists --- [[split-list]]>>
<<Convert sublists into group objects --- [[convert-sublists-to-group-objects]]>>
<<Class \class{locref-group}>>
<<Class \class{locref-class-group}>>
<<Separating the location-references by using [[split-list]] and [[convert-sublists-to-group-objects]]>>
@


\paragraph{Splitting into sublists}

This is a function that operates on lists. It takes a list and groups
its elements into new subgroups. The given function [[split-function]]
must return the same value for all elements that belong to the same
group. These values are compared with the [[#'equal]]-predicate. Its
meaning is to create \emph{equivalence-classes} of elements. The
resulting sublists are sorted by function [[sort-function]] which must
define a \emph{less-than}-predicate of the values [[split-function]]
delivers. The result is a list containing the sorted sublists.

<<Splitting lists into sublists --- [[split-list]]>>=
(defun split-list (split-function sort-function list)
  (let ((split-table (make-hash-table :test #'equal))
        (sorted-keys '()))
    (mapcar #'(lambda (x)
                (let ((split-value (funcall split-function x)))
                  (setf (gethash split-value split-table)
                        (cons x (gethash split-value split-table)))))
            list)
    (maphash #'(lambda (key element)
                 (declare (ignore element))
                 (setq sorted-keys (cons key sorted-keys)))
             split-table)
    (mapcar #'(lambda (x) (gethash x split-table))
            (sort sorted-keys sort-function))))
@ %def split-list

\paragraph{Converting sublists into group-objects}

This conversion-routine iterates over a list containing sublists and
returns for every sublist an instance of class [[object-type]] and
stores the original sublist into the [[member]]-slot of the instance.
We need it, for instance, to generate the list separated/mixed-groups
in the location-reference-processing.

<<Convert sublists into group objects --- [[convert-sublists-to-group-objects]]>>=
(defun convert-sublists-to-group-objects (list-of-sublists object-type)
  (mapcar #'(lambda (sublist)
              (make-locref-group object-type sublist))
          list-of-sublists))
@ %def convert-sublists-to-group-objects

This slightly modified conversion-routine behaves like
[[convert-sublists-to-fixed-group]] but takes a function [[convert-func]]
instead of the object-type. This function takes as its argument the
sublist and must return an appropriate object-type. It is possible to
convert different sublists into different object-types.

<<convert-sublists-to-group>>=
(defun convert-sublists-to-specialized-groups (list-of-sublists convert-func)
  (declare (special convert-func))
  (mapcar #'(lambda (sublist)
              (make-locref-group (funcall convert-func sublist) sublist))
          list-of-sublists))
@ %def convert-sublists-to-specialized-groups


\paragraph{Location-reference groups}

Location-reference-groups are used to simplify processing the
location-references. We define the abstract base-class
[[locref-groups]] which can be used to define other subclasses and
bind methods to them. The \emph{elements} of a group are stored in
slot [[members]]. We define a generic function [[process-group]] that
specifies the work that needs to be done on every kind of group.

<<Class \class{locref-group}>>=
(defclass locref-group ()
    ((members :reader get-members :writer set-members :initarg :members)))

(defun make-locref-group (group-class members)
  (make-instance group-class :members members))

(defgeneric process-group (group-object indexclass))
@ %def locref-group make-locref-group process-group

\no This method is intended to operate on an indexentry. The work to
be done on the indexentries' location-references is to separate them
into groups of different location-classes. This is done by calling
[[split-list]] with a function that returns the order number of the
corresponding location-class a reference belongs to. Every created
subgroup is turned into an object of type [[locref-class-group]].
After creation of those objects we call [[process-group]] on them.


\paragraph{Class \class{locref-class-group}}

An object of type [[locref-class-group]] contains location-references
which belong the same location-class. The method
[[process-indexentry]] creates these objects for us.

<<Class \class{locref-class-group}>>=
(defclass locref-class-group (locref-group)
    ())
@ %def locref-class-group

<<Separating the location-references by using [[split-list]] and [[convert-sublists-to-group-objects]]>>=
(defmethod process-indexentry ((idxent indexentry))
  (set-locrefs (convert-sublists-to-group-objects
                (split-list #'(lambda (locref)
                                (get-ordnum (get-locclass locref)))
                            #'<
                            (get-locrefs idxent))
                'locref-class-group)
               idxent)
  )
@ %def process-indexentry

<<Export-list of submodule \module{idxentry}>>=
(export '(locref-group make-locref-group process-group process-indexentry))
@

\paragraph*{Further processing}

Process the following steps for each subset $L_i$ separately.

<<Processing location-reference-groups>>=
(defmethod process-group ((locref-cls-grp locref-class-group)
                          (idxcls indexclass))
  (apply-substitution-and-merge-rules locref-cls-grp idxcls)
  (build-ranges locref-cls-grp idxcls t)
  (cleanup locref-cls-grp)
  (separate-into-catattr-groups locref-cls-grp)
  locref-cls-grp)

<<Apply substitution- and merge-rules>>
<<Building of ranges>>
@ %def process-group


\paragraph*{Implementation cleanup}

To cleanup the funny-looking-list that is returned by [[build-range]]
we need to iterate over its elements.

<<Processing location-reference-groups>>=
(defmethod cleanup ((locref-cls-grp locref-class-group))
  (set-members
   (delete-if #'(lambda (object)
                  (and (typep object 'location-reference)
                       (state-virtual-p object)))
              (apply #'nconc
                     (apply #'nconc
                            (get-members locref-cls-grp))))
   locref-cls-grp))
@ %def cleanup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Sid}{\irule{substitute-if-double}\xspace}
\newcommand{\sid}{\irule{subs-if-dbl}\xspace}

\subsubsection{Apply all \Sid-rules}
\label{sec:subs-if-dbl}

This application operates on a set $L_i$ of location-references. All
\Sid-rules define a relation on the set $C$ of category-attributes
(ca). The relation is notated in the form `\Sid~$x$~$y$' or
abbreviated `\sid~$x$~$y$'.

There are two ways the user can specify these relations:
\begin{enumerate}
\item By explictly defining a set $C_U$ of rules of the form
  `\sid~$x$~$y$' with $x,y\in C$.
\item By defining virtual category-attributes (vca's). E.g.\@the
  definition of a vca $v:=(x~y~z)$ composed of the ca's $x,y,z$
  defines implicitely `\sid~$x$~$y$' and `\sid~$y$~$z$'. Tis set of
  rules is denoted $C_V$.
\end{enumerate}
%%
The question now arises if we should deduce that also implicitely
holds `\sid~$x$~$z$'? This means if we should calculate the
\term{transitive hull} on our relation. In a simple case like this the
user can add the remaining rule by her-/himself, but in more complex
cases we can calculate the transivie hull for him without the danger
of making any mistakes. We think that the user may expect a behaviour
that says `replace $z$ because we already have it in the form of $x$.'
and therefore define the transitive hull of the defined vca's. This is
a design decision but we will add a user-definable hook to change this
behaviour by not calculating the transitive hull. We denote the
transitive-hull operator with an appended star ($*$).  The resulting
relation $C_R$ can now be calculated in several ways:
\begin{enumerate}
\item $C_R:=C_U\cup C_V$$*$, defined as the default.
\item $C_R:=C_U$$*$$\cup C_V$. (seems very meaningless to me)
\item $C_R:=C_U$$*$$\cup C_V$$*$, if the user wants the transitive
  hull also be generated over his specification.
\item $C_R:=(C_U\cup C_V)*$, if the user wants a global transitive
  hull generation.
\end{enumerate}
%%
We conclude that we probably need three separate hooks for the
transitive-hull-calculation of $C_U,C_V$ and $C_U\cup C_V$. The users
are then free to do whatever (more or less) they want. The application
of these hooks is done in submodule \module{idxclass}. Additionally we
could include a check to see if some of the relations are
\term{refexive} what actually doesn't make any sense, since no
location-reference wants to substitute itself.

\medskip

After the definition of the substitution-relation we continue to
process the location-references. Until now we havent't defined what
\term{substitution} actually means. There are two ways.
\begin{enumerate}
\item To substitute means to \term{remove} in a way that the
  substituted location-reference will be removed.
\item It means to set the state of the substituted location-reference
  to \term{virtual} to allow it to be joined into a range.
\end{enumerate}
Both ways make sense so we need another hook to specify in what sense
to substitute.

\medskip

Informally we can describe this process as follows: $\forall l\in L_i$
test, if there exists $k\in L_i$ with $k\not=l\wedge\fstat{k}=\Real
\wedge\fordnum{k}=\fordnum{l}\wedge \exists
r=`\sid~\fcatattr{k}~\fcatattr{l}'\in C_R$ in which case we set
\fstat{$l$} to \Virt or remove $l$.

Actually we reset $l$'s state to \Virt means to move it from the set
of \emph{real} location-references into the set of \emph{virtual}
location-references. This happens only in the case that there really
exists a location-reference $k$ which is \Real.

The general idea for processing the location-references is to
separate them into sublists that contain location-references with the
same \term{ordnum}. For each of these sublists we call
[[apply-substitution-rules]]. This function returns a list of the
modified location-references without those being removed (if there
were some). Immediately we apply [[apply-merge-rules]] on this list
which will be described in the next section. This is the simplest way,
since the list ist in the exact form we need for optimal processing.

The resulting list is stored back into the [[member]]-slot
of the group.
\begin{note}
  Afterwards the list is in the form
  \begin{center}
    (\emph{ordnum-list}$_1$\ldots\emph{ordnum-list}$_n$) with
    \emph{ordnum}$_i$ =
    (\emph{locref}$_{i,1}$\ldots\emph{locref}$_{i,n}$).
  \end{center}
  This form is used in further steps.
\end{note}

<<Apply substitution- and merge-rules>>=
(defmethod apply-substitution-and-merge-rules ((locref-cls-grp locref-class-group)
                                               (idxcls         indexclass))
  (let ((locref-same-ordnum-grps
         (split-same-locrefs (get-members locref-cls-grp))))
    (set-members
     (mapcan #'(lambda (locref-same-ordnum-grp)
                 (apply-merge-rules
                  idxcls
                  (apply-substitution-rules idxcls
                                            locref-same-ordnum-grp)))
             locref-same-ordnum-grps)
     locref-cls-grp))
  locref-cls-grp)

<<Apply substitution-rules>>
<<Apply merge-rules>>
@ %def process-group apply-substitution-and-merge-rules

\no This function splits the location-references into sublists with
the same ordnums.

<<Apply substitution-rules>>=
(defmethod split-same-locrefs ((locrefs list))
  (split-list #'(lambda (locref) (get-ordnums locref))
              #'locref-ordnum<
              locrefs))
@ %def split-same-locrefs

\no The next function takes a list of location-references with the
same ordnum and applies the substitution-rules on them. It returns a
list of the remaining (if some have been removed) or modified (if
their state has been changed) location-references.

<<Apply substitution-rules>>=
(defmethod apply-substitution-rules ((idxcls indexclass)
                                     (locrefs list))
  (let ((substitute-locref (get-substitution-subst-hook idxcls)))
    (delete-if #'null
               (mapcar #'(lambda (test-locref)
                           (cond ((some #'(lambda (against-locref)
                                            (substitutable-p idxcls test-locref
                                                             against-locref))
                                        locrefs)
                                    (funcall substitute-locref test-locref))
                                 (t test-locref)))
                       locrefs))))
@ %def apply-substitution-rules-on-locref-list

\no To test if [[test-locref]] can be substituted by
[[against-locref]] we first test for equality in which case it is not
substitutable. Afterwards we check if the state of the
[[against-locref]] is normal and if they are in relation according to
the indexstyle. Otherwise no substitution may occur.

<<Apply substitution-rules>>=
(defmethod substitutable-p ((idxcls         indexclass)
                            (test-locref    structured-locref)
                            (against-locref structured-locref))
  (cond ((eql test-locref against-locref)
           nil)
        ((and (state-normal-p against-locref)
              (relation-p (get-implicit-subst-rules idxcls)
                          (get-catattr against-locref)
                          (get-catattr test-locref))))
        (t nil)))
@ %def substitutable-p

<<Export-list of submodule \module{idxentry}>>=
(export '(process-group split-same-locrefs
          apply-substitution-rules substitutable-p))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Apply all \irule{merge-to}- and \irule{drop-if-merged}-rules}

The formal description says: Initialize the set of new
location-references $L_i^+:=\{\}$. For all $l\in{}L_i$ (virtual or
not) if exists a rule `$\irule{merge-to}~\fcatattr{l}~x$' then
$L_i^+:=L_i^+\cup{}l_+$ with
\[l_+:=l\,[\Fstat{}:=\Virt,\Fcatattr{}:=x].\]
or if additionally holds `\irule{drop-if-merged}~\fcatattr{l}~x'
\[l_+:=l\,[\Fstat{}:=\Virt,\Fcatattr{}:=x,\Fparent:=\fparent{l}].\]
After applying the last steps we first need to union $L_i$ and $L^+_i$
to receive the extended set $L_i:=L_i\cup L_i^+$.

\noindent The basic idea is to generate new location-references that
are equal to their parents but with \Fstat{} set to \Virt and if there
exists an applicable \irule{drop-if-merged}-rule additionally
\Fparent{} holds a reference to the parent location-reference, since
we must be able to actually \emph{drop} the parent, if necessary.

The implementation performs the creation of new location-references as
needed but does not check for duplicates. Duplicates can occur when we
don't use the \irule{drop-if-merged}-rule and equal
location-references are generated from different category-attributes.
Additionally there can exist \term{virtual} location-references for
which also exists their \term{normal} counterpart. We do not worry
about too much location-references. In the ramaining steps this will
not cause any problems (hopefully).

<<Apply merge-rules>>=
(defmethod apply-merge-rules ((idxcls indexclass) (locrefs list))
  (let ((merge-rules          (get-merge-rules idxcls))
        (drop-if-merged-rules (get-drop-if-merged-rules idxcls)))
    (nconc locrefs
           (mapcan #'(lambda (locref)
                       (mapcan #'(lambda (catattr)
                                   (let ((new-locref
                                          (make-virtual-structured-locref
                                           :catattr  catattr
                                           :ordnums  (get-ordnums locref)
                                           :layers   (get-layers locref)
                                           :locclass (get-locclass locref))))
                                     (when (relation-p drop-if-merged-rules
                                                       (get-catattr locref)
                                                       catattr)
                                       (set-origin locref new-locref))
                                     (list new-locref)))
                               (relation-set merge-rules (get-catattr locref))))
                   locrefs))))
@ %def apply-merge-rules

<<Export-list of submodule \module{idxentry}>>=
(export '(apply-merge-rules))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Building of ranges}

Building of ranges the next job to be done. In general we have to
solve two problems:
\begin{itemize}
\item The application of the \irule{drop-if-merged}-rule is somewhat
  problematic. The notion of \term{dropping} a location-reference
  needs an exact definition. We can say, that dropping simply means to
  reset the state of a location-reference to virtual. This works well
  and doesn't cause any trouble. But when it is intended to actually
  \term{remove} a dropped location-reference the order in which the
  category-attribute-groups are processed is significant. Since we
  must delay the building of ranges inside a category-attribute until
  we know which location-references aren't removed we need to know the
  \term{order} in which the category-attributes must be processed.
  This can easily determined by sorting the
  \irule{drop-if-merged}-relation topologically and start with a
  category-attribute $c$ such there doesn't exist a rule
  `\irule{drop-if-merged}~$c~x$' which means that this catattr can't
  be dropped. The problem is to ensure that there exists a topological
  sort on the category-attributes. Otherwise it is possible that a
  circular droping may occur which is an error. In this case the user
  must be advised to correct his erroneus specification. Function
  [[make-ready]] in submodule \module{idxclass} calculates for a given
  category-attribute its position in the topological sorting of all
  \irule{drop-if-merged}-rules and stores the resulting value into the
  [[processing-ordnum]]-slot of the catattr. For all
  category-attributes that are not involved in these rules we can put
  them in any order (this is done by setting the initial value to 0).

  We start by splitting the location-references into
  category-attribute-subgroups (ordered by their processing-number)
  and process each of those subgroups.

\item The second problem deals with the range-building of
  \term{var-classes}. Currently we don't support bulding of ranges for
  var-classes because we want to make some experience with the
  standard-classes first.
\end{itemize}

\subsubsection*{Separation into sublists with the same category-attribute}

We now come closer to the building of ranges and we need a different
view on the location-references. In the last sections we processed
location-references with equal ordnums in general. Now we must focus
on location-references that have to the same category-attribute.

<<Building of ranges>>=
(defmethod build-ranges ((locref-cls-grp locref-class-group)
                         (idxcls indexclass)
                         x)
  (declare (ignore x))
  (let ((locref-same-catattr-grps
         (split-list #'(lambda (locref) (get-catattr locref))
                     #'(lambda (x y)
                         (< (get-processing-ordnum x)
                            (get-processing-ordnum y)))
                     (get-members locref-cls-grp))))
    (set-members (mapcar #'(lambda (catattr-sublist)
                             (build-ranges catattr-sublist
                                           idxcls
                                           (get-locclass (car catattr-sublist))))
                         locref-same-catattr-grps)
                 locref-cls-grp)
    ))
@ %def build-ranges

\no The implementation of [[build-ranges]] is continued in submodule
\module{ranges}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Separation into category-attribute-groups}

At the end we must separate the location-references and ranges into
the category-attribute-groups. Now we must focus on
location-references that belong to the same category-attribute-group.
We introduce a new class for easy dispatching during the
markup-processing.

The category-attribute-groups (cag's) are described by a injective
function $\phi$ from the set $C$ of category-attributes to the set $G$
of cag's. Since $\phi$ is given we do $\forall l\in L_i:
\fcag{l}:=\phi(\fcatattr{l})$. Divide $L_i$ into equivalence-classes
$K_1,\ldots,K_m$ that for each pair $l,k\in{}K_j$ holds:
$\fcag{l}=\fcag{k}$. Additionally holds $\forall x\in K_j,\forall
y\in K_k,j\not=k\Rightarrow\fcag{j}\not=\fcag{k}$.

\smallskip\noindent%%
A category-attribute contains an additional slot [[ordnum]] that keeps its
ordnum. Currently this slot is initialized but unused.

Method [[separate-into-catattr-groups]] takes a location-class-group
whose [[members]]-slot contains a list of location-references and
location-ranges. It splits this list into the catattr-groups by
calling [[get-catattr-grp-ordnum]] with the catattr of all objects. Method
[[get-catattr]] is defined for location-references and location-ranges
so we don't need to distinguish between them explicitly.

Finally we fill the [[ordnum]]-slot of all catattr-groups (maybe we
don't need it at all).

<<Separation into category-attribute-groups>>=
(defclass category-attribute-group (locref-group)
    ((ordnum :reader get-ordnum :writer set-ordnum :initform 'nil)))

(defmethod separate-into-catattr-groups ((locref-cls-grp locref-class-group))
  (set-members (convert-sublists-to-group-objects
                (split-list #'(lambda (object)
                                (get-catattr-grp-ordnum (get-catattr object)))
                            #'<
                            (get-members locref-cls-grp))
                'category-attribute-group)
               locref-cls-grp)
  (mapc #'(lambda (catattr-grp)
            (set-ordnum (get-catattr-grp-ordnum (get-catattr (car (get-members catattr-grp))))
                        catattr-grp)
            (set-members
             (sort (get-members catattr-grp)
                   #'(lambda (object-1 object-2)
                       (let ((ordnum-1 (get-ordnums object-1))
                             (ordnum-2 (get-ordnums object-2)))
                         (or (locref-ordnum< ordnum-1 ordnum-2)
                             (and (locref-ordnum= ordnum-1 ordnum-2)
                                  (< (get-sort-ordnum (get-catattr object-1))
                                     (get-sort-ordnum (get-catattr object-2))))))))
             catattr-grp))
        (get-members locref-cls-grp))
  locref-cls-grp)
@ %def category-attribute-group separate-into-catattr-groups

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{idxentry}>>=
;; $Id$

<<Class \class{indexentry}>>
<<Processing an indexentry>>

<<Export-list of submodule \module{idxentry}>>
@

<<RCS-Identifier>>=
("idxentry" . "$Id$")
@ %def RCS-Identifier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
(set-pprint-dispatch 'indexentry
                     #'(lambda (s idxent)
                         (pprint-logical-block
                          (s nil :suffix "}")
                          (pprint-indent :block 2 s)
                          (write-string "Indexentry {" s)
                          (pprint-newline :mandatory s)
                          (write-string "main-key: " s)
                          (write (get-main-key idxent) :stream s)
                          (pprint-newline :mandatory s)
                          (pprint-logical-block
                           (s nil :suffix "}")
                           (write-string "Locrefs {" s)
                           (pprint-indent :block 2)
                           (pprint-newline :mandatory s)
                           (pprint-linear s (get-locrefs idxent)))
                          (pprint-newline :mandatory s))
                         ))
@

\no Here we define a function that is used to specify the pretty-print
of locref-groups. Function [[pprint-locref-group]] prints [[grp]] on
stream [[s]]. It uses [[name]] to add the name of the group into the
pretty-print-stream. Function [[set-pprint-locref-group-dispatch]] is
needed to add the class-types into the dispatch-table for the
pretty-printer.

<<Pretty-printing>>=
(defun pprint-locref-group (s grp name)
  (pprint-logical-block
   (s nil :prefix "(" :suffix ")")
   (write-string name s)
   (write-string ":" s)
   (when (typep grp 'category-attribute-group)
     (write (get-ordnum grp) :stream s))
   (pprint-indent :block 2 s)
   (pprint-newline :mandatory s)
   (pprint-fill s (get-members grp) nil)
   (pprint-indent :block -1 s)
   (pprint-newline :mandatory s)))

(defun set-pprint-locref-group-dispatch (class name &optional (rank 0))
  (set-pprint-dispatch class
                       #'(lambda (s grp)
                           (pprint-locref-group s grp name))
                       rank))
@ %def pprint-locref-group set-pprint-locref-group-dispatch

\no When adding types is is absolutely necessary to add a rank into
the dispatch-table, that describes the inheritance-relations between
the classes. For example, class [[locref-group]] is base-class of all
other locref-groups. Therefore the other classes need a higher rank to
explicitely define a precedence during the pretty-printer-dispatching
(This took me quite a while to work it out\ldots uff!). As can be seen
the given ranks (third argument of
[[set-pprint-locref-group-dispatch]]) describe exactly the topological
sort of the class-relationships.

This section is placed here before the definition of all classes.

<<Pretty-printing>>=
(set-pprint-locref-group-dispatch 'locref-group
                                  "LOCREF-GROUP"               0)
(set-pprint-locref-group-dispatch 'locref-class-group
                                  "LOCREF-CLASS-GROUP"         1)
(set-pprint-locref-group-dispatch 'category-attribute-group
                                  "CATEGORY-ATTRIBUTE-GROUP"   2)
@


%% $Log$
%% Revision 1.8  1996/01/31 16:13:27  kehr
%% Still working on th user-interface...
%%
%% Revision 1.7  1996/01/09  14:27:24  kehr
%% Moved submodule `ranges' from module `locref' to this module.
%% Nearly complete rewrite of all submodules. See ChangeLog for further details.
%%
%% Revision 1.6  1995/12/19  10:59:44  kehr
%% Changes Imakefile.
%%
%% Revision 1.5  1995/12/15  17:09:07  kehr
%% Wrote down more specification for the locref-handling.
%%
%% Revision 1.4  1995/12/13  16:44:16  kehr
%% Extended the specification of the location-reference-handling. Implemented
%% the transitive-hull algorithm.
%%
%% Revision 1.3  1995/12/13  14:07:25  kehr
%% Just a check-in to preserve the transitive-hull-function.
%%
%% Revision 1.2  1995/12/11  17:37:01  kehr
%% Added semi-formal description of the location-refernce handling.
%%
%% Revision 1.1  1995/12/05  18:46:29  kehr
%% Added module `index' and restructured some parts.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Revision 1.13  1995/07/28  10:41:17  kehr
%% Added simple markup for location-references and ranges. Currently
%% exists no support for differen layer-markup. A location-reference is
%% always printed as a whole.
%%
%% Revision 1.12  1995/07/27  23:59:02  kehr
%% Added support for keword-markup.
%%
%% Revision 1.11  1995/07/27  14:36:43  kehr
%% Added support for joining of locref-separated-groups.
%%
%% Revision 1.10  1995/07/26  16:19:53  kehr
%% Added support for the pretty-printer module. Output of data-structures
%% now looks more readable.
%%
%% Revision 1.9  1995/07/25  11:03:18  kehr
%% Added separation of location-references into seprated/mixed-groups.
%% Modified debug-output of locref-groups to reflect the real class-type
%% of the groups. Verified the process of generating these groups.
%%
%% Revision 1.8  1995/07/24  16:33:44  kehr
%% Added subgrouping of location-references with the same ordnum. Now
%% I'll start to join ranges.
%%
%% Revision 1.7  1995/07/23  20:48:33  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.6  1995/07/23  14:14:09  kehr
%% Added support for merge-to--rule. Now works and creates
%% virtual-attributes as expected.
%%
%% Revision 1.5  1995/07/15  20:50:22  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.4  1995/07/11  23:33:07  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.3  1995/07/11  15:14:16  kehr
%% Today I finished the definition of indexentries. They now will be
%% inserted into the index when a appropriate location-class was finished.
%%
%% Revision 1.2  1995/07/11  00:47:44  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%
%% Revision 1.1  1995/07/09  18:14:27  kehr
%% Initial checkin.
%%


%% Local Variables:
%% mode: latex
%% TeX-master: t
%% End:
