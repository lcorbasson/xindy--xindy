%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Submodule: indexentry
%%
%%
\RCS $Id$
\RCS $Author$
\RCS $Revision$
\RCS $RCSfile$
\RCS $State$
\RCS $Date$
%

\ModuleTitle{}


\section{Submodule \module{indexentry}}


\subsection{Introduction}

This module is responsible for the management of an indexentry. It is
one of the main submodules of the whole system. An indexentry is an
object that holds the keywords of the indexentry (we currently
distinguish the \emph{main-key, merge-key, sort-key} and
\emph{print-key}), the corresponding list of location-references and
the reference to the indexclass the entry belongs to. We must be able
to process the location-references, and to markup the indexentry
during output-tagging.


\subsection{Abstract Specification}

\subsubsection{Definition}

An \term{indexentry} is a set
\begin{center}
  $\{$\emph{main-key, merge-key, sort-key, print-key, locrefs,
    indexclass}$\}$
\end{center}
with
\begin{deflistit}{indexclass}
\item [main-key] is a \tstrlist representing the main-key.
\item [merge-key] is a \tstrlist representing the merge-key.
\item [sort-key] is a \tstrlist representing the sort-key.
\item [print-key] is a \tstrlist representing the print-key.
\item [locrefs] is a list of \tlocref and contains all
  location-references that belong to this indexentry.
\item [indexclass] is a \type{indexclass}. It points to the whole
    indexclass description.
\end{deflistit}


\subsubsection{Operation}


\subsection{Concrete Specification}

\subsubsection{External interface}

The following symbols are exported:

\begin{defcls}{index-entry}{}
  Decribes indexentries.
\end{defcls}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Class \class{index-entry}}
\label{sec:cls-indexentry}

Class \class{index-entry} is directly derived from the specification
above.

<<Class \class{index-entry}>>=
(defclass index-entry ()
    ((main-key   :initarg :main-key)
     (merge-key  :initarg :merge-key)
     (sort-key   :initarg :sort-key)
     (print-key  :initarg :print-key)
     (locrefs    :reader get-locrefs    :writer set-locrefs :initarg :locrefs)
     (idxclass   :reader get-idxclass                      :initarg :idxclass)
     (subentries :reader get-subentries :writer set-subentries :initform '())))

(defun make-index-entry (&key (main-key '()) (merge-key '())
                             (sort-key '()) (print-key '())
                             (locrefs '())  (idxclass nil)
                             &allow-other-keys)
  (make-instance 'index-entry :main-key main-key :merge-key merge-key
                             :sort-key sort-key :print-key print-key
                             :locrefs  locrefs  :idxclass  idxclass))
@ %def index-entry make-index-entry

\no To keep track of the currently processed indexentry we store this
value in the following global parameter.

<<Class \class{index-entry}>>=
(defvar *currently-processed-indexentry*)
@ %def *currently-processed-indexentry*

\no To add a location-reference to an indexentry we use the generic
function [[add]]. (For a detailed description see
\look{sec:precondition})

<<Class \class{index-entry}>>=
(defmacro add-location-reference-to-indexentry (idxent locref)
  `(PROGN
    (UNLESS (SOME #'(LAMBDA (LREF)
                      (LOCREF= ,locref LREF))
                  (GET-LOCREFS ,idxent))
      (SET-LOCREFS (CONS ,locref (GET-LOCREFS ,idxent))
                   ,idxent))
    ,idxent))
@ %def add-location-reference-to-indexentry

<<Class \class{index-entry}>>=
(defmacro get-main-key (locref)
  `(SLOT-VALUE ,locref 'MAIN-KEY))
(defmacro get-merge-key (locref)
  `(SLOT-VALUE ,locref 'MERGE-KEY))
(defmacro get-sort-key (locref)
  `(SLOT-VALUE ,locref 'SORT-KEY))
(defmacro get-print-key (locref)
  `(SLOT-VALUE ,locref 'PRINT-KEY))
@ %def get-merge-key get-main-key get-sort-key get-print-key

<<Class \class{index-entry}>>=
(defmacro set-main-key (key locref)
  `(SETF (SLOT-VALUE ,locref 'MAIN-KEY) ,key))
(defmacro set-merge-key (key locref)
  `(SETF (SLOT-VALUE ,locref 'MERGE-KEY) ,key))
(defmacro set-sort-key (key locref)
  `(SETF (SLOT-VALUE ,locref 'SORT-KEY) ,key))
(defmacro set-print-key (key locref)
  `(SETF (SLOT-VALUE ,locref 'PRINT-KEY) ,key))
@ %def set-merge-key set-main-key set-sort-key set-print-key

<<Export-list of submodule \module{idxentry}>>=
(export '(index-entry make-index-entry
          get-main-key get-merge-key get-sort-key get-print-key
          set-main-key set-merge-key set-sort-key set-print-key
          get-locrefs set-locrefs get-idxclass
          get-subentries set-subentries
          add-location-reference-to-indexentry
          main-key merge-key sort-key print-key))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Processing an indexentry ---  a semi-formal description}

Processing an indexentry is one of the central parts of the system.
Since a lot of different rules parametrize this process, the
underlying algorithm must consider several topics in parallel. We
start to describe a short theoretical overview, which shall remind us
what tasks to perform and what to consider generally.

During markup, the location-references an indexentry owns must be
sorted, merged into ranges and finally be tagged. We're given a list
of location-references and have to perform the following tasks in the
order below.

\newcommand{\Real}{\textsf{normal}\xspace}
\newcommand{\Virt}{\textsf{virtual}\xspace}

Before starting with the process' description we introduce some
slot-functions (which are both readable and setable) according to the
slots that appear in the description of class
\class{location-refererence} extended by some new slots:
\begin{deflist}{XXXXXX}
  \item [\fcatattr{$l$}] returns the category-attribute of $l$.
  \item [\floccls{$l$}] returns the location-class $l$ belongs to.
  \item [\fordnum{$l$}] returns the list of ordnums of $l$.
  \item [\fstat{$l$}] returns the state of $l$ with
    $\fstat{l}\in\{\Real,\Virt\}$. This slot is initially set to
    \Real.
  \item [\fparent{$l$}] returns a reference to the location-reference
    $l$ was generated from. This value is initially set to \fnil.
\end{deflist}
Additionally we introduce an operator $[\ldots]$ which is used in
the form
\[k := l\,[s_1:=v_1,\ldots,s_n:=v_n]\]
with $k,l$ location-references and $s_i$~slot, $v_i$~new slot-value.
With this notation we describe that $k$ inherits all slot-values from
$l$ except those mentioned in the $[\ldots]$-list. This operator is
called \term{inheritance-operator}.\footnote{The idea is simply
  borrowed from similar notations which are used with variable
  substitutions in denotational semantics and unification.}

<<Processing an indexentry>>=
<<Separating into location-class-groups>>
<<Processing location-reference-groups>>
<<Separation into category-attribute-groups>>
@

\subsubsection{Precondition}
\label{sec:precondition}

\no We start with an initial set $R$ of location-references such that
\[\forall l,k\in R: l\not=k\Rightarrow\fcatattr{l}\not=\fcatattr{k}\vee
\fordnum{l}\not=\fordnum{k}\vee \floccls{l}\not=\floccls{k}.\] So we
can assume that there exist no \term{duplicates} in $R$.

\begin{note}
  Method [[add]]~\emph{idxent}~\emph{locref} already assures that this
  condition is always satisfied.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Separating into location-class-groups}

Divide $R$ into equivalence-classes of location-references based on
the location-classes. We receive a set of disjoint sets of
location-references $R:=\{L_1,\ldots,\L_n\}$, where in each subset
$L_i$ for each pair $l,k\in{}L_i$, $i=1\ldots{}n$ of
location-references holds \func{loccls}($l$)=\func{loccls}($k$).
Additionally holds $\forall x\in~L_j,\forall y\in~L_k,
j\not=k\Rightarrow\func{loccls}(j)\not=\func{loccls}(k)$.

\smallskip

\noindent The process itself is more or less a operation of refinement
on the underlying structure. For example, we subgroup the list of
location-references into location-class-groups. Later we need to
subgroup the location-class-groups into separated/mixed--groups, \etc.
This process continues until we reach ranges of location-references.

The idea is to define a generally usable function [[split-list]] that
may be used to subgroup and sort a list with a [[split-function]] and
a [[sort-function]]. Additionally we define a conversion-function
[[convert-sublists-to-group-object]] that can be used to turn the
generated sublists into \emph{group-objects}. A more flexible function
[[convert-sublists-to-specialized-groups]] is used to create instances
of different classes of group-objects. The idea of group-objects is to
easily bind action-methods with them to simplify overall work.

At first I started with working on highly nested lists in which every
sublist has a special meaning. Because I must concentrate on managing
those lists more than giving new features the idea of groups was born.
It is also easier to maintain for future extensions.

The resulting code is now:

<<Separating into location-class-groups>>=
<<Splitting lists into sublists --- [[split-list]]>>
<<Convert sublists into group objects --- [[convert-sublists-to-group-objects]]>>
<<Convert sublists into group objects --- [[convert-sublists-to-specialized-groups]]>>
<<Class \class{locref-group}>>
<<Class \class{locref-class-group}>>
<<Class \class{crossref-class-group}>>
<<Separating the location-references by using [[split-list]] and [[convert-sublists-to-group-objects]]>>
<<Treeing location-references>>
@


\paragraph{Converting sublists into group-objects}

This conversion-routine iterates over a list containing sublists and
returns for every sublist an instance of class [[object-type]] and
stores the original sublist into the [[member]]-slot of the instance.
We need it, for instance, to generate the list separated/mixed-groups
in the location-reference-processing.

<<Convert sublists into group objects --- [[convert-sublists-to-group-objects]]>>=
(defun convert-sublists-to-group-objects (list-of-sublists
                                          object-type
                                          &key (initializer-func nil))
  (mapcar #'(lambda (sublist)
              (let ((locref-grp (make-locref-group object-type sublist)))
                (if initializer-func
                    (funcall initializer-func locref-grp)
                    locref-grp)))
          list-of-sublists))
@ %def convert-sublists-to-group-objects

This slightly modified conversion-routine behaves like
[[convert-sublists-to-fixed-group]] but takes a function [[convert-func]]
instead of the object-type. This function takes as its argument the
sublist and must return an appropriate object-type. It is possible to
convert different sublists into different object-types.

<<Convert sublists into group objects --- [[convert-sublists-to-specialized-groups]]>>=
(defun convert-sublists-to-specialized-groups (list-of-sublists
                                               convert-func
                                               &optional
                                               initializer-func)
  (mapcar #'(lambda (sublist)
              (let ((locref-grp
                     (make-locref-group (funcall convert-func sublist)
                                        sublist)))
                (if initializer-func
                    (funcall initializer-func locref-grp)
                    locref-grp)))
          list-of-sublists))
@ %def convert-sublists-to-specialized-groups


\paragraph{Location-reference groups}

Location-reference-groups are used to simplify processing the
location-references. We define the abstract base-class
[[locref-groups]] which can be used to define other subclasses and
bind methods to them. The \emph{elements} of a group are stored in
slot [[members]]. We define a generic function [[process-group]] that
specifies the work that needs to be done on every kind of group.

<<Class \class{locref-group}>>=
(defclass locref-group ()
    ((members :reader get-members :writer set-members :initarg :members)))

(defun make-locref-group (group-class members)
  (make-instance group-class :members members))

(defgeneric process-group (group-object indexclass))
@ %def locref-group make-locref-group process-group

\no This method is intended to operate on an indexentry. The work to
be done on the indexentries' location-references is to separate them
into groups of different location-classes. This is done by calling
[[split-list]] with a function that returns the order number of the
corresponding location-class a reference belongs to. Every created
subgroup is turned into an object of type [[locref-class-group]].
After creation of those objects we call [[process-group]] on them.


\paragraph{Class \class{locref-class-group}}

An object of type [[locref-class-group]] contains location-references
which belong the same location-class. The method
[[process-indexentry]] creates these kind of objects for us. Since all
location-references belonging to the same location-class are put into
on object of this type, we separate them from each other. The
initializer-function, sets the slot [[locclass]] to the location-class
all the location-references belong to. We need this only for an easy
dispatching during the markup process.

<<Class \class{locref-class-group}>>=
(defclass locref-class-group (locref-group)
    ((locclass  :writer set-locclass :initform 'nil)))
@ %def locref-class-group

<<Class \class{crossref-class-group}>>=
(defclass crossref-class-group (locref-group)
    ((locclass  :writer set-locclass :initform 'nil)))
@ %def crossref-class-group


<<Separating the location-references by using [[split-list]] and [[convert-sublists-to-group-objects]]>>=
(defun process-indexentry (idxent)
  (setq *currently-processed-indexentry* idxent)
  (when (>= (incf *current-number*) (caar *processing-percentage-list*))
    (info " [~A%]" (cdar *processing-percentage-list*))
    (pop *processing-percentage-list*))
  (set-locrefs (convert-sublists-to-specialized-groups
                (split-list #'(lambda (locref)
                                (get-ordnum (get-locclass locref)))
                            (get-locrefs idxent)
                            :sortfunc #'<)
                #'(lambda (sublist)
                    (typecase (car sublist)
                      (layered-location-reference  'locref-class-group)
                      (crossref-location-reference 'crossref-class-group)
                      (t (error "internal error in `process-indexentry'"))))
                #'(lambda (locref-cls-grp)
                    (set-locclass (get-locclass
                                   (car (get-members locref-cls-grp)))
                                  locref-cls-grp)
                    locref-cls-grp))
               idxent)
  (mapc #'(lambda (locref-cls-grp)
            (process-group locref-cls-grp *indexstyle*))
        (get-locrefs idxent))
  idxent)
@ %def process-indexentry

<<Export-list of submodule \module{idxentry}>>=
(export '(locref-group get-members
          locref-class-group crossref-class-group get-locclass
          make-locref-group process-group process-indexentry))
@

\paragraph*{Further processing}

Process the following steps for each subset $L_i$ separately.

<<Processing location-reference-groups>>=
(defmethod process-group ((locref-cls-grp locref-class-group)
                          (idxcls indexclass))
  (apply-substitution-and-merge-rules locref-cls-grp idxcls)
  (build-ranges-in-locref-class-group locref-cls-grp idxcls)
  (remove-virtual-locrefs locref-cls-grp)
  (separate-into-catattr-groups locref-cls-grp)
  locref-cls-grp)

<<Apply substitution- and merge-rules>>
<<Building of ranges>>
@ %def process-group

\no What has to be done with the cross-reference-groups? First of all
we have to check the verified cross-references.

<<Processing location-reference-groups>>=
(defmethod process-group ((crossref-cls-grp crossref-class-group)
                          (idxcls indexclass))
  (let ((cross-references (get-members crossref-cls-grp)))
    (typecase (get-locclass (car cross-references))
      (verified-crossref-location-class
         (mapc #'(lambda (xref)
                   (let* ((target (get-target xref))
                          (merge-key-target (gen-keyword-mergekey-list target)))
                     (unless (lookup-indexentry merge-key-target)
                       (oops "Cross-reference-target ~S does not exist!"
                             target))))
               cross-references))
      (unverified-crossref-location-class)
      (t (error "INTERNAL ERROR in process-group"))))
  crossref-cls-grp)
@ %def process-group


\paragraph*{Implementation cleanup}

This function removes all virtual location-references from the
locref-list.

<<Processing location-reference-groups>>=
(defun remove-virtual-locrefs (locref-cls-grp)
  (set-members (delete-if #'(lambda (object)
                              (and (typep object 'location-reference)
                                   (state-virtual-p object)))
                          (get-members locref-cls-grp))
               locref-cls-grp))
@ %def remove-virtual-locrefs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Sid}{\irule{substitute-if-double}\xspace}
\newcommand{\sid}{\irule{subs-if-dbl}\xspace}

\subsubsection{Apply all \Sid-rules}
\label{sec:subs-if-dbl}

This application operates on a set $L_i$ of location-references. All
\Sid-rules define a relation on the set $C$ of category-attributes
(ca). The relation is notated in the form `\Sid~$x$~$y$' or
abbreviated `\sid~$x$~$y$'.

There are two ways the user can specify these relations:
\begin{enumerate}
\item By explictly defining a set $C_U$ of rules of the form
  `\sid~$x$~$y$' with $x,y\in C$.
\item By defining virtual category-attributes (vca's). E.g.\@the
  definition of a vca $v:=(x~y~z)$ composed of the ca's $x,y,z$
  defines implicitely `\sid~$x$~$y$' and `\sid~$y$~$z$'. Tis set of
  rules is denoted $C_V$.
\end{enumerate}
%%
The question now arises if we should deduce that also implicitely
holds `\sid~$x$~$z$'? This means if we should calculate the
\term{transitive hull} on our relation. In a simple case like this the
user can add the remaining rule by her-/himself, but in more complex
cases we can calculate the transivie hull for him without the danger
of making any mistakes. We think that the user may expect a behaviour
that says `replace $z$ because we already have it in the form of $x$.'
and therefore define the transitive hull of the defined vca's. This is
a design decision but we will add a user-definable hook to change this
behaviour by not calculating the transitive hull. We denote the
transitive-hull operator with an appended star ($*$).  The resulting
relation $C_R$ can now be calculated in several ways:
\begin{enumerate}
\item $C_R:=C_U\cup C_V$$*$, defined as the default.
\item $C_R:=C_U$$*$$\cup C_V$. (seems very meaningless to me)
\item $C_R:=C_U$$*$$\cup C_V$$*$, if the user wants the transitive
  hull also be generated over his specification.
\item $C_R:=(C_U\cup C_V)*$, if the user wants a global transitive
  hull generation.
\end{enumerate}
%%
We conclude that we probably need three separate hooks for the
transitive-hull-calculation of $C_U,C_V$ and $C_U\cup C_V$. The users
are then free to do whatever (more or less) they want. The application
of these hooks is done in submodule \module{idxclass}. Additionally we
could include a check to see if some of the relations are
\term{refexive} what actually doesn't make any sense, since no
location-reference wants to substitute itself.

\medskip

After the definition of the substitution-relation we continue to
process the location-references. Until now we havent't defined what
\term{substitution} actually means. There are two ways.
\begin{enumerate}
\item To substitute means to \term{remove} in a way that the
  substituted location-reference will be removed.
\item It means to set the state of the substituted location-reference
  to \term{virtual} to allow it to be joined into a range.
\end{enumerate}
Both ways make sense so we need another hook to specify in what sense
to substitute.

\medskip

Informally we can describe this process as follows: $\forall l\in L_i$
test, if there exists $k\in L_i$ with $k\not=l\wedge\fstat{k}=\Real
\wedge\fordnum{k}=\fordnum{l}\wedge \exists
r=`\sid~\fcatattr{k}~\fcatattr{l}'\in C_R$ in which case we set
\fstat{$l$} to \Virt or remove $l$.

Actually we reset $l$'s state to \Virt means to move it from the set
of \emph{real} location-references into the set of \emph{virtual}
location-references. This happens only in the case that there really
exists a location-reference $k$ which is \Real.

The general idea for processing the location-references is to
separate them into sublists that contain location-references with the
same \term{ordnum}. For each of these sublists we call
[[apply-substitution-rules]]. This function returns a list of the
modified location-references without those being removed (if there
were some). Immediately we apply [[apply-merge-rules]] on this list
which will be described in the next section. This is the simplest way,
since the list ist in the exact form we need for optimal processing.

The resulting list is stored back into the [[member]]-slot
of the group.
\begin{note}
  Afterwards the list is in the form
  \begin{center}
    (\emph{ordnum-list}$_1$\ldots\emph{ordnum-list}$_n$) with
    \emph{ordnum}$_i$ =
    (\emph{locref}$_{i,1}$\ldots\emph{locref}$_{i,n}$).
  \end{center}
  This form is used in further steps.
\end{note}

<<Apply substitution- and merge-rules>>=
(defmethod apply-substitution-and-merge-rules ((locref-cls-grp locref-class-group)
                                               (idxcls         indexclass))
  (let ((locref-same-ordnum-grps
         (split-same-locrefs (get-members locref-cls-grp))))
    (set-members
     (mapcan #'(lambda (locref-same-ordnum-grp)
                 (apply-merge-rules
                  idxcls
                  (apply-substitution-rules idxcls
                                            locref-same-ordnum-grp)))
             locref-same-ordnum-grps)
     locref-cls-grp))
  locref-cls-grp)

<<Apply substitution-rules>>
<<Apply merge-rules>>
@ %def process-group apply-substitution-and-merge-rules

\no This function splits the location-references into sublists with
the same ordnums.

<<Apply substitution-rules>>=
(defun split-same-locrefs (locrefs)
  #+ASSERT! (assert! (listp locrefs))
  (split-list #'(lambda (locref)
                  (get-ordnums locref))
              locrefs
              :sortfunc #'(lambda (locref-ordnum-1 locref-ordnum-2)
                            (locref-ordnum< locref-ordnum-1 locref-ordnum-2))
              ))
@ %def split-same-locrefs

\no The next function takes a list of location-references with the
same ordnum and applies the substitution-rules on them. It returns a
list of the remaining (if some have been removed) or modified (if
their state has been changed) location-references.

<<Apply substitution-rules>>=
(defmethod apply-substitution-rules ((idxcls indexclass)
                                     (locrefs list))
  (let ((substitute-locref (get-substitution-subst-hook idxcls)))
    (delete-if #'null
               (mapcar #'(lambda (test-locref)
                           (cond ((some #'(lambda (against-locref)
                                            (substitutable-p idxcls test-locref
                                                             against-locref))
                                        locrefs)
                                    (funcall substitute-locref test-locref))
                                 (t test-locref)))
                       locrefs))))
@ %def apply-substitution-rules-on-locref-list

\no To test if [[test-locref]] can be substituted by
[[against-locref]] we first test for equality in which case it is not
substitutable. Afterwards we check if the state of the
[[against-locref]] is normal and if they are in relation according to
the indexstyle. Otherwise no substitution may occur.

<<Apply substitution-rules>>=
(defmethod substitutable-p ((idxcls         indexclass)
                            (test-locref    layered-location-reference)
                            (against-locref layered-location-reference))
  (cond ((eql test-locref against-locref)
           nil)
        ((and (state-normal-p against-locref)
              (relation-p (get-implicit-subst-rules idxcls)
                          (get-catattr against-locref)
                          (get-catattr test-locref))))
        (t nil)))
@ %def substitutable-p

<<Export-list of submodule \module{idxentry}>>=
(export '(process-group split-same-locrefs
          apply-substitution-rules substitutable-p))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Apply all \irule{merge-to}- and \irule{drop-if-merged}-rules}

The formal description says: Initialize the set of new
location-references $L_i^+:=\{\}$. For all $l\in{}L_i$ (virtual or
not) if exists a rule `$\irule{merge-to}~\fcatattr{l}~x$' then
$L_i^+:=L_i^+\cup{}l_+$ with
\[l_+:=l\,[\Fstat{}:=\Virt,\Fcatattr{}:=x].\]
or if additionally holds `\irule{drop-if-merged}~\fcatattr{l}~x'
\[l_+:=l\,[\Fstat{}:=\Virt,\Fcatattr{}:=x,\Fparent:=\fparent{l}].\]
After applying the last steps we first need to union $L_i$ and $L^+_i$
to receive the extended set $L_i:=L_i\cup L_i^+$.

\noindent The basic idea is to generate new location-references that
are equal to their parents but with \Fstat{} set to \Virt and if there
exists an applicable \irule{drop-if-merged}-rule additionally
\Fparent{} holds a reference to the parent location-reference, since
we must be able to actually \emph{drop} the parent, if necessary.

The implementation performs the creation of new location-references as
needed but does not check for duplicates. Duplicates can occur when we
don't use the \irule{drop-if-merged}-rule and equal
location-references are generated from different category-attributes.
Additionally there can exist \term{virtual} location-references for
which also exists their \term{normal} counterpart. We do not worry
about too much location-references. In the ramaining steps this will
not cause any problems (hopefully).

<<Apply merge-rules>>=
(defmethod apply-merge-rules ((idxcls indexclass) (locrefs list))
  (let ((merge-rules          (get-merge-rules idxcls))
        (drop-if-merged-rules (get-drop-if-merged-rules idxcls)))
    (nconc locrefs
           (mapcan #'(lambda (locref)
                       (mapcan #'(lambda (catattr)
                                   (let ((new-locref
                                          (make-layered-location-reference
                                           :virtual  t
                                           :catattr  catattr
                                           :ordnums  (get-ordnums locref)
                                           :layers   (get-layers locref)
                                           :locclass (get-locclass locref))))
                                     (when (relation-p drop-if-merged-rules
                                                       (get-catattr locref)
                                                       catattr)
                                       (set-origin locref new-locref))
                                     (list new-locref)))
                               (relation-set merge-rules (get-catattr locref))))
                   locrefs))))
@ %def apply-merge-rules

<<Export-list of submodule \module{idxentry}>>=
(export '(apply-merge-rules))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Building of ranges}

Building of ranges the next job to be done. In general we have to
solve two problems:
\begin{itemize}
\item The application of the \irule{drop-if-merged}-rule is somewhat
  problematic. The notion of \term{dropping} a location-reference
  needs an exact definition. We can say, that dropping simply means to
  reset the state of a location-reference to virtual. This works well
  and doesn't cause any trouble. But when it is intended to actually
  \term{remove} a dropped location-reference the order in which the
  category-attribute-groups are processed is significant. Since we
  must delay the building of ranges inside a category-attribute until
  we know which location-references aren't removed we need to know the
  \term{order} in which the category-attributes must be processed.
  This can easily determined by sorting the
  \irule{drop-if-merged}-relation topologically and start with a
  category-attribute $c$ such there doesn't exist a rule
  `\irule{drop-if-merged}~$c~x$' which means that this catattr can't
  be dropped. The problem is to ensure that there exists a topological
  sort on the category-attributes. Otherwise it is possible that a
  circular droping may occur which is an error. In this case the user
  must be advised to correct his erroneus specification. Function
  [[make-ready]] in submodule \module{idxclass} calculates for a given
  category-attribute its position in the topological sorting of all
  \irule{drop-if-merged}-rules and stores the resulting value into the
  [[processing-ordnum]]-slot of the catattr. For all
  category-attributes that are not involved in these rules we can put
  them in any order (this is done by setting the initial value to 0).

  We start by splitting the location-references into
  category-attribute-subgroups (ordered by their processing-number)
  and process each of those subgroups.

\item The second problem deals with the range-building of
  \term{var-classes}. Currently we don't support bulding of ranges for
  var-classes because we want to make some experience with the
  standard-classes first.
\end{itemize}

\subsubsection*{Separation into sublists with the same category-attribute}

We now come closer to the building of ranges and we need a different
view on the location-references. In the last sections we processed
location-references with equal ordnums in general. Now we must focus
on location-references that have to the same category-attribute.

Function [[build-ranges]] returns a list of location-references and
--ranges. The call to [[mapcan]] is neccessary to remove the
additional structure introduced by the mapping process.

<<Building of ranges>>=
(defun build-ranges-in-locref-class-group (locref-cls-grp idxcls)
  (let ((locref-same-catattr-grps
         (split-list #'(lambda (locref) (get-catattr locref))
                     (get-members locref-cls-grp)
                     :sortfunc #'(lambda (x y)
                                   (< (get-processing-ordnum x)
                                      (get-processing-ordnum y))))))
    (set-members (mapcan #'(lambda (catattr-sublist)
                             (build-ranges catattr-sublist
                                           idxcls
                                           (get-locclass
                                            (car catattr-sublist))))
                         locref-same-catattr-grps)
                 locref-cls-grp)))
@ %def build-ranges-in-locref-class-group

\no The implementation of [[build-ranges]] is continued in submodule
\module{ranges}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Separation into category-attribute-groups}

At the end we must separate the location-references and ranges into
the category-attribute-groups. Now we must focus on
location-references that belong to the same category-attribute-group.
We introduce a new class for easy dispatching during the
markup-processing.

The category-attribute-groups (cag's) are described by a injective
function $\phi$ from the set $C$ of category-attributes to the set $G$
of cag's. Since $\phi$ is given we do $\forall l\in L_i:
\fcag{l}:=\phi(\fcatattr{l})$. Divide $L_i$ into equivalence-classes
$K_1,\ldots,K_m$ that for each pair $l,k\in{}K_j$ holds:
$\fcag{l}=\fcag{k}$. Additionally holds $\forall x\in K_j,\forall
y\in K_k,j\not=k\Rightarrow\fcag{j}\not=\fcag{k}$.

\smallskip\noindent%%
A category-attribute contains an additional slot [[ordnum]] that keeps its
ordnum. Currently this slot is initialized but unused.

Method [[separate-into-catattr-groups]] takes a location-class-group
whose [[members]]-slot contains a list of location-references and
location-ranges. It splits this list into the catattr-groups by
calling [[get-catattr-grp-ordnum]] with the catattr of all objects. Method
[[get-catattr]] is defined for location-references and location-ranges
so we don't need to distinguish between them explicitly.

Finally we fill the [[ordnum]]-slot of all catattr-groups (maybe we
don't need it at all).

<<Separation into category-attribute-groups>>=
(defclass category-attribute-group (locref-group)
    ((ordnum #| get-ordnum is macro |# :writer set-ordnum :initform 'nil)))

(defun separate-into-catattr-groups (locref-cls-grp)
  (set-members (convert-sublists-to-group-objects
                (split-list #'(lambda (object)
                                (get-catattr-grp-ordnum (get-catattr object)))
                            (get-members locref-cls-grp)
                            :sortfunc #'<)
                'category-attribute-group)
               locref-cls-grp)
  (mapc #'(lambda (catattr-grp)
            (set-ordnum (get-catattr-grp-ordnum
                         (get-catattr (car (get-members catattr-grp))))
                        catattr-grp)
            (set-members
             (sort (tree-location-references (get-members catattr-grp)
                                             (get-hierdepth
                                              (get-locclass locref-cls-grp)))
                   #'(lambda (object-1 object-2)
                       (let ((ordnum-1 (get-ordnums object-1))
                             (ordnum-2 (get-ordnums object-2)))
                         (or (locref-ordnum< ordnum-1 ordnum-2)
                             (and (locref-ordnum= ordnum-1 ordnum-2)
                                  (< (get-sort-ordnum (get-catattr object-1))
                                     (get-sort-ordnum (get-catattr object-2))))))))
             catattr-grp))
        (get-members locref-cls-grp))
  locref-cls-grp)

#|
(defun separate-into-catattr-groups-old-version (locref-cls-grp)
  (set-members (convert-sublists-to-group-objects
                (split-list #'(lambda (object)
                                (get-catattr-grp-ordnum (get-catattr object)))
                            #'<
                            (get-members locref-cls-grp))
                'category-attribute-group)
               locref-cls-grp)
  (mapc #'(lambda (catattr-grp)
            (set-ordnum (get-catattr-grp-ordnum
                         (get-catattr (car (get-members catattr-grp))))
                        catattr-grp)
            (set-members
             (sort (get-members catattr-grp)
                   #'(lambda (object-1 object-2)
                       (let ((ordnum-1 (get-ordnums object-1))
                             (ordnum-2 (get-ordnums object-2)))
                         (or (locref-ordnum< ordnum-1 ordnum-2)
                             (and (locref-ordnum= ordnum-1 ordnum-2)
                                  (< (get-sort-ordnum (get-catattr object-1))
                                     (get-sort-ordnum (get-catattr object-2))))))))
             catattr-grp))
        (get-members locref-cls-grp))
  locref-cls-grp)
|#
@ %def category-attribute-group separate-into-catattr-groups

<<Export-list of submodule \module{idxentry}>>=
(export '(category-attribute-group))
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Building location-reference trees}

Sometimes it is desirable to form location-references into a
hierarchy. For example the following sequence of location-references
\begin{center}
1--2, 1--3, 1--4, 1--7
\end{center}
may also be written as
\begin{center}
  1\quad{}2, 3, 4, 7 .
\end{center}
We call this type of conversion \term{treeing} of a list of
location-references. To tree a list of location-references some
preconditions must be fulfilled:
\begin{enumerate}
\item They must be members of a \class{layered-location-class}.
\item All location-references must be of the same class.
\end{enumerate}
A more subtle problem arises, when we use location-references that
own different category-attributes. Imagine the following list
\begin{center}
\textbf{1--2}, 1--3, \textbf{1--4}, 1--7
\end{center}
what should the result look like? The most obvious solution might be
\begin{center}
  1\quad{}\textbf{2}, 3, \textbf{4}, 7 .
\end{center}
but there are other possibilities as well. Since this situation can
only occur in a single category-attribute-group, we choose the least
specific category-attribute of the group as the catattr of the
\emph{root}-reference (in this example the `1') and the
sub-location-references keep their attribute. So for the group
\begin{center}
  \texttt{(bold italic default)}
\end{center}
we use \emph{always} \texttt{default} as the category-attribute of the
root-reference (see [[get-last-in-group]]). We hope this is the most
intuitive solution for the moment.

<<Treeing location-references>>=
(defmacro take-first (list)
  `(AND ,list  (LIST (CAR ,list))))

(defun tree-location-references (locref-list
                                 max-depth
                                 &optional (curr-depth 1))
  (if (or (endp locref-list)        #| nothing more to do |#
          (> curr-depth max-depth)) #| we reached the end |#
      locref-list  #| this is the THEN case |#
      (let ((locref-slist (split-list #'(lambda (locref)
                                          (car (get-layers locref)))
                                      locref-list
                                      :sort-func #'string<)))
        (mapcar
         #'(lambda (sublist)
             (let* ((locref (car sublist))
                    (layers (get-layers locref)))
               (if (= 1 (length layers))
                   (progn #| length = 1 |#
                     (set-subrefs
                      (sort-locrefs
                       (tree-location-references (remove-first-layers
                                                  (cdr sublist))
                                                 max-depth
                                                 (1+ curr-depth)))
                      locref)
                     locref)
                   (let #| length > 1 |#
                       ((new-locref
                         (make-layered-location-reference
                          :layers   (take-first (get-layers locref))
                          :ordnums  (take-first (get-ordnums locref))
                          :locclass (get-locclass locref)
                          :catattr  (get-last-in-group (get-catattr locref))
                          )))
                     (set-subrefs
                      (sort-locrefs
                       (tree-location-references (remove-first-layers sublist)
                                                 max-depth
                                                 (1+ curr-depth)))
                      new-locref)
                     new-locref))))
         locref-slist))))
@ %def take-first tree-location-references

<<Treeing location-references>>=
(defun remove-first-layers (locref-list)
  (declare (inline))
  (mapc #'(lambda (locref)
            (typecase locref
              (layered-location-reference
                 (set-ordnums (cdr (get-ordnums locref)) locref)
                 (set-layers  (cdr (get-layers  locref)) locref))
              (location-range
                 (let ((first (get-first locref))
                       (last (get-last locref)))
                   (set-layers  (cdr (get-layers  first)) first)
                   (set-ordnums (cdr (get-ordnums first)) first)
                   (set-layers  (cdr (get-layers  last))  last)
                   (set-ordnums (cdr (get-ordnums last))  last)
                   ))))
        locref-list)
  locref-list)
@ %def remove-first-layers

<<Export-list of submodule \module{locref}>>=
(export '(tree-location-references))
@

<<Treeing location-references>>=
(defun sort-locrefs (locref-list)
  #+:ASSERT! (assert! (listp locref-list))
  (sort locref-list
        #'(lambda (locref-1 locref-2)
            (locref-ordnum< (get-ordnums locref-1)
                            (get-ordnums locref-2)))))
@ %def sort-locrefs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Splitting into sublists}

This is a function that operates on lists. It takes a list and groups
its elements into new subgroups. The given function [[split-function]]
must return the same value for all elements that belong to the same
group. These values are compared with the [[#'equal]]-predicate. Its
meaning is to create \emph{equivalence-classes} of elements. The
resulting sublists are sorted by function [[sort-function]] which must
define a \emph{less-than}-predicate of the values [[split-function]]
delivers. The result is a list containing the sorted sublists.

<<Splitting lists into sublists --- [[split-list]]>>=
(defun split-list (split-function list &key sortfunc headfunc)
  #+:ASSERT! (assert (not (and sortfunc headfunc))
                     "split-list")
  (let ((list-len (length list)))
    (if (= 1 list-len)
        (list list)
        (let ((split-table (make-hash-table :test #'equal
                                            :size (round (* 1.2 list-len))))
              (key-list '()))
          (mapc #'(lambda (elt)
                    (let ((key (funcall split-function elt)))
                      (setf (gethash key split-table)
                            (cons elt (gethash key split-table)))))
                list)
          (maphash #'(lambda (key element)
                       (declare (ignore element))
                       (push key key-list))
                   split-table)
          (maplist #'(lambda (rest-list)
                       (let ((entries (gethash (car rest-list) split-table)))
                         (if headfunc
                             (let ((head (find-if headfunc entries)))
                               (rplaca rest-list
                                       (if head
                                           (cons head (delete head entries))
                                           entries)))
                             (rplaca rest-list entries))))
                   (if sortfunc (sort key-list sortfunc) key-list))
          key-list))))

#|
This version seems to be a little bit slower than the above one,
despite the fact that we use a temporary array with a fill-pointer.

(defun split-list (split-function sort-function list)
  (let ((list-len (length list)))
    (if (= 1 list-len)
        (list list)
        (let ((split-table (make-hash-table :test #'equal
                                            :size (round (* 1.5 list-len)))))
          (mapc #'(lambda (elt)
                    (let ((key (funcall split-function elt)))
                      (setf (gethash key split-table)
                            (cons elt (gethash key split-table)))))
                list)
          (let ((sort-array (make-array (hash-table-count split-table)
                                        :fill-pointer 0)))
            (maphash #'(lambda (key element)
                         (declare (ignore element))
                         (vector-push key sort-array))
                     split-table)
            (map 'list
                 #'(lambda (key)
                     (gethash key split-table))
                 (sort sort-array sort-function)))))))
|#
@ %def split-list

<<Export-list of submodule \module{locref}>>=
(export '(split-list))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{idxentry}>>=
;; $Id$

<<Global definitions of submodule \submodule{idxentry}>>
<<Class \class{index-entry}>>
<<Processing an indexentry>>

<<Export-list of submodule \module{idxentry}>>
@

<<RCS-Identifier>>=
("idxentry" . "$Id$")
@ %def RCS-Identifier

<<Global definitions of submodule \submodule{idxentry}>>=
(defvar *number-of-indexentries*)
(defvar *current-number*)
(defvar *percentage-list*)
(defvar *processing-percentage-list*)
@ %def *number-of-indexentries* *current-number* *percentage-list* *processing-percentage-list*

<<Export-list of submodule \module{idxentry}>>=
(export '*percentage-list*)
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Pretty-printing}

<<Pretty-printing>>=
#+:XP
(set-pprint-dispatch 'index-entry
                     #'(lambda (s idxent)
                         (pprint-logical-block
                          (s nil :suffix "}")
                          (pprint-indent :block 2 s)
                          (write-string "Indexentry {" s)
                          (pprint-newline :mandatory s)
                          (write-string "main-key: " s)
                          (write (get-main-key idxent) :stream s)
                          (pprint-newline :mandatory s)
                          (write-string "merge-key: " s)
                          (write (get-merge-key idxent) :stream s)
                          (pprint-newline :mandatory s)
                          (write-string "sort-key: " s)
                          (write (get-sort-key idxent) :stream s)
                          (pprint-newline :mandatory s)
                          (pprint-logical-block
                           (s nil :suffix "}")
                           (write-string "Locrefs {" s)
                           (pprint-indent :block 2)
                           (pprint-newline :mandatory s)
                           (pprint-linear s (get-locrefs idxent)))
                          (pprint-newline :mandatory s)
                          (pprint-logical-block
                           (s nil :suffix "}")
                           (write-string "Subentries {" s)
                           (pprint-indent :block 2)
                           (pprint-newline :mandatory s)
                           (pprint-linear s (get-subentries idxent)))
                          (pprint-newline :mandatory s))
                         ))
@

\no Here we define a function that is used to specify the pretty-print
of locref-groups. Function [[pprint-locref-group]] prints [[grp]] on
stream [[s]]. It uses [[name]] to add the name of the group into the
pretty-print-stream. Function [[set-pprint-locref-group-dispatch]] is
needed to add the class-types into the dispatch-table for the
pretty-printer.

<<Pretty-printing>>=
#+:XP
(defun pprint-locref-group (s grp name)
  (pprint-logical-block
   (s nil :prefix "(" :suffix ")")
   (write-string name s)
   (write-string ":" s)
   (when (typep grp 'category-attribute-group)
     (write (get-ordnum grp) :stream s))
   (pprint-indent :block 2 s)
   (pprint-newline :mandatory s)
   (pprint-fill s (get-members grp) nil)
   (pprint-indent :block -1 s)
   (pprint-newline :mandatory s)))

#+:XP
(defun set-pprint-locref-group-dispatch (class name &optional (rank 0))
  (set-pprint-dispatch class
                       #'(lambda (s grp)
                           (pprint-locref-group s grp name))
                       rank))
@ %def pprint-locref-group set-pprint-locref-group-dispatch

\no When adding types is is absolutely necessary to add a rank into
the dispatch-table, that describes the inheritance-relations between
the classes. For example, class [[locref-group]] is base-class of all
other locref-groups. Therefore the other classes need a higher rank to
explicitely define a precedence during the pretty-printer-dispatching
(This took me quite a while to work it out\ldots uff!). As can be seen
the given ranks (third argument of
[[set-pprint-locref-group-dispatch]]) describe exactly the topological
sort of the class-relationships.

This section is placed here before the definition of all classes.

<<Pretty-printing>>=
#+:XP
(set-pprint-locref-group-dispatch 'locref-group
                                  "LOCREF-GROUP"               0)
#+:XP
(set-pprint-locref-group-dispatch 'locref-class-group
                                  "LOCREF-CLASS-GROUP"         1)
#+:XP
(set-pprint-locref-group-dispatch 'crossref-class-group
                                  "CROSSREF-CLASS-GROUP"       2)
#+:XP
(set-pprint-locref-group-dispatch 'category-attribute-group
                                  "CATEGORY-ATTRIBUTE-GROUP"   3)
@


%% $Log$
%% Revision 1.22  1996/07/22 15:54:53  kehr
%% Replaced some of the oops-macros by nraw-macros. Implemented the
%% checking of the cross-references.
%%
%% Revision 1.21  1996/07/11  14:16:26  kehr
%% Complete Major checkin before changing the letter-groups.
%%
%% Revision 1.20  1996/07/09  14:41:46  kehr
%% Corrected a bug in the incorrect usage of the split-list-function.
%% Added some features to this function such that for each group that is
%% created an element satisfying a predicate can be made the head of the
%% resulting list. This is supported via the :headfunc keyword-parameter.
%% I needed this to correct an error in the
%% build-indexentry-tree-functions.
%%
%% Revision 1.19  1996/07/01  09:19:26  kehr
%% Added support for flat indexes and modified logfile-support.
%%
%% Revision 1.18  1996/06/24  09:12:44  kehr
%% Several changes in all Lisp-modules due to the new startup-module and
%% the implementation of the percentage bar appearing in the processing
%% phases.
%%
%% Revision 1.17  1996/06/03  10:01:33  kehr
%% Added support for treeing layered-location-references.
%%
%% Revision 1.16  1996/05/29  14:15:38  kehr
%% Complete checkin after the major changes in the markup. See ChangeLog
%% for details.
%%
%% Revision 1.15  1996/05/20  08:48:47  kehr
%% Major release of the modules locref, idxstyle and index. Added picture
%% for the range-building FSM with a complete rewrite.
%%
%% Revision 1.14  1996/05/09  11:49:41  kehr
%% Changes in all submodules, due to macro-expansion problems during
%% compilation.
%%
%% Revision 1.13  1996/05/06  10:01:22  kehr
%% Minor changes in nearly all modules.
%%
%% Revision 1.12  1996/04/30  15:54:14  kehr
%% Rewrote large parts of part that ist responsible for adding an
%% indexentry. Moved some parts from idxentry to index and restructured
%% the whole functions that deal with that topic.
%%
%% Revision 1.11  1996/04/29  08:38:06  kehr
%% Forgot some declarations.
%%
%% Revision 1.10  1996/03/28  16:47:33  kehr
%% Changed modules to work together with the foreign package `ordrules'.
%%
%% Revision 1.9  1996/03/13  16:53:22  kehr
%% Don't remember specific changes. Just time to check-in.
%%
%% Revision 1.8  1996/01/31  16:13:27  kehr
%% Still working on th user-interface...
%%
%% Revision 1.7  1996/01/09  14:27:24  kehr
%% Moved submodule `ranges' from module `locref' to this module.
%% Nearly complete rewrite of all submodules. See ChangeLog for further details.
%%
%% Revision 1.6  1995/12/19  10:59:44  kehr
%% Changes Imakefile.
%%
%% Revision 1.5  1995/12/15  17:09:07  kehr
%% Wrote down more specification for the locref-handling.
%%
%% Revision 1.4  1995/12/13  16:44:16  kehr
%% Extended the specification of the location-reference-handling. Implemented
%% the transitive-hull algorithm.
%%
%% Revision 1.3  1995/12/13  14:07:25  kehr
%% Just a check-in to preserve the transitive-hull-function.
%%
%% Revision 1.2  1995/12/11  17:37:01  kehr
%% Added semi-formal description of the location-refernce handling.
%%
%% Revision 1.1  1995/12/05  18:46:29  kehr
%% Added module `index' and restructured some parts.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Revision 1.13  1995/07/28  10:41:17  kehr
%% Added simple markup for location-references and ranges. Currently
%% exists no support for differen layer-markup. A location-reference is
%% always printed as a whole.
%%
%% Revision 1.12  1995/07/27  23:59:02  kehr
%% Added support for keword-markup.
%%
%% Revision 1.11  1995/07/27  14:36:43  kehr
%% Added support for joining of locref-separated-groups.
%%
%% Revision 1.10  1995/07/26  16:19:53  kehr
%% Added support for the pretty-printer module. Output of data-structures
%% now looks more readable.
%%
%% Revision 1.9  1995/07/25  11:03:18  kehr
%% Added separation of location-references into seprated/mixed-groups.
%% Modified debug-output of locref-groups to reflect the real class-type
%% of the groups. Verified the process of generating these groups.
%%
%% Revision 1.8  1995/07/24  16:33:44  kehr
%% Added subgrouping of location-references with the same ordnum. Now
%% I'll start to join ranges.
%%
%% Revision 1.7  1995/07/23  20:48:33  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.6  1995/07/23  14:14:09  kehr
%% Added support for merge-to--rule. Now works and creates
%% virtual-attributes as expected.
%%
%% Revision 1.5  1995/07/15  20:50:22  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.4  1995/07/11  23:33:07  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.3  1995/07/11  15:14:16  kehr
%% Today I finished the definition of indexentries. They now will be
%% inserted into the index when a appropriate location-class was finished.
%%
%% Revision 1.2  1995/07/11  00:47:44  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%
%% Revision 1.1  1995/07/09  18:14:27  kehr
%% Initial checkin.
%%


%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:
