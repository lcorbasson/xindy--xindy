%%
%% This file is part of the `makeindex4'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module: `index'
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{index}}

\subsection{Introduction}

\subsection{Abstract Specification}

\subsubsection{Definition}

\subsubsection{Operation}


\subsection{Concrete Specification}

\subsubsection{Class \class{base-index}}

Indexentries consist of a set of keys and a set of
location-references. An index is a data-structure that is empty on
creation and filled afterwards with indexentries. Indexentries that
own the same \term{merge-key} are merged together meaning that the
location-reference-sets are merged together. Usually the indexentries
are read in an unsorted sequence, so we can collect all indexentries
in a list an sort it afterwards. This is a waste of space since for
each indexentry we separately store all keys. Instead we can merge
indexentries with the same key directly when they are read.

The idea is to store the indexentries in a large hash-table with the
merge-key as its key. We are then able to directly merge new
indexentries with the old one with reasonable performance since we
share all indexentry-keys. Later we need to sort the elements of the
hash-table to markup the index.

Class \class{base-index} implements an index. It contains the
following slots:
\begin{slots}{entry-table}
  \item [entry-table] is the hash-table just described. We use
    [[#'equal]] as the tables test-function since the keys are of type
    \tstrlist.
  \item [entry-list] After the hash-table is filled, we need to sort
    and process the indexentries in an order defined by the
    indexentries \term{sort-keys}. This slot keeps this list.
  \item [idxclass] is a reference to the indexclass used to
    parametrize this index. Especally markup-information is contained here.
\end{slots}

<<Class \class{base-index}>>=
(defclass base-index ()
    ((entry-table :accessor get-entry-table :initform (make-hash-table :test #'equal))
     (entry-list  :reader get-entry-list :writer set-entry-list :initform '())
     (idxclass    :reader get-idxclass                          :initarg :idxclass)))

(defun make-base-index (idxclass)
  (make-instance 'base-index :idxclass idxclass))
@ %def base-index make-base-index

<<Export-list of submodule \module{index}>>=
(export '(base-index make-base-index))
@

<<markup methods>>=
(defmethod markup-object ((idx base-index)
                          (markup-list  list)
                          (context-list list)
                          (env-stack    list))
  (do ((indexentries (get-entries idx) (cdr indexentries)))
      ((endp indexentries)
         (close-environments env-stack))
    (let ((idxent (car indexentries)))
      (setq env-stack (markup-object idxent markup-list
                                     context-list env-stack))
      (setq context-list (get-print-key idxent)))))
@

\no We are now interested in filling the index with indexentries. The
first idea was to define a method [[add]] bound to an index and an
indexentry that looks if the indexentry is already in the table. If
not it is directly stored into the table, otherwise the indexentry is
merged with the already existing indexentry with the same key.

This heavily creates instances of indexentries that mostly are merged
with the already existing indexentry. Most of the time the
indexentries are created and dropped immediately. This is a waste of
space and time since the creation of an object ins't for free at all.

The idea is to define a function at a lower level to implement the
desired behaviour. Function [[add-indexentry]] takes an object that
must be [[eql]] to a [[entry-table]]. We will directly manipulate this
object for efficency reasons. The other arguments are directly part of
an indexentry.

<<Class \class{base-index}>>=
(defun add-indexentry (entry-table idxcls locref
                                   &key
                                   (merge-key '()) (sort-key '())
                                   (main-key '()) (print-key '()))
  (let ((old-entry (gethash merge-key entry-table)))
    (if old-entry
        (setf (gethash merge-key entry-table)
              (join-indexentries (gethash merge-key entry-table)
                                 main-key sort-key print-key locref))
        (setf (gethash merge-key entry-table)
              (make-indexentry :main-key  main-key      :sort-key   sort-key
                               :merge-key merge-key     :print-key  print-key
                               :locrefs   (list locref) :indexclass idxcls)))))
@ %def add-indexentry

\no Function [[join-indexentries]] implements a
\emph{default-behaviour} when joining indexentries. The
indexentry-keys are joined by the [[join-with-precedence]]-function
which is defined as $\lambda x,y.(if x x y)$.

<<Class \class{base-index}>>=
(defun join-indexentries (idxent main-key sort-key print-key locref)
  (set-main-key  (join-with-precedence (get-main-key  idxent) main-key) idxent)
  (set-sort-key  (join-with-precedence (get-sort-key  idxent) sort-key) idxent)
  (set-print-key (join-with-precedence (get-print-key idxent) print-key) idxent)
  (set-locrefs   (cons locref (get-locrefs idxent)) idxent)
  idxent)

(defun join-with-precedence (x y)
  (declare (inline))
  (if x x y))
@ %def merge-indexentries join-with-precedence

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sorting an index}

Sorting an index is the task to transform the
hash-table-representation of an index into a sorted
list-representation.  We iterate with [[maphash]] over all the
hash-tables elements and prepend the [[temp-list]] with a
[[cons]]-cell (\emph{key}~.~\emph{idxent}). Afterwards we sort this
list by comparing the first elements of the cons-cells and store the
result into slot [[entry-list]].

<<Sorting an index>>=
(defmethod sort-indexentries ((index base-index))
  (let ((temp-list '()))
    (maphash #'(lambda (key idxent)
		 (declare (ignore key))
                 (setq temp-list (cons (cons (get-sort-key idxent) idxent) temp-list)))
             (get-entry-table index))
    (set-entry-list (sort temp-list
                          #'(lambda (element-1 element-2)
                              (strlist< (car element-1) (car element-2))))
                    index)))

(defun strlist< (string-list-1 string-list-2)
  (declare (inline))
  (do ((rest-1 string-list-1 (cdr rest-1))
       (rest-2 string-list-2 (cdr rest-2)))
      ((or (endp rest-1) (endp rest-2)
           (string/= (first rest-1) (first rest-2)))
         (or (endp rest-1)
             (if (endp rest-2)
                 'nil
                 (string< (first rest-1) (first rest-2)))))))
@ %def sort-index strlist<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Processing an index}

After the index is filled with indexentries our first task is to sort the index.
Additionally we need to process all indexentries. Because we decide to
make the processing of the indexentries directly driven by the markup,
we simply markup the index and start right out of the box.

<<Processing an index>>=
(defmethod process-index ((index base-index))
  (sort-indexentries index)
  ;(markup index)
  )
@ %def process-index

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The module root}

<<*>>=
;; $Id$

(in-package 'index)
(provide 'index)

(eval-when (compile load eval)
  (use-package 'clos)
  (use-package 'xp)
  (unless (find-package 'locref)
    (load 'locref))
  (use-package 'locref)
  (unless (find-package 'idxstyle)
    (load 'idxstyle))
  (use-package 'idxstyle))

<<Submodule \module{idxentry}>>
<<Submodule \module{ranges}>>
<<Submodule \module{index}>>

<<Pretty-printing>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{index}>>=
<<Class \class{base-index}>>
<<Export-list of submodule \module{index}>>

<<Sorting an index>>
<<Processing an index>>
@

<<RCS-Identifier>>=
("index" . "$Id$")
@

%% Local Variables:
%% mode: latex
%% TeX-master: t
%% End:
%%
%% $Log$
%% Revision 1.4  1996/01/09 15:58:36  kehr
%% Corrected minor bugs.
%%
%% Revision 1.3  1996/01/09  14:27:27  kehr
%% Moved submodule `ranges' from module `locref' to this module.
%% Nearly complete rewrite of all submodules. See ChangeLog for further details.
%%
%% Revision 1.2  1995/12/11  17:37:04  kehr
%% Added semi-formal description of the location-refernce handling.
%%
%% Revision 1.1  1995/12/05  18:46:32  kehr
%% Added module `index' and restructured some parts.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Revision 1.5  1995/07/27  23:59:03  kehr
%% Added support for keword-markup.
%%
%% Revision 1.4  1995/07/23  20:48:34  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.3  1995/07/15  20:50:23  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.2  1995/07/11  23:33:08  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.1  1995/07/11  00:47:44  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%

