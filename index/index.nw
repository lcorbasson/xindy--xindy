%%
%% This file is part of the `xindy'-project at the
%% Technical University Darmstadt, Computer Science Department
%% WG System Programming, Germany.
%%
%% This source is entirely written in the `noweb' literate programming
%% system.
%%
%% History at end
%%
%% Module: `index'
%%
%%
\RCS $Id$%
\RCS $Author$%
\RCS $Revision$%
\RCS $RCSfile$%
\RCS $State$%
\RCS $Date$%
%
\ModuleTitle{}


\section{Submodule \module{index}}

\subsection{Introduction}

\subsection{Abstract Specification}

\subsubsection{Definition}

\subsubsection{Operation}


\subsection{Concrete Specification}

\subsubsection{Class \class{base-index}}

Indexentries consist of a set of keys and a set of
location-references. An index is a data-structure that is empty on
creation and filled afterwards with indexentries. Indexentries that
own the same \term{merge-key} are merged together meaning that the
location-reference-sets are merged together. Usually the indexentries
are read in an unsorted sequence, so we can collect all indexentries
in a list an sort it afterwards. This is a waste of space since for
each indexentry we separately store all keys. Instead we can merge
indexentries with the same key directly when they are read.

The idea is to store the indexentries in a large hash-table with the
merge-key as its key. We are then able to directly merge new
indexentries with the old one with reasonable performance since we
share all indexentry-keys. Later we need to sort the elements of the
hash-table to markup the index.

Class \class{base-index} implements an index. It contains the
following slots:
\begin{slots}{entry-table}
  \item [entry-table] is the hash-table just described. We use
    [[#'equal]] as the tables test-function since the keys are of type
    \tstrlist.
  \item [entry-list] After the hash-table is filled, we need to sort
    and process the indexentries in an order defined by the
    indexentries \term{sort-keys}. This slot keeps this list.
  \item [idxclass] is a reference to the indexclass used to
    parametrize this index. Especally markup-information is contained here.
\end{slots}

<<Class \class{base-index}>>=
(defclass base-index ()
    ((entry-table :accessor get-entry-table
                  :initform (make-hash-table :test #'equal))
     (entry-list  :reader get-entry-list
                  :writer set-entry-list
                  :initform '())
     (idxclass    :reader get-idxclass
                  :initarg :idxclass)))

(defun make-base-index (idxclass)
  (make-instance 'base-index :idxclass idxclass))
@ %def base-index make-base-index

<<Export-list of submodule \module{index}>>=
(export '(base-index make-base-index get-entry-list))
@

<<Class \class{base-index}>>=
(defun create-index (idxclass)
  (make-instance 'base-index :idxclass idxclass))
@ %def create-index

<<Export-list of submodule \module{index}>>=
(export '(create-index))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Adding indexentries to the index --- The interface}

The process of adding an indexentry to the index consists of the
following steps:
\begin{enumerate}
\item We must check for a correct category-attribute class.

\item The string that represents the location-reference must be
  compared to all declared location-classes. This process returns a
  list of location-reference-objects. If only one object was returned
  this one is used as the location reference. If no object was
  returned, the string was invalid and we should issue a warning to
  the user. If more than object was returned the location-class
  declarations are not sound. In this situation, we let the first one
  win and also issue a warning.

\item If the keyword-rewriting feature is active we must perform the
  substitutions on the [[main-key]] (which is \emph{always}
  neccessary), yielding the [[merge-key]], and the [[merge-key]],
  yielding the [[sort-key]]. as described by the [[merge-rule]] and
  [[sort-rule]] replacement-rules.

  \begin{note}
    The keyword argument [[:merge-key]] must \emph{always} be supplied
    when calling this function.
  \end{note}

  The exact policies for all keys are as follows:
  \begin{enumerate}
  \item The [[merge-key]] is generated from the [[main-key]] by
    applying the keyword-rules, or if this rewrite-mechanism is not
    activated ([[#-:ORDRULES]]), the [[main-key]] directly.
  \item The [[sort-key]] is generated from the [[merge-key]] by
    applying the keyword-rules, or if this rewrite-mechanism is not
    activated ([[#-:ORDRULES]]), the [[merge-key]] directly.
  \item The [[print-key]] is only set, when it is specified
    explicitely.  If no explicit definition occured we take the
    [[main-key]] as the [[print-key]]. This can only be done at
    markup-time since we know only then if one of the raw-indexentries
    defined the print-key.
  \end{enumerate}

\item After these initial steps we check if there is already an
  indexentry in the index with the same [[merge-key]] as ours. If so
  we join both together, otherwise we create a new indexentry and
  store it into the index. When joining both indexentries we must keep
  care of the fact that we do not introduce duplicate
  location-references into the same indexentry.

\end{enumerate}

\no The description is now directly transformed into the following set
of functions:

<<Adding an indexentry>>=
(defun add-indexentry (entry-table idxcls locref
                                   &key
                                   (merge-key '()) (sort-key '())
                                   (main-key '()) (print-key '())
                                   (catattr nil))
  #+:ASSERT! (assert! (and entry-table main-key idxcls locref))

  (unless catattr (setq catattr (lookup-catattr idxcls "default")))
  (unless (lookup-catattr idxcls catattr)
    (warn "unknown attribute `~A'! (ignored)" catattr))

  (let ((location-reference
         (create-location-reference-from-string locref catattr)))

    #+:ORDRULES (unless merge-key
                  (setq merge-key (gen-keyword-mergekey-list main-key)))
    #+:ORDRULES (unless sort-key
                  (setq sort-key  (gen-keyword-sortkey-list merge-key)))
    #-:ORDRULES (unless merge-key (setq merge-key main-key))
    #-:ORDRULES (unless sort-key  (setq sort-key  merge-key))

    (let ((old-entry (gethash merge-key entry-table)))
      (if old-entry
          (setf (gethash merge-key entry-table)
                (join-indexentries (gethash merge-key entry-table)
                                   main-key sort-key print-key locref))
          (setf (gethash merge-key entry-table)
                (make-indexentry :main-key  main-key   :sort-key   sort-key
                                 :merge-key merge-key  :print-key  print-key
                                 :locrefs   (list location-reference)
                                 :indexclass idxcls))))))
@ %def add-indexentry

\no These functions perform the keword-rewriting on a list of strings.

<<Adding an indexentry>>=
(defun gen-keyword-mergekey-list (list-of-strings)
  #+ASSERT! (assert! (listp list-of-strings))
  (mapcar #'(lambda (str)
              (gen-keyword-mergekey str))
          list-of-strings))

(defun gen-keyword-sortkey-list (list-of-strings)
  #+ASSERT! (assert! (listp list-of-strings))
  (mapcar #'(lambda (str)
              (gen-keyword-sortkey str))
          list-of-strings))
@ %def gen-keyword-mergekey-list gen-keyword-sortkey-list

\no Function [[join-indexentries]] implements a
\emph{default-behaviour} when joining indexentries. The
indexentry-keys are joined by the [[join-with-precedence]]-function
which is defined as $\lambda x,y.(if x x y)$. Adding a new
location-reference to the indexentry is performed throuh the method
[[add]], which also checks for duplicates (\look{sec:cls-indexentry}
for further details).

<<Adding an indexentry>>=
(defun join-indexentries (idxent main-key sort-key print-key locref)
  (set-main-key (join-with-precedence (get-main-key idxent) main-key) idxent)
  (set-sort-key (join-with-precedence (get-sort-key idxent) sort-key) idxent)
  (set-print-key (join-with-precedence (get-print-key idxent) print-key) idxent)
  (add idxent locref))

(defun join-with-precedence (x y)
  (declare (inline))
  (if x x y))
@ %def merge-indexentries join-with-precedence

<<Export-list of submodule \module{index}>>=
(export '(add-indexentry))
@

\no The following function takes an string representing a
location-reference and scans all possible location-classes if the
location-reference-string matches with some of them. If it matches it
location-reference

<<Adding an indexentry>>=
(defun create-location-reference-from-string (locref-str catattr)
  (let* ((locref-list
	  (map-location-classes #'(lambda (loccls)
				    (make-locref locref-str loccls catattr)))))
    (case (length locref-list)
      (0 (warn "location-reference ~A did not match any location-class! (ignored)" locref-str))
      (1 (car locref-list) #| return its only member |#)
      (t (warn "location-reference ~A did match multiple location-classes! (taking first one)" locref-str)
	 (car locref-list) #| return its first member |#))))
@ %def create-location-reference-from-string

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sorting an index}

Sorting an index is the task to transform the
hash-table-representation of an index into a sorted
list-representation.  We iterate with [[maphash]] over all the
hash-tables elements and prepend the [[temp-list]] with a
[[cons]]-cell (\emph{key}~.~\emph{idxent}). Afterwards we sort this
list by comparing the first elements of the cons-cells and store the
result into slot [[entry-list]].

<<Sorting an index>>=
(defmethod sort-indexentries ((index base-index))
  (let ((temp-list '()))
    (maphash #'(lambda (key idxent)
                 (declare (ignore key))
                 (setq temp-list (cons (cons (get-sort-key idxent) idxent) temp-list)))
             (get-entry-table index))
    (set-entry-list (sort temp-list
                          #'(lambda (element-1 element-2)
                              (strlist< (car element-1) (car element-2))))
                    index)))

(defun strlist< (string-list-1 string-list-2)
  (declare (inline))
  (do ((rest-1 string-list-1 (cdr rest-1))
       (rest-2 string-list-2 (cdr rest-2)))
      ((or (endp rest-1) (endp rest-2)
           (string/= (first rest-1) (first rest-2)))
         (or (endp rest-1)
             (if (endp rest-2)
                 'nil
                 (string< (first rest-1) (first rest-2)))))))
@ %def sort-index strlist<

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Processing an index}

After the index is filled with indexentries our first task is to sort the index.
Additionally we need to process all indexentries. Because we decide to
make the processing of the indexentries directly driven by the markup,
we simply markup the index and start right out of the box.

<<Processing an index>>=
(defmethod process-index ((index base-index))
  (sort-indexentries index)
  ;(set-entry-table nil index)
  ;(markup-index)
  index)
@ %def process-index

<<Export-list of submodule \module{index}>>=
(export '(process-index))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The module root}

<<*>>=
;; $Id$

(in-package 'index)
(provide 'index)

(use-package "CLOS")
(use-package "XP")
(require "base")
(use-package "BASE")
(require "locref")
(use-package "LOCREF")
(require "idxstyle")
(use-package "IDXSTYLE")

;; The following construct must be separated since the definition of
;; the *feature* :ORDRULES was added via loading the package
;; "idxstyle" but is only active *after* reading the whole SEXP.

#+:ORDRULES (use-package "ORDRULES")

<<Submodule \module{idxentry}>>
<<Submodule \module{ranges}>>
<<Submodule \module{index}>>

<<Pretty-printing>>

(defvar *RCS-Identifier* '( <<RCS-Identifier>> ))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The submodule root}

<<Submodule \module{index}>>=
<<Class \class{base-index}>>
<<Export-list of submodule \module{index}>>

<<Adding an indexentry>>
<<Sorting an index>>
<<Processing an index>>
@

<<RCS-Identifier>>=
("index" . "$Id$")
@


%% $Log$
%% Revision 1.11  1996/04/30 15:54:17  kehr
%% Rewrote large parts of part that ist responsible for adding an
%% indexentry. Moved some parts from idxentry to index and restructured
%% the whole functions that deal with that topic.
%%
%% Revision 1.10  1996/04/29  08:38:09  kehr
%% Forgot some declarations.
%%
%% Revision 1.9  1996/03/28  16:47:36  kehr
%% Changed modules to work together with the foreign package `ordrules'.
%%
%% Revision 1.8  1996/03/13  16:53:26  kehr
%% Don't remember specific changes. Just time to check-in.
%%
%% Revision 1.7  1996/01/31  16:13:31  kehr
%% Still working on th user-interface...
%%
%% Revision 1.6  1996/01/10  16:47:19  kehr
%% Tested and corrected the keyword-markup. Not finished, yet.
%%
%% Revision 1.5  1996/01/10  11:09:00  kehr
%% Re-implemented the submodule `markup' .
%%
%% Revision 1.4  1996/01/09  15:58:36  kehr
%% Corrected minor bugs.
%%
%% Revision 1.3  1996/01/09  14:27:27  kehr
%% Moved submodule `ranges' from module `locref' to this module.
%% Nearly complete rewrite of all submodules. See ChangeLog for further details.
%%
%% Revision 1.2  1995/12/11  17:37:04  kehr
%% Added semi-formal description of the location-refernce handling.
%%
%% Revision 1.1  1995/12/05  18:46:32  kehr
%% Added module `index' and restructured some parts.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Revision 1.5  1995/07/27  23:59:03  kehr
%% Added support for keword-markup.
%%
%% Revision 1.4  1995/07/23  20:48:34  kehr
%% Major changes in the location-reference-processing. Full support for
%% merge-to and separate-mixed--rules. The whole processing of
%% location-refernces is more structured now and can be easier maintained.
%%
%% Revision 1.3  1995/07/15  20:50:23  kehr
%% Added markup-support for location-references, sorting of indexentries
%% and separation of location-reference-lists into location-class
%% subgroups.
%%
%% Revision 1.2  1995/07/11  23:33:08  kehr
%% Added indexclass-structure as assoc-list. Completed
%% indexentry-inserting with merge-insert-feature. Now we are nearlx
%% finished with the data-setup and can start to handle the
%% location-references.
%%
%% Revision 1.1  1995/07/11  00:47:44  kehr
%% Now starting to work on a full index. Detection of indexclasses is
%% nearly finished an we can start to define indexentries to make that
%% thing work.
%%

%% Local Variables:
%% mode: lisp
%% TeX-master: t
%% End:
